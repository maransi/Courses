Clean Architecture Essencial ( ASP.NET Core com CSharp ) - Macoratti
--------------------------------------------------------------------

Introdução
==========

Ambiente
--------

. Ambiente e Ferramentas usadas no curso

    . .Net Core SDK 6

    . ASP.NET Core 6

    . VSCode

    . SQLite

. Instalação do .NET Core 

        wget https://dot.net/v1/dotnet-install.sh
        chmod +x dotnet-install.sh
        ./dotnet-install.sh -c 3.1
        ./dotnet-install.sh -c 5.0
        ./dotnet-install.sh -c 6.0
        ./dotnet-install.sh -c 7.0

        dotnet --version

        # insira as linhas abaixo no arquivo ".bashrc"
        export PATH="home/$USER/.dotnet:/home/$USER/.dotnet/tools:$PATH"
        export DOTNET_ROOT=/home/$USER/.dotnet/

        source ~/.bashrc

        sudo ln -s /home/$USER/.dotnet/dotnet /usr/bin/dotnet

        dotnet --version
        dotnet --list-runtimes
        dotnet --list-sdks

        cd /home/$USER/Download

        wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.0g-2ubuntu4_amd64.deb
        sudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb


. Instalação das extensões do VSCode

    . Acessar a pagina de download da microsoft:

        https://code.visualstudio.com/download

    . Baixar o arquivo .deb 

    . Abrir o terminal e acessar a pasta Downloads

    . Executar o comando abaixo:

        sudo dpkg -i code_1.37.1-1565886362_amd64.deb

    . Atalhos

        Alt + 1, 2, 3, 4, ...	Posiona na aba no.
        Ctrl + b				Ativar o menu lateral esquerdo 
        Ctrl + Alt + P			Para ativar a linha de comandos 
        Ctrl + P 				Localiza um determinado arquivo
        Ctrl + W				Fecha a aba corrente
        Ctrl + Shift + W		Fecha todas as abas abertas

        Ctrl + Rolagem do Mouse	
                sobre as abas 
                abertas			Faz a rolagem das abas.

        Ctrl + K + C ou 
        Ctrl + /				Comenta linha atual, ou bloco selecionado

        Ctrl + K + U ou
        Ctrl + /				Descomenta linha, ou bloco selecionado.

        Ctrl + Shift + 
                Acento Agudo	Abre o terminal na parte inferior

        Ctrl + X				Apaga linha
        Ctrl + H				Localiza e atualiza uma expressão
        Ctrl + F2				Selecione um texto e pressionando Ctrl + F2 
                                muda todos os textos equivalente a medida
                                que vai se digitando
        Alt + Arrow(up/Down)    Move a linha para cima, ou para baixo.
        Ctrl + Shift + O		Abre a lista de funções/métodos da classe atual
        Ctrl + G				Posicionar na linha No. que for digitado
        Alt + Backspace			Apaga palavra inteira a esquerda
        Ctrl + Shift + .		Mostra os métodos da classe
        Ctrl + Shift + L		Altera dinamicamente em todo o arquivo a palavra que está sendo alterada

    . Instale as extensões abaixo:

        C# 
        C# Extensions (JosKreativ)
        C# XML Documentation Comments
        C# Snippets
        vscode-solution-explorer
        ASP.NET Helper
        RapidApi
        Bracket Pair Colorization Toggler
        Razor Snippets
        Libman
        Docker
        vscode-icons (Opcional)
        VZ Dotnet File Template
        Auto-Using for C#
        Error Lens


        . Testar

            Dotnet Solution Explorer
            Dotnet New Extension
            Net Core Extension Pack
            C# Utilities
            Nuget Package Manager
            Visual Nuget
            C# Developer Extension Package
            Auto closet tag
            C# Snippets

    . Configurações:

        . Digite Ctrl K+S, localize o item "Delete Line" e configure Ctrl + D
        . Acesse View / Minimap para retirar o scroll de código da direita
        . Acessar configurações, ir em "Settings", Text editors, Sugestions:
            . Na opção "Accept Suggestion On Enter" deixar como off
            . Na opção "Suggest: Insert Mode" deixar como replace
            . Na opção "Quick Suggestions Delay" deixar como 1000
            

. Instalação o "DB Browser for SQLite" para realizar as consultas no banco de dados

    sudo apt-get update && sudo apt-get upgrade

    sudo apt-get install sqlite3

    sqlite3 --version

    sudo apt-get install sqlitebrowser




Conceitos e Fundamentos
=======================

Aula 9 - Modelo Anêmico
----------------------

    . Definições

        . O modelo de domínio anêmico é um modelo de domínio onde os objetos que representam as 
            entidades do domínio contêm pouca ou nenhuma lógica de negócio (validações, cálculos,
            regras de negócio, etc.)

        . Um modelo de domínio anêmico é um modelo sem compratamentos onde temos diversas 
            propriedades com get e set públicos definidas sem lógica alguma e onde o cliente do 
            domínio tem controle sobre como instanciar e modificar o domínio.

            . Conceito de OO é perdido.

            . Regras de negócio espalhada em vários objetos.

            . Mais parecidos com estilo de programação procedural. Parecidos com objetos DTOs.

    . Exemplos de modelos anêmicos

        public class Pedido                                         public class PedidoServide
        {                                                           {
            public int Id {get; set; }                                  public void AddItem( int Id, itemPedido item )
            public string ClienteId {get; set; }                        {
            public decimal Desconto {get; set; }                            // validações
            public DateTime? DataPagamento {get; set; }                 }
            public List<ItemPedido> Itens {get; set;}                   public void DescontoPedido( int Id, decimal desconto){...}
                                                                        public void PagamentoPedido( int id) {...}
        }                                                           }
            |
            v                                                                   ^
                                                                                |
        Não tem lógica nenhuma é preciso colocar a lógica em outra classe   ----+


        . Contém somente prorpidades com get e set públicos
        
        . Não possuem validações nem comportamentos

        . Não possuem gerenciamento de estado, permitindo que objetos com estado inconsistente sejam cirados

        . Permitem que outros objetos criem instâncias e modifiquem o domínio.

    . Modelos anêmicos - Problemas

        . O cliente precisa interpretar o objetivo e o uso da classe e a lógica é enviada para outras classes,
            denomidadas serviçoes da classe de domínio

        . Violação do encapsulamento;

        . Lógica de negócios duplicada;

        . Não é possível garantir que as entidades no modelo estejam em u estado consistente;

        . Baixa coesão;

    . Iremos adotar as orientações do Domain-Drive Design. Pesquisar padrões como: Entity, Value Object, Aggregate

        https://dev.to/guisfits/easycommerce-01-introducao-ao-ddd-kik
        https://dev.to/guisfits/implementando-domain-driven-design-3d1h

        . Entity
            
            https://www.codeproject.com/Articles/4293/The-Entity-Design-Pattern
            https://dotnettutorials.net/lesson/repository-design-pattern-csharp/

        . Value Object 

            https://www.macoratti.net/20/11/c_valueobj1.htm
            https://www.codeproject.com/Articles/1046193/Value-Object-Design-Pattern-in-Csharp
            https://www.codeproject.com/Articles/5354124/Csharp-Value-Object-Pattern-Data-Transfer-Object-P#:~:text=Value%20Object%20Pattern%20%2D%20Definition,based%20on%20identity%2Freference).

        . Agreagate

            https://code-maze.com/csharp-design-pattern-aggregate/        

    . Vamos atualizar o modelo com dados, lógica e regras de negócio.

    . Modelo anêmicos - Enriquecendo o modelo

        . Usar propriedades com setters privados ( e as classes como "sealed" )

        . Validar estado da entidade

        . Evitar construtores sem parâmetros.

        . Definir invariantes

        . Trazer as regras de comportamentos dos serviços para o modelo de domínio.

        . Usar os conceitos da programação OO

        . Cuidado e atenção ao usar ferramentas ORM (EF Core)

    . "sealed"

        . Quando aplicado a uma classe, o modificador sealed impede que outras classes herdem dela. 
            No exemplo a seguir, a classe B herda da classe A, mas nenhuma classe pode herdar da classe B.

            class A {}

            sealed class B : A {}

        . O modificador "sealed" também pode ser usado com métodos para evitar que os métodos sejam sobrescritos 
            nas classes filhas.


    . Enriquecendo o modelo - Exemplo

        public class Cliente                                    public sealed class Cliente
        {                                                       {
            public int Id{ get; set; }                              public int Id { get; private set; }
            public string Nome { get; set; }                        public string NOme {get; private set; }
            public string Endereco { get; set; }                    public string Endereco { get; private set; }
        }                                       
                                                                    public Cliente (int id, string nome, string endereco)
                                                                    {
                                                                        Validar( id, nome, endereco);

                                                                        Id = id
                                                                        Nome = nome;
                                                                        Endereco = endereco;
                                                                    }

                                                                    public void Update( int id, string nome, string endereco )
                                                                    {
                                                                        Validar( id, nome, endereco);

                                                                        Id = id
                                                                        Nome = nome;
                                                                        Endereco = endereco;
                                                                    }

                                                                    private static void Validar( int id, string nome, string endereco )
                                                                    {
                                                                        ...
                                                                    }
                                                                }

Aula 10 - Separação dos conceitos ( Separation of Concerns )
------------------------------------------------------------

    . Separtion of Concerns - Soc: Separação de conceitos

        . Não se deve misturar conceitos e/ou responsabilidades diferentes denro do design ou do código de um projeto de software.

        . A violação deste princípio causa cpodigo duplicado com mais de uma responsabilidade, vilando també, os princícpios SOLID
            da responsabilidade Ùnica (SRP) e o princípio DRY Don´t Repeat YourSelf.

        . Exemplos de aplicação do conceito:

            . Separar a interface do usuário (front-end) da lógica de negócios (back-end)

            . Separar o código de acesso a dados do código da apresentação dos dados 

            . Separar o projeto em diferentes módulos/camadas com responsabilidade distintas

            . Criar componentes/classes/funções que realizam apenas uma única tarefa com eficiência.

        . A aplicação da Separação dos Conceitos/Responsabilidades envolve dois processos:

            . Reduzir o acoplamento

            . Aumentar a coesão.

            . Acoplamento
                
                . Acoplamento é o nível de dependência/conhecimento que pode existir entre os componentes do sistema. Quanto maior o acoplamento
                    entre os componenetes do sistema maior será dependêmcia entre eles, e mais difícil será manter, reusar e estender o sistema.

                . Quando há um baixo acoplamento, um componente consegue operar de forma praticamente independente do outro. Alto acoplamento 
                    já implica em uma conexão forte entre os dois, que pode torná-los até indistinguíveis

            . Coesão

                . A coesão é o grau com o qual um módulo tem uma responsabilidade única e bem definida

                . Coesão é o nível de integridade interna dos componentes do sistema. Quanto maior a coesão enter os componentes mais definidas 
                    são suas responsabilidades sendo mais difícil desembrar o componente em outros componentes.

            . Portanto quanto menor o acoplamento e mais alta a coesão de um componente ou módulo do sistema mais fácil ele será de matner, 
                reusar e estender.

        . Vantagens

            . Facilita a manutenção. A não duplicação do código e as responsabilidades bem definidas dos componentes do projeto
                tornam o sistema mais fácil de manter.

            . Melhor reutilização do código. O principal benefício de reutilizar o código pe a reduçao dos custos de manutenção. Sempre que
                você precisar estender a funcionalidade ou corrigir um bug - é muito menos doloroso fazer isso quando você tem certeza de que ele
                parece em apenas um lugar.

            . Melhor clareza de código. É muito mais fácil entender o que está acontecendo no programa quando cada módulo tem uma API concisa
                e clara com um conjunto de métodos com escopo lógico e bem definido.

            . Melhora a testabilidade. Móduglo independentes com guncionalidade e escopo adequado e com isolamento do resto do aplicativo
                são fáceis de testar. Você nãp precisa configurar o ambiente inteiro parar ver como seu módulo funciona, basta substituir 
                os módulos reais por simulações ou fontes de dados falsas.

            . Permite uma evolução mais rápida do projeto. Quer seja um novo recurso ou uma atualização de um recurso existente, o isolamento 
                dos módulos ajuda a definiri o  escopo das áreas do projeto que podem ser afetadas pela mudanças, acelerando assim o desenvolvimento.

Aula 11 - Dependency Inversion
------------------------------

    . Para entender como funciona a inversão de dependência no .NET veja o resumo do curso "DI - Dominando Injeção de Dependência - Balta".

    . A direção da dependenência em uma aplicação deverá ser na direção da abstração e não nos detalhes de impplementação.

    . Módulos de alto nível não devem depender de módulos de baixo nível. Ambos devem depender de uma abstração.

    . Abstrações não devem depender de detalhes. Detalhes devem depender de abstrações.

    . Módulos de alto nível são classes da camada de negócio que encapsulam uma çógica complexa.

    . Módulos de baixo nível são cçasses da camada de infaestrutura que implementa operações básicas como acesso a dados, 
        ao disco, protocolos de rede, etc.

    . As abstrações seria interfaces ouclasses abstratas que não possuem implementação.

    . Assim as classes da camada de negócio não devem depender das classes da camada de infraestrura mas 
        devem depender de interfaces ou classe abstratas

    . Exemplo 1. Via Interface - A implementação da injeção de dependência via interface -  Interface Injection -  
                    utiliza uma interface comum que outras classes necessitam implementar para injetar a dependência.

        namespace DIP;

        public interface IDataService       ----------------------------------------+
        {                                                                           |
            public void Save(string message);                                       |
        }                                                                           |
                                                                                    |
        public class DatabaseService: IDataService  ---------------------------->   |
        {                                                                           |
            public void Save(string message)                                        |
            {                                                                       |
                Console.WriteLine("Save the message into the database");            |
            }                                                                       |
        }                                                                           |
                                                                                    |
        public class Logger                                                         |
        {                                                                           |
            private readonly IDataService _dataService;                             |
                                                                                    |
                                +---------------------------------------------------+
                                |  Não dependemos de detalhes, somente da abstração
                                V
            public Logger(IDataService dataService)
            {
                _dataService = dataService;
            }

            public void Log(string message)
            {
                _dataService.Save(message);
            }
        }

        public class Program
        {
            public static void Main(string[] args)
            {
                var logger = new Logger(new DatabaseService());
                logger.Log("Hello");
            }
        }



    . Exemplo 2. Via Construtor - A implementação da injeção de dependência via construtor - Construtor Injection - consiste em 
                    passar as dependências de um objeto para o seu construtor.

        namespace DI
        {                                              IOC
            class programa          Unconcerned logic shifted the externa entity
            {                                           ^
                static voida Main( string[] args)       |
                {                                       |
                    Customer obj = new Customer( New SQLServer() );
                }                                       |
                                            Dependency   |
                class Customer             Injection    |
                {                          +------------+
                    private IDal _dal;     |
                                            V

                    public Customer( IDal obj)
                    {
                        _dal = obj;
                    }

                    public bool validate()
                    {
                        return true;
                    }

                    public void Add()
                    {
                        if (validate())
                        {
                            dal.Add();
                        }
                    }

                }
            }
        }
        
    . Exemplo 3 - Via Propriedades. A implementação da injeção de dependência via propriedades - Setter Injection - não força 
                    a dependência ser passada para o construtor. Ao invés disso, as dependências são definidas em 
                    propriedades públicas expostas pelo objeto.

        public class Cliente
        {
        public Cliente() {}

            private IPedido meuPedido;

            public IPedido Pedido {
            get {
                    if (meuPedido == null) {
                        throw new MemberAccessException("meuPedido não foi inicializado");
                    }
                return meuPedido;
                }
                set { meuPedido = value; }
            }
        }

    . Resumo

        . Princípio da inversão de dependência (DIP)    É um princípio que sugere uma solução para o problema da dependência mas não diz
                                                        como implementar ou que técnica usar.

        . Injeção da dependência (DI)                   Padrão de projeto usado para implementar a inversão da dependência. Permite
                                                        injetar a implementação concreta de um componente de baixo nível em um componente
                                                        de alto nível.

        . Inversão de Controle (IoC)                    Outro princípio, que sugere uma forma de aplicar a inversão da dependência permitindo 
                                                        que componentes de alto nível dependam de uma abstração e não de um componente de
                                                        baixo nível.

        . Contâiner IoC (Contâiner de injeção de dependência )  É um framework que permite fazer a injeção de dependência de forma automática 
                                                                nos componentes.

Aula 12 - Padrão Repository
---------------------------

    . O que é o padrão Repository?

        . O padrão "Repository" faz a mediação entre o domínio e as camadas de mapeamento de dados, agingo como uma coleção de objetos de 
            domínio em memória.

        . Um repostório é essencialmente uma coleção de objetos de domínio em memória, e, com base nisso o padrão "Repository" permite 
            desacoplar o modelo de domínio do código de acesso a dados.

        . Ao utilizar o padrão "Epository" você pode realizar a persistência e a separação de interesses em seu código de acesso a dados 
            visto que ele encapsula a lógica necessária para persistir os objetos do seu domínio na sua fonte de dados.

    . Implementação e Tipos de repositórios

        . Em uma implementação padrão podemos começar definindo uma "interface" que atuará como a nossa fachada de acesso aos dados e a 
            seguir definiir a implementação na classe concreta.

        . Podemos implementar os seguintes tipos de repositórios:

            . Repositório Genérico

            . Reposítorio Específico

        . E podemos realizar uma implementação síncrona ou assíncrona (Task, async/await).

        . Implementação (Como fazer)

            1. Criar uma "interface" ou classe abstrata e definir o contrato com os métodos do repositório.

            2. Criar a classe concreta que implementa a "interface"

                            Repositório Genérico                                    Repositório Especifico
                    +------------------------------+                            +---------------------------+
                    |                              |                            |                           |
                IRepository<T>              Repository<T>               IProductRepository          ProductRepository

                Add()                       ...                         Add()                       ...
                Remove()                    ...                         Remove()                    ...
                Get()                       ...                         Get()                       ...
                GetId( int id )             ...                         GetId( in id )              ...

                Domain ou Application       Infrastructure              Domain ou Application       Infrastructure

        . Exemplo "Repositório Genérico":

            +-- public interface IRepository<T>: where T class ---------->  public class Repository<T>: IRepository<T> where T: class
            |    {                                                           {
            |        IEnumerable<T> GetAll();                                    ... // Implementação
            |                                                                }
            |        T GetById( int id );
            |
            |        void Add( T item );
            |
            |        void Update( T item );
            |
            |        void Delete( T item );
            |    }
            |
            |
            |    public classe CustormerController: Controller
            |    {
            |        private readonly IRepository<Customer> _custormerRepository;
            |
            +---------------------------------------+
                                                    | Injeção de Dependência
                                                    V
                    public CustomerController( IRepository<Customer> repo)
                    {
                        _custormerRepository = repo;
                    }
                }

        . Exemplo "Repositório Genérico":

            +-- public interface ICustomerRepository --------------------->  public class CustomerRepository: ICustomerRepository
            |    {                                                           {
            |        IEnumerable<T> GetAll();                                    ... // Implementação
            |                                                                }
            |        T GetById( int id );
            |
            |        void Add( T item );
            |
            |        void Update( T item );
            |
            |        void Delete( T item );
            |    }
            |
            |
            |    public classe CustormerController: Controller
            |    {
            |        private readonly ICustomerRepository _custormerRepository;
            |
            +---------------------------------------+
                                                    | Injeção de Dependência
                                                    V
                    public CustomerController( CustomerRepository repo)
                    {
                        _custormerRepository = repo;
                    }
                }

        . Qual utilizar? Genérico ou Especifico?

            . Um repositório genérico pode ser usado por qualquer entidade da camada de negócios e com isso economizarmos código.

            . Ocorre que cada entidade da camada de domínio pode possuir sua particularidades distintas de outras entidades e isso 
                pode inviabilizar o uso de um repositório genèrico.

            . Assim para decidir é preciso fazer uma análise prévia do modelo de domínio e das particularidades de cada entidade.

        . Benfícios:

            . Minimiza a lógica de consultas na sua aplicação evitando consultas esparramdas pelo seu código.

            . Encapsula a lógica das consultas em um repositório

            . Desacopla a sua aplicação dos framworks de persistência como o EF Core.

            . Facilita a realização de testes de unidade em sua alicação (repositório fake)

            . Centraliza a lógica de acesso a dados facilitando a manutenção.

Aula 13 - Padrão MVC
--------------------

    . O padrão MVC fornece uma maneira de separa a funcionalidade e responsabilidade envolvidas com a manutenção e apresentação 
        dos dados de uma aplicação usando 3 componentes:

        . O Model           Representa os daos a serem tratados e não inclui detalhes de implementação.

        . A View            Representa o componente de interface com o usuário (UI)  e está vinculado ao "Model"

        . O Controller      Fornece um mecanismo para o usuário interagir como sistema definindo como a interface do usuário vai 
                            reagir a ação do usuário. É responsável por trocar e interpretar mensagens entre a "View" e o "Model".

                    Request                    Data
                / --------->  Controller  <----------->   Model
                /               ^ |     
                /                | |
            User                  | | Data
                \                | |
                \  Response     | V
                \ <---------- View

        . Padrões de comunicação:

            . Permitido

                . Os usuários podem interagir com uma "View"

                . "Views" podem interagir com "Controller"

                . "Controller" podem interagir com "Views"

                . "Controller" podem se comunicar com outros "Controller"

                . "Controller" podem se comunicar com o "Model"

            . Não permitido:

                . Os usuários não podem interagir diretamente com o "Model".

                . "Views" não podem interagir diretamente com outras "Views".

                . "Views" não podem interagir diretamente como "Model".

                . "Model" não podem interagir com outros "Models".
            
    . Benefícios:

        . A "View" e o "Model" são desacoplados ou dissociados. Isso significa que você pode ter muitas "Views" associadas 
            com um determinado model.

        . A dissociação "View-Controller" permite que você altere a forma como uma aplicação responde à entrada do usuário 
            sem alterar o modo de exibição, permitindo que a interface do usuário "view" seja alterada sem alterar a maneira 
            como o aplicativo responde à entrada do usuário.

        . A separação das responsabilidades permite que diferentes membros da equipe possam se concentrar em uma parte da 
            aplicação que melhor se alinha com suas respcetivas habilidades.

        . Como o padrão MVC gerencia múltiplos visalizadores usando o mesmo modelo, é fácil manter, testar e atualizar 
            mais de um sistema.

    . Padrão MVC vs. Arquitetura em 3 Camadas (MVC não é 3 camadas)

        . Padrão MVC                    Está relacionado com a arquitetura da aplicação e em como os componentes se comunicam.

        . Arquitetura em 3 camadas      Está relacionada com a arquitetura do Sistema onde você divide as responsabilidade em 
                                        camada de apresentação, de negócio e de acesso aos dados.


            Arquitetura em 3 camadas
            ------------------------

                    UI                                              Controller
                                                                        /\          O padrão MVC é triangular
                    |                                                  /  \         a view aciona o controller, o 
                    |                                                 /    \        controller atualiza o modelo, e 
                    v   Conceitualmente a                         Model --> view    a view é atulizada pelo modelo.
                        arquitetura de três 
                   BLL  camadas é linear.        
                        As dependências são 
                    |   definidas de cima
                    |   para baixo
                    V

                   DAL

        . Os conceito se complementam e podem coexistir harmonicamente sem conflitos. Você pode usar o padrão MVC para a 
            camada de apresentação de uma arquitetura em camadas.

                                                                +------------------+
                    UI  ------------------------------------->  |    Controller    |
                                                                |       /\         |
                    |                                           |      /  \        |
                    |                                           |     /    \       |
                    v   As camadas dizem como                   | Model --> view   |
                        agrupar os componentes e                +------------------+
                   BLL  
                        O MVC diz como interagem os
                    |   componentes
                    |   
                    V

                   DAL
        
Aula 14. Padrão CQRS
--------------------

    https://www.youtube.com/watch?v=G0yi5PTzhLA&t=297s
    https://balta.io/blog/aspnet-core-cqrs-mediator

    https://balta.io/blog/clean-code

    . CQRS ( Command Query Responsability Segregation ) ou, numa traução livre, segregação de responsabilidade consulta 
        e de comando, e é utilizado para aplicar modelos diferentes para operações de leitura e gravação.

        . Separar a responsabilidade de ler dados, de escrever dados.

    . O CQRS é um padrão de projeto arquitetural para separar os processos de leitura e gravação da sua aplicação. As 
        alterações de dados são realizados via "Commands" e a leitura de dados são realizados via "Queries".

        . Commands  representam tudo o que altera o estado de uma entidade (inser, update, delete ).

        . Queries   não alteram estado da entidade (select)

    . A utilização do CQRS e indicada para um cenário onde existe uma alta demanda de consumo de daos com operações de 
        leitura e escrita feitas de forma bem intensa, com grande volume de dados.

    . Cenário clássico:

                        Presentation
                            &
                        Application
                        ||        ||
                        ||        ||
                        ||        ||    Command
                        ||        ||       &
                        ||        ||     Query
                        ||        ||
                        \/        \/
                       Banco de dados ==>   Usar a mesma base de dados
                                            para leitura e gravação

    . Cenário com CQRS:

                        Presentation
                            &
                        applications        +-----------+
                        ||        ||        |   Query   |
                        ||        ||    +---------+     |
                        ||  +---+ ||    | Command |-----+
                        ||  |   | ||    +---------+   
                        ||      v ||     
                        ||  ^     ||
                        ||  |   | ||
                        ||  +---+ ||
                        \/        \/
                       Banco     Banco     | Temos aqui a separação da escrita e da leitura
                         de        de      > (Podemos usar banco de dados distintos c/sincronização)
                       dados     dados     | 
                      (Leitura) (Gravação)

        . Separar o tipo da consulta (escrita/leitura) em bancos distintos. Um banco para "SELECTs" e outro
            somente para "UPDATEs | INSERTs| DELETEs".

    . Funcionamento:


        +-----+
        |     |         +---------------------------+
        |     |         |       Query Model         |
        |     |         |   +-------------------+   |
        |     |  Query  |   |                   |   |
        |     |<--------|---|       +---+       |   |
        |     |         |   |       |   |       |   |
        |     |         |   |       +---+       |   |
        |     |         |   |                   |   |               
        |     |         |   |       +---+       |   |               +-----------+
        |     |         |   |       |   |       |<--|---------------|           |
        |     |         |   |       +---+       |   |               |           |
        | UI  |         |   +-------------------+   |               |           |
        |     |         |                           |               |     DB    |
        |     |         |       Command Model       |               |           |
        |     |         |   +-------------------+   |               |           |
        |     | Command |   |                   |   |               |           |
        |     |---------|-->| +---+      +---+  |   |               |           |
        |     |         |   | |   |------|   |  |---|-------------->|           |
        |     |         |   | +---+      +---+  |   |               +-----------+
        |     |         |   |   |          |    |   |
        |     |         |   | +---+        |    |   |
        |     |         |   | |   |--------+    |   |
        |     |<--------|---| +---+             |   |      
        |     |         |   +-------------------+   |
        |     |         +---------------------------+
        |     | 
        +-----+
        
        . O CQRS separa leituras e gravações em modelos diferentes, usando comandos para atualizar dados e 
            consultas para ler dados.

        . Os comandos devem ser baseads em tarefas, e não centrados em dados.

        . Os comandos podem ser colocados em uma fila para processamento asincrono, em ves de serem 
            processaods de forma sincrona

        . As consulta nunca modeificam o banco de daos, Uma consulta retorna um DTO que nao encapsula nenhum 
            conhecimento de domínio.

    . Para obter um maior isolamento, você pode separa fiscamente os dados de leitura dos dados de gravação. 
        Nesse caso, o banco de dados de leitura pode usar seu próprio esquema de dados otimizado para consultas.

    . Beneficios

        . Escala independentes                  O CQRS permite que as cargas de trabalho de leitura e gravação sejam
                                                escalonadas independentemente o que pode resultar em menos contenções 
                                                bloqueios.

        . Esquemas de dados otimizados          O lado de leitura pode usar um esquema otimizado para consultas, enquanto 
                                                o lado de gravação usa um esquem otimizado para atualizações.

        . Segurança                             É mais fácil garantir que apenas as entidades de domínio corretas estejam
                                                executando gravações nodados.

        . Separação de responsabilidades        A segregação dos lados de leitura e gravação pode resultar em modelos mais 
                                                flexiveis e fáceis de manter. A maior parte da lógica de negócios complexa 
                                                entra no modelo de gravação. O model de leitura pode ser relativamente simples,
                                                sem o uso de "Foreign Keys | Triggers", ou bancos de dados em memória.

        . Consulta mais simples                 Ao armazenar uma visualizaçõa no banco de dados de leitura, o aplicativo pode
                                                evitar junções (joins) complexas durante a consulta tornando as consultas mais 
                                                simples.

    . Implementação do CQRS no .NET

        . Usaremos a biblioteca "MediatR" (pattern Mediator)                          

        . E o pacote MediatR.Extensions.Microsoft.DependencyInjection

        . A partir da aula 57 iremos ver a implementação do padrão CQRS num projeto.

    . A utilização do CQRS não é recomendada quando:

        . O domínio ou as regras de negócios forem bem simples;

        . Uma interface de usuário simples no estilo CRUD e operações de acesso a dados forem suficientes para resulver o problema.


Aula 15 - Arquiteura Monolítica
-------------------------------

    . A arquitetura monolítica é um sistema único, não dividido, que roda em um único processo, ou seja, é uma aplicação na qual 
        diferentes componenetes estão ligados a um único programa dentro de uma única plataforma.

    . Na arquittura monolítica o núcleo do comportamento da aplicação é executado em seu próprio processo e a aplicação inteira é
        implantada como uma única unidade.

    . Um aplicativo criado com essa arquitetura pode escalar verticalmente aumentando o poder das máquinas em que a aplicação roda 
        ou horizontalmente com a adição instâncias atrás de um Load Balancer.

    . Vantagens      

        . Mais simples de desenvolver: A organização fica concentrada em um único sistema e muitos desenvolvedores estão 
            familiarizados com este modelo sendo que o desenvolvimento inicial é mais rápido.

        . Simples de fazer o deploy para o servidor: Fazemos o deploy de um único pacote final

        . Exige uma equipe menor: Necessita de um time menor para desenvolver e manter a aplicação.

    . Desvantagens

        . Manutenção: A aplicação se torna cada vez maior de acordo com o seu tamanho, o código será cada vez mais difícil de entender 
            e o desagio de fazer alterações rápidas e ter que subir para o servidor só cresce.

        . Alterações: Para cada alteração feita, é necessário realizar um novo deploy de toda a aplicação.

        . Fagrilidade: Uma linha de código que subiu errada pode quebrar todo o sistema e ele ficar totlamente inoperante.

    . Um exemplo de uma aplicação monolítica são os projetos gerados pelos templates do ASP.NET Core MVC.

        . Dentro da mesma aplicação ele cria as camadas:

            . Data Access Logic:

                . EF Migrations

                . EF DbContext and model design

            . Models

            . Application Services (interfaces and implementations)

            . Presentation Logic ( Views )

            . Application Entru Point and Configuration ( appSettings.json, *.csproj, Program.cs )

        . Desvantagens:

            . O no. de pastas tende a crescer e as pastas não estão agrupadas em ordem

            . A lógica de negócio está espalhada entre as pastas Models e Services.

            . Não existe umaindicação clara das dependências entre as classes na pastas.

            . Falta de organização leva ao código espaguete.

    . Evolução

        . As aplicações que usam a arquitetura monolítica podem se beneficiar usando a separação lógica de responsabilidades em camadas.

        . Para isso as aplicações evoluem para soluções com váriaos projetos onde cada projeto reside em uma camada com responsabilidades 
            especificas.

        . Podemos ter uma evolução de uma arquitetura monolítica de projetos único para uma arquitetura monolítica em camadas também 
            conhecida como arqutetura em camadas.

Aula 16 - Arquitetura em Camadas
-------------------------------

    . A arquitetura em camadas visa a crição de aplicativos modulares, de forma que cada camada possui uma responsabilidade e onde a 
        camada superior se comunica com a camada inferior e assim por diante, fazendo com que uma camada seja dependente apenas da camada
        imediatamente infeior. 

    . Podemos assim dividir um sistema em uma, duas, três ou ncamadas dependendo do objetivo e da complexidade do sistema.

    . Dependendo do conteto as camadas podem ser lógicas (Layers) ou físicas (Tiers).

    . Uma das mais conhecias é a arquitetura em três camadas, onde temos as camadas de interface (UI), a camada lógica dos negócios (BLL) e 
        a camada de acesso aos dados (DAL).


        +-----------------------------------+
        |   User Interface Layer (UI)       |   Aqui temos a dependência entre as camadas
        | (HTML, Javascript, Razor, CSS)    |   definida de cma para baixo
        +-----------------------------------+
                        |
                        v
        +-----------------------------------+
        |   Business Logic Layer (BLL)      |   A camada UI depende da camada BLL e esta
        |       (.NET, C#, classes)         |   depende da camada DAL
        +-----------------------------------+
                        |
                        v
        +-----------------------------------+
        |     Data Access  Layer (DAL)      |   A comunicação deve passar pela camada de 
        |   (EF Core, SQL Server, MySQL)    |   de negócios (BLL)
        +-----------------------------------+

    . Exemplo de projetos .NET

        Solution
            |
            +-- src
                 |
                 +-- ApplicationCore    <------------- Business/Aplication Model
                 |
                 +-- Infrastructure     <------------- Data Logic (Infrastructure)
                 |                                      . EF Migration
                 |                                      . EF DbContext and model design
                 |
                 +-- Web                <------------- Presentation Logic
                 |                                      . wwwroot
                 |                                      . Controllers
                 |                                      . Services
                 |                                      . ViewModels
                 |                                      . Views
                 |
                 +-- Tests              <------------- Automated Tests

        . Os usuários interagem com camada de UI

        . A camada de UI interage apenas com a camada de negócios (BLL)

        . A camada de negócios pode chamar a camada de acesso a dados (DAL)

        . A camada de UI não deve interagir com a DAL diretamente

        . A implantação é feita como uma unidade única pois ainda estamos na arquitetura Monolítica.

        . Vantagens

            . Com a organização do código em camadas podemos reutilizar a funcionalidade de baixo nível em todo o aplicativo

            . Com uma arquitetura em camadas, os aplicativos podem impor restrições sobre quais camadas podem se comunicar com 
                outras camadas.

            . Essa arquitetura ajuda a atingir o encapsulamento.

            . Quando uma camada é alterada ou substrituida, apensa as camadas que interagem com ela serão afetadas.

            . As camadas ( e o encapsulamento) tornam muito mais fácil substituir a funcionalidade dentro do projeto.

        . Desvantagens

            . As dependêmcias em tempo de compilação são executadas de cima para baixo

            . Assim a camada de negócios (BLL)  depende dos detalhes de implementação da camada de acesso aos dados.

            . Testar a lógica de negócio nesta arquitetura é difícil pois exige um banco de dados de teste.

            . Para resolver esse problema podemos usar a inversão da dependência em uma arquitetura mais robusta como a "Arquitetura
                Cebola (Onion Archittecture).


Aula 17. Arquitetura Cebola
---------------------------

    . Arquitetura Cebola (Onion Architecture)

        . Acesse a imagem abaixo para entender as camadas da arquitetura em cebola:

            https://www.macoratti.net/20/05/net_onion11.jpg

        . A arquitetura de cebola está baseada no princípio da inversão de controle e é composta por várias camadas concêntricas que se 
            interconectam em direção ao núcleo que representa o domínio. Ela não depende da camada de dados como nas arquiteturas em 
            várias camadas, mas dos modelos de comínio reais.

        . A "Onion Architecture" resolveu o provlema do acoplamento entre as camadas defnindo camadas a partir do núcleo para a infraestrura.

        . Ela aplica a regra fundamental movendos todos acoplamentos em direção ao centro, sendo que no centro da "Onion Architecture" está 
            o modelo de domínio, que representa os objetos de negócios e co comportamento.

        . Ao redor da camada de domínio existem outras camadas (UI, Infa, repositórios, interfaces) com mais comportamentos.

    . Evolução da arquitetura em camadas para arquitetura cebola.

        Arquitetura em Camadas                          Arquitetura Cebola
        (Layered Architecture)                          (Onion Arquitecture)
        +------------------------+                      +------------------------+
        |   User Interface (UI)  |                      |   User Interface (UI)  |
        +------------------------+                      +------------------------+
                    |                                               |
                    V                                               V
        +------------------------+                      +------------------------+
        |   Business (BLL)       |                      |   Business (BLL)       |
        +------------------------+                      +------------------------+
                    |   A camada de negócio                         ^   A arquitetura cebola 
                    V   depende da camada dados                     |   inverte essa dependência
        +------------------------+                      +------------------------+
        |   Data Access (DAL)    |                      |   Data Access (DAL)    |
        +------------------------+                      +------------------------+
        Produz um forte acoplamento


                            Arquitetura Cebola


        +-----------------------------------------------------------------------------------------------+
        |                                                                                               |   
        |   +-------------------------------------------------------------------------------+           |
        |   |                                                                               |           |
        |   |   +---------------------------------------------------------------+           |           |
        |   |   |                                                               |           |           |
        |   |   |                                                               |           |           |
        |   |   |           +---------------------------------------+           |           |           |
        |   |   |           |                                       |           | Aplication|           |
        |   |   |           |           Business (Domínio)  <-------| Infra <---|-Services<-|-- UI      |
        |   |   |           |                                       |           |           |   Tests   |
        |   |   |           +---------------------------------------+           |           |           |
        |   |   |                                                               |           |           |
        |   |   |                                                               |           |           |
        |   |   +---------------------------------------------------------------+           |           |     
        |   |                                                                               |           |
        |   +-------------------------------------------------------------------------------+           |       
        |                                                                                               |   
        +-----------------------------------------------------------------------------------------------+

    . A Onion Architecture usa o conceito de camadas, mas são diferentes das camadas da arquitetura de três e 
        n-camadas. Vamos ver o que cada uma dessas camadas representa e o que deve conter.

        . Camada de Domínio (a camada mais interna)

            . A camada de domínio reside na parte central da arquitetura Onion, e representa os objetos de negócios e 
                o comportamento. A idéia é ter todos os seus objetos de domínio nesse núcleo. Ele contém todos os objetos 
                de domínio do aplicativo. Além dos objetos de domínio, você também pode ter interfaces de domínio. Essas 
                entidades de domínio não têm dependências. Objetos de domínio também são simples como deveriam ser, sem 
                nenhum código pesado ou dependências. (Se um aplicativo for desenvolvido usando um ORM como o Entity Framework,  
                essa camada conterá classes POCO.)

            . A camada central (domínio) não depende das camadas externas ( UI e Data Access ).

            . As camadas externas são clientes da camada interna.

            . As camadas externas podem ser substituidas mais facilmente.

            . A regra de dependência é sempre de fora pra dentro.

        . Camada de Repositório (Infra, Repository Layer, Data Access)

            . Essa camada cria uma abstração entre as entidades do domínio e a lógica de negócios do aplicativo. Nesta camada, 
                geralmente adicionamos interfaces que fornecem o comportamento de salvar e recuperar objetos, geralmente envolvendo 
                um banco de dados. Essa camada consiste no padrão de acesso a dados, que é uma abordagem mais fracamente acoplada 
                ao acesso a dados. Também criamos um repositório genérico e adicionamos consultas para recuperar dados da fonte,
                mapear os dados da fonte de dados para uma entidade comercial e persistir alterações na entidade comercial na 
                fonte de dados.

        . Camada de Serviços (Service Layer, Application )

            . A camada de serviços mantém interfaces com operações comuns, como Adicionar, Salvar, Editar e Excluir. Além disso, 
            essa camada é usada para se comunicar com a camada da interface do usuário e a camada do repositório. A camada de 
            serviço também pode conter lógica de negócios para uma entidade. Nesta camada, as interfaces de serviço são mantidas 
            separadas de sua implementação, tendo em mente o acoplamento e a separação de responsabilidades.

        . Camada de Interface do Usuário (UI Layer)

            . É a camada mais externa e mantém responsabilidades periféricas como interface do usuário e testes. Pode ser uma 
            aplicação Web, uma API, um projeto de Testes, etc. Essa camada possui uma implementação do padrão da injeção de 
            dependência, para que o aplicativo construa uma estrutura fracamente acoplada e possa se comunicar com a camada 
            interna por meio de interfaces.

    . Vantagens e desvantagens da arquitetura Onion

        . A seguir, estão algumas vantagens da implementação da Onion Architecture:

            As camadas da Onion Architecture são conectadas através de interfaces. As implementações são fornecidas durante o 
                tempo de execução;

            A arquitetura do aplicativo é construída sobre um modelo de domínio;

            Toda dependência externa, como acesso ao banco de dados e chamadas de serviço, é representada em camadas externas;

            Não há nenhuma dependência da camada Interna com camadas externas;

            Os acoplamentos estão voltados para o centro;

            Arquitetura flexível, sustentável e portátil;

            Não há necessidade de criar projetos comuns e compartilhados;

            Pode ser testada rapidamente porque o núcleo do aplicativo não depende de nada;

        . Algumas desvantagens da arquitetura Onion, como a seguir:

            Não é fácil de entender para iniciantes, e tem uma curva de aprendizado. Os arquitetos geralmente confundem a 
                divisão de responsabilidades entre as camadas;

            Utiliza Interfaces em profusão;

    . Acesse o link abaixo:

        # Como construir um projeto DDD em arquitetura cebola
        https://www.macoratti.net/20/07/aspnc_ucddd1.htm

    . A seguir vou me basear em uma arquitetura genérica para criar a aplicação e que será definida da seguinte forma:

        . Apresentação      Cuida da interação com quem vai usar a nossa aplicação;  Podemos ter aqui um projeto Web, Mobile, Web API, 
                            Desktop, etc.
        
        . Aplicação         Cuida da comunicação com o Domínio; Aqui podemos ter: Classes de serviços, Interfaces, DTOs, etc.
        
        . Domínio           É o coração do projeto e deve representar o negócio; Aqui teremos : entidades, Interfaces, Validações, etc.
        
        . Infraestrutura    Cuida do suporte geral às demais implementações e em geral possui uma outra camada que se comunica com 
                            todas as camadas do projeto; Aqui podemos ter Repositórios, Persistência, Mapeamentos, Migrations, Context, etc.   

    . Cada camada acima será um projeto em nossa solução.

        . Dessa forma em nossa implementação criaremos uma solução e 4 projetos :

            Contatos.sln - Solução
            Contatos.Web - projeto Web API Asp .NET Core
            Contatos.Application -  projeto Class Library
            Contatos.Domain - projeto Class Library
            Contatos.Infra - projeto Class Library


Aula 18. DDD - Domain Drive Design
----------------------------------