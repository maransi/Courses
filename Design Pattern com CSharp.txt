Design Pattern com CSharp
-------------------------

. Gang of Four (GoF) 

    . Conjunto de 23 soluções clássicas para problemas de projeto recorrentes no desenvolvimento de 
        software orientado a objetos, documentadas no livro de 1994 "Design Patterns: Elements of 
        Reusable Object-Oriented Software". O termo "Gang of Four" refere-se aos quatro autores 
        do livro: Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides. Esses padrões são 
        categorizados em três tipos (Criacional, Estrutural e Comportamental) e promovem a 
        criação de código mais flexível, reutilizável e sustentáve

    . Os três tipos de padrões GoF

        . Criacionais: Focam em como criar objetos de forma flexível e controlada.
        
            . Singleton: Garante que uma classe tenha apenas uma única instância e fornece um 
                            ponto de acesso global para ela.
            . Prototype: Especifica os tipos de objetos para criar utilizando uma intância prototipada, 
                            criando um novo objeto copiando neste prtotipo.
            . Builder: Separa a construção de um objeto complexo de sua representação, permitindo 
                        que o mesmo processo gere diferentes representações.
            . Factory Method: Cria uma instância de várias classes derivadas, mas permite que 
                                subclasses decidam qual classe instanciar.
            . Abstract Factory: Permite criar famílias de objetos relacionados sem especificar 
                                suas classes concretas.
            . Prototype: Cria novas instâncias através da cópia de objetos existentes.

        . Estruturais: Lidaram com a maneira de compor classes e objetos para formar estruturas maiores.
        
            . Proxy: Forneça um substituto ou marcador para outro objeto, a fim de controlar o acesso a ele.
            . Decorator: Atribui responsabilidades adicionais a um objeto dinamicamente. Os decoradores 
                            fornecem uma alternativa flexível à criação de subclasses para estender a 
                            funcionalidade.
            . Adapter: Permite que objetos com interfaces incompatíveis trabalhem juntos.
            . Facade: Fornece uma interface unificada para um conjunto de interfaces em um subsistema. Facade 
                        define uma interface de nível superior que facilita o uso do subsistema.
            . Flyweight: Uso de compartilhamento para dar suporte a um grande número de objetos de 
                            granularidade fina de forma eficiente.
            . Composite: Composição de objetos em estruturas de árvore para representar hierarquias parte-todo. 
                            O recurso Composite permite que os clientes tratem objetos individuais e 
                            composições de objetos de forma uniforme.
            . Bridge: Desacopla uma abstração de sua implementação para que ambas possam variar independentemente.

        . Comportamentais: Descrevem como objetos interagem e distribuem responsabilidades entre si 
                            de forma flexível e eficiente.

            . Visitor: Representa uma operação a ser realizada nos elementos de uma estrutura de objeto. 
                        O Visitor permite definir uma nova operação sem alterar as classes dos elementos 
                        sobre os quais ela opera.
            . Observer: Define uma dependência de um para muitos entre objetos, de forma que, quando um objeto 
                        mudar de estado, todos os seus dependentes sejam notificados e atualizados automaticamente.
            . Strategy: Define uma família de algoritmos, encapsula cada um e os torna intercambiáveis, 
                        permitindo que o algoritmo varie independentemente do cliente que o usa.
            . Template: Defina o esqueleto de um algoritmo em uma operação, delegando algumas etapas para subclasses.
                        O padrão Template Method permite que subclasses redefinam certas etapas de um algoritmo
                        sem alterar a estrutura do algoritmo.
            . Command: Encapsula uma solicitação como um objeto, permitindo assim parametrizar clientes com
                        solicitações diferentes, enfileirar ou registrar solicitações e oferecer suporte a 
                        operações reversíveis.
            . Iterator: Fornece uma maneira de acessar os elementos de um objeto agregado sequencialmente sem
                        expor sua representação subjacente.
            . Memento: Sem violar o encapsulamento, capture e externalize o estado interno de um objeto para que
                        o objeto possa ser restaurado a esse estado posteriormente.
            . State: Permite que um objeto altere seu comportamento quando seu estado interno mudar. O objeto 
                        parecerá mudar de classe.
            . Mediator: Centralizar a comunicação entre objetos, fazendo com que eles não se comuniquem diretamente 
                        entre si, mas sim através de um objeto mediador.
            . Chain of Responsibility: Permite que uma solicitação percorra uma cadeia de manipuladores, 
                                        onde cada manipulador decide se processa a solicitação ou a 
                                        encaminha para o próximo. 
            . Interpreter: Dada uma linguagem, defina uma representação para sua gramática juntamente com um 
                            interpretador que use a representação para interpretar frases na linguagem.
    
    . Design Patterns adicionais:

        . Simple Factor: Cria um objeto sem expor a lógica de criação para o cliente.
        . Null Object: Fornece um objeto “nulo” com comportamento padrão, em vez de usar null. Em vez de retornar 
                        null e obrigar o código cliente a verificar if(obj != null), Você retorna um objeto especial, 
                        que implementa a mesma interface, seguindo um comportamento neutro, seguro e vazio.

        . MVC: padrão arquitetural que separa uma aplicação em três componentes principais: model (dados e regras de negócio),
                View (interface com o usuário), Controller (controle do fluxo e orquestração das ações). O objetivo do MVC 
                é organizar o código, separar responsabilidades e tornar o sistema mais manutenível, testável e escalável.

. Pattern Criacionais 

    . Singleton

        . Definição
            
            . Garante que uma classe tenha apenas uma única instância e fornece um ponto de acesso global para ela.

        . Conceito

            . Uma determinada classe deve ter apenas uma instância. Você pode usar essa instância sempre que precisar e, portanto, 
                evitar a criação de objetos desnecessários.

        . Ilustração

                Client(Program.cs)


                Singleton


            . O construtor é private, assim não poderá ser instanciado (new)

            . Antes de tentar criar um objeto, verificamos se existe uma cópia disponível. Se
                não existir, criamos novo objeto; caso contrário, reutilizamos a existente.

        . Exemplo

            // Singleton
            using System;
            namespace  Pattern.Creational.Singleton
            {               
                public sealed class Singleton       // sealed impedi que a classe Singleton seja herdada por outras classes
                {
                    private static readonly Singleton instance = new Singleton();
                    private int numberOfInstances = 0;

                    //Private constructor is used to prevent
                    //creation of instances with 'new' keyword outside this class
                    private Singleton()
                    {
                        Console.WriteLine("Instantiating inside the private constructor.");
                        numberOfInstances++;
                        Console.WriteLine("Number of instances ={0}", numberOfInstances);
                    }


                    // Detalhe importante, o bloco abaixo é uma propriedade e não um método. 
                    // Se terminasse com "()" seria um método e poderiamos retornar o "instance" com 
                    // "return instance"
                    public static Singleton Instance
                    {
                        get
                        {
                            Console.WriteLine("We already have an instance now.Use it.");
                            return instance;
                        }
                    }
                }
            }        


            // Program

            using Pattern.Creational.Singleton;

            class Program
            {
                static void Main()
                {
                    Console.WriteLine("***Singleton Pattern Demo***\n");
                    //Console.WriteLine(Singleton.MyInt);
                    // Private Constructor.So,we cannot use 'new' keyword.
                    Console.WriteLine("Trying to create instance s1.");
                    Singleton s1 = Singleton.Instance;
                    Console.WriteLine("Trying to create instance s2.");
                    Singleton s2 = Singleton.Instance;
                    if (s1 == s2)
                    {
                        Console.WriteLine("Only one instance exists.");
                    }
                    else
                    {
                        Console.WriteLine("Different instances exist.");
                    }
                    Console.Read();
                }
            }

    . Prototype

        . Definição

            .  Especifica os tipos de objetos para criar utilizando uma intância prototipada, criando um novo objeto 
                copiando neste prtotipo.

        . Conceito

            . Fornece um método para criar, ou clonar, uma instância de um objeto existente. 

        . Ilustração


                            BasicCar    <-------    Client( Program.cs )
                            ^      ^
                            |      |
                            |      |
                        Nano   Ford

            . BasiCar é o prototipo. 
            . Nano e Ford são as classes concretas prototipadas, que implementam o método "clone"
            . Client inicialemente cria o objeto prototipada com os objetos Nano e Ford, posteriormente
                alteramos o preço da classe prototipada.

        . Exemplo

            // BasicCar
            using System;

            namespace  Pattern.Creational.Prototype
            {
                public abstract class BasicCar
                {
                    public string? ModelName { get; set; }
                    public int Price { get; set; }
                    public static int SetPrice()
                    {
                        int price = 0;
                        Random r = new Random();
                        int p = r.Next(200000, 500000);
                        price = p;
                        return price;
                    }
                    public abstract BasicCar Clone();
                }
            }


        
            //Nano.cs
            using System;

            namespace  Pattern.Creational.Prototype
            {
                public class Nano : BasicCar
                {
                    public Nano(string m)
                    {
                        ModelName = m;
                    }
                    public override BasicCar Clone()
                    {
                        return (Nano)this.MemberwiseClone();    // MemberwiseClone() -> cria uma cópia shallow do objeto, 
                    }                                           // copiando todos os valores dos campos (fields) para 
                }                                               // um novo objeto da mesma classe.
            }        



            //Ford.cs
            using System;

            namespace  Pattern.Creational.Prototype
            {
                public class Ford : BasicCar
                {
                    public Ford(string m)
                    {
                        ModelName = m;
                    }
                    public override BasicCar Clone()
                    {
                        return (Ford)this.MemberwiseClone();
                    }
                }
            }



            // Client( Program.cs )
            using Pattern.Creational.Prototype;

            class Program
            {
                static void Main()
                {
                    Console.WriteLine("***Prototype Pattern Demo***\n");

                    //Base or Original Copy
                    BasicCar nanoBase = new Nano("Green Nano") { Price = 100000 };
                    BasicCar fordBase = new Ford("Ford Yellow") { Price = 500000 };
                    
                    BasicCar bcNano;
                    
                    //Nano
                    bcNano = nanoBase.Clone();
                    bcNano.Price = nanoBase.Price + BasicCar.SetPrice();
                    Console.WriteLine("Car is: {0}, and it's price is Rs. {1}", bcNano.ModelName, bcNano.Price);
                    
                    //Ford
                    bcNano = fordBase.Clone();
                    bcNano.Price = fordBase.Price + BasicCar.SetPrice();
                    Console.WriteLine("Car is: {0}, and it's price is Rs. {1}", bcNano.ModelName, bcNano.Price);

                    Console.ReadLine();
                }
            }

    . Builder

        . Definição

            . Separa a construção de um objeto complexo de sua representação, permitindo que o mesmo processo gere 
                diferentes representações.

        . Conceito 

            . É util para criar objetos complexos, que tem multiplas partes. O processo de criação de um objeto terá
                partes independentes. O processo de criação não se importa como as partes são montadas.
                
        . Ilustração

                                Director    <>----------  Builder

                                                            ^
                                                            |
                                                            |

                                                        ConcreteBuilder ------> Product



        . Exemplo

            // Builders common interface
            using System;
            using System.Collections.Generic;

            namespace  Pattern.Creational.Builder
            {
                internal interface IBuilder
                {
                    void StartUpOperations();
                    void BuildBody();
                    void InsertWheels();
                    void AddHeadlights();
                    void EndOperations();
                    Product GetVehicle();
                }
            }


            // ConcreteBuilder: Car
            using Pattern.Creational.Builder;

            class Car : IBuilder
            {
                private string brandName;
                private Product product;

                public Car(string brand)
                {
                    product = new Product();
                    this.brandName = brand;
                }

                public void StartUpOperations()
                { //Starting with brandname
                    product.Add(string.Format("Car Model name :{0}", this.
                    brandName));
                }

                public void BuildBody()
                {
                    product.Add("This is a body of a Car");
                }

                public void InsertWheels()
                {
                    product.Add("4 wheels are added");
                }

                public void AddHeadlights()
                {
                    product.Add("2 Headlights are added");
                }

                public void EndOperations()
                { //Nothing in this case
                }

                public Product GetVehicle()
                {
                    return product;
                }
            }


            // ConcreteBuilder:Motorcycle
            using Pattern.Creational.Builder;

            class MotorCycle : IBuilder
            {
                private string brandName;
                private Product product;
                public MotorCycle(string brand)
                {
                    product = new Product();
                    this.brandName = brand;
                }
                public void StartUpOperations()
                { //Nothing in this case
                }
                public void BuildBody()
                {
                    product.Add("This is a body of a Motorcycle");
                }
                public void InsertWheels()
                {
                    product.Add("2 wheels are added");
                }
                public void AddHeadlights()
                {
                    product.Add("1 Headlights are added");
                }
                public void EndOperations()
                {
                    //Finishing up with brandname
                    product.Add(string.Format("Motorcycle Model name :{0}",
                    this.brandName));
                }
                public Product GetVehicle()
                {
                    return product;
                }
            }



            // "Product"
            namespace  Pattern.Creational.Builder;

            class Product
            {
                // We can use any data structure that you prefer e.g.List<string> etc.
                private LinkedList<string> parts;
                public Product()
                {
                    parts = new LinkedList<string>();
                }
                public void Add(string part)
                {
                    //Adding parts
                    parts.AddLast(part);
                }
                public void Show()
                {
                    Console.WriteLine("\nProduct completed as below :");
                    foreach (string part in parts)
                        Console.WriteLine(part);
                }
            }



            // "Director"
            using Pattern.Creational.Builder;

            class Director
            {
                IBuilder builder;
                // A series of steps-in real life, steps are complex.
                public void Construct(IBuilder builder)
                {
                    this.builder = builder;
                    builder.StartUpOperations();
                    builder.BuildBody();
                    builder.InsertWheels();
                    builder.AddHeadlights();
                    builder.EndOperations();
                }
            }

    . Factory Method
    
        . Definição

            . Define uma interface para a criação de objetos, mas deixa as subclasses decidir qual classe
                será instanciada. O padrão Factory Method permite que uma classe diferencie a subclasse a 
                ser instanciada.

        . Ilustração

                                +-----------------------+               +-----------------------+       +-----------------------+
                                |     IAnimalFactory    |               |       Client          |       |       IAnimal         |
                                |   <<Abstract Class>>  |               |      <<Class>>        |       |       <<Interface>>   |
                                +-----------------------+               +-----------------------+       +-----------------------+
                                |                       |               |                       |       |                       |
                                +-----------------------+               +-----------------------+       +-----------------------+
                                | + CreateAnimal        |               | # Main                |       | + Action              |
                                +-----------------------+               +-----------------------+       | + Speak               |
                                            ^                                                           +-----------------------+
                                        /_\
                                            |
                            +---------------------------+
                            |                           |
            +-----------------------+       +-----------------------+   +-----------------------+   +-----------------------+
            |     IAnimalFactory    |       |       TiegerFactory   |   |           Dog         |   |       Tiger           |
            |   <<Abstract Class>>  |       |       <<Class>>       |   |         <<Class>>     |   |       <<Class>>       |
            +-----------------------+       +-----------------------+   +-----------------------+   +-----------------------+
            |                       |       |                       |   |                       |   |                       |
            +-----------------------+       +-----------------------+   +-----------------------+   +-----------------------+ 
            | + CreateAnimal        |       | + CreateAnimal        |   | + Action              |   | + Action              |
            +-----------------------+       +-----------------------+   | + Speak               |   | + Speak               |
                                                                        +-----------------------+   +-----------------------+

        . Exemplo

            . Primeira Versão

                // Interface para as classes de criação
                namespace  Pattern.Creational.FactoryMethod;

                public interface IAnimal
                {
                    void Speak();
                    void Action();
                }


                // Interface para as classe de fabricação

                namespace  Pattern.Creational.FactoryMethod;

                public abstract class IAnimalFactory
                {
                    //Remember the GoF definition which says "....Factory method lets a class
                    //defer instantiation to subclasses." Following method will create a Tiger
                    //or Dog But at this point it does not know whether it will get a Dog or a
                    //Tiger. It will be decided by the subclasses i.e.DogFactory or TigerFactory.
                    //So, the following method is acting like a factory (of creation).

                    public abstract IAnimal CreateAnimal();
                }            


                // Classes de criação
                namespace  Pattern.Creational.FactoryMethod;

                public class Dog : IAnimal
                {
                    public void Speak()
                    {
                        Console.WriteLine("Dog says: Bow-Wow.");
                    }
                    public void Action()
                    {
                        Console.WriteLine("Dogs prefer barking...\n");
                    }
                }


                // Classe de criação
                namespace  Pattern.Creational.FactoryMethod;

                public class Tiger: IAnimal
                {
                    public void Speak()
                    {
                        Console.WriteLine("Tiger say: Halum.");
                    }

                    public void Action()
                    {
                        Console.WriteLine("Tigers prefer hunting....\n");
                    }
                }



                // Factory da classe Dog
                namespace  Pattern.Creational.FactoryMethod;

                public class DogFactory: IAnimalFactory
                {
                    public override IAnimal CreateAnimal()
                    {
                        return new Dog();
                    }
                }


                // Factory da classe Tiger
                namespace  Pattern.Creational.FactoryMethod;

                public class TigerFactory: IAnimalFactory
                {
                    public override IAnimal CreateAnimal()
                    {
                        return new Tiger();
                    }
                }



                // Classe "client" para efetuar as chamadas
                using Pattern.Creational.FactoryMethod;


                class Program
                {
                    static void Main()
                    {
                        Console.WriteLine("*** Factory Pattern Demo***\n");

                        IAnimalFactory tigerFactory = new TigerFactory();
                        IAnimalFactory dogFactory = new DogFactory();

                        IAnimal tiger = tigerFactory.CreateAnimal();

                        IAnimal dog = dogFactory.CreateAnimal();

                        tiger.Speak();
                        tiger.Action();

                        dog.Speak();
                        dog.Action();

                        Console.ReadKey();
                    }
                }

            . Melhorias

                // Inserção do método MakeAnimal, assim todas as Factory implementarão automaticamente esse método.
                // Quando for chamado o método MakeAnimal das classes [Dog/Tiger]Factory, a chamada será da classe
                // abstrata pai "IAnimalFactory" e consequentemente retornará a classe de criação Dog/Tiger
                namespace  Pattern.Creational.FactoryMethod;

                public abstract class IAnimalFactory
                {
                    public abstract IAnimal CreateAnimal();

                    // Método inserido
                    public IAnimal MakeAnimal()
                    {
                        IAnimal animal = CreateAnimal();

                        animal.Speak();
                        animal.Action();

                        return animal;
                    }
                }




                using Pattern.Creational.FactoryMethod;


                class Program
                {
                    static void Main()
                    {
                        Console.WriteLine("*** Factory Pattern Demo***\n");

                        IAnimalFactory tigerFactory = new TigerFactory();
                        IAnimalFactory dogFactory = new DogFactory();

                        /*  Trecho substituido
                        IAnimal tiger = tigerFactory.CreateAnimal();
                        IAnimal dog = dogFactory.CreateAnimal();
                        */

                        // Linha inserida
                        IAnimal tiger = tigerFactory.MakeAnimal();

                        // Linha inserida
                        IAnimal dog = dogFactory.MakeAnimal();
                        
                        tiger.Speak();
                        tiger.Action();

                        dog.Speak();
                        dog.Action();

                        Console.ReadKey();
                    }
                }

    . Abstract Factory

        . Definição

            . É um padrão que fornece uma interface para criar grupos de objetos relacionados entre si, garantindo 
                que o código cliente use apenas interfaces/abstrações, nunca classes concretas.

            . Suponha que queiramos categorizar cachorros e tigres, e escolhemos obter um animal pet (cachorro ou tigre);
                ou um animal selvagem (cachorro ou tigre) através de uma fabrica. Introduziremos duas fabricas concretas:
                WildAnimalFactory (responsável pela criação de animias selvagens) e PetAnimalFactory (responsável pela 
                criação dos animais pet).


        .Exemplo

            // Interface IDog
            namespace  Pattern.Creational.AbstractFactory;

            public interface IDog
            {
                void Speak();
                void Action();
            }


            // Interface ITiger
            namespace  Pattern.Creational.AbstractFactory;

            public interface ITiger
            {
                void Speak();
                void Action();
            }


            // Classe PetDog
            namespace  Pattern.Creational.AbstractFactory;

            class PetDog : IDog
            {
                public void Speak()
                {
                    Console.WriteLine("Pet Dog says: Bow-Wow.");
                }
                public void Action()
                {
                    Console.WriteLine("Pet Dogs prefer to stay at home.\n");
                }
            }


            // Classe PetTiger
            namespace  Pattern.Creational.AbstractFactory;

            class PetTiger : ITiger
            {
                public void Speak()
                {
                    Console.WriteLine("Pet Tiger says: Halum.");
                }
                public void Action()
                {
                    Console.WriteLine("Pet Tigers play in an animal circus.\n");
                }
            }


            // Classe WildDog
            namespace  Pattern.Creational.AbstractFactory;

            class WildDog : IDog
            {
                public void Speak()
                {
                    Console.WriteLine("Wild Dog says: Bow-Wow.");
                }
                public void Action()
                {
                    Console.WriteLine(@"Wild Dogs prefer to roam freely in
                    jungles.\n");
                }
            }


            // Classe WildTiger
            namespace  Pattern.Creational.AbstractFactory;

            class WildTiger : ITiger
            {
                public void Speak()
                {
                    Console.WriteLine("Wild Tiger says: Halum.");
                }
                public void Action()
                {
                    Console.WriteLine("Wild Tigers prefer hunting in jungles.\n");
                }
            }


            // Interface IAnimalFactory
            namespace  Pattern.Creational.AbstractFactory;

            public interface IAnimalFactory
            {
                IDog GetDog();
                ITiger GetTiger();
            }



            // Classe Factory PetAnimalFactory
            namespace  Pattern.Creational.AbstractFactory;

            public class PetAnimalFactory : IAnimalFactory
            {
                public IDog GetDog()
                {
                    return new PetDog();
                }
                public ITiger GetTiger()
                {
                    return new PetTiger();
                }
            }


            // Classe Factory WildAnimalFactory
            namespace  Pattern.Creational.AbstractFactory;

            public class WildAnimalFactory : IAnimalFactory
            {
                public IDog GetDog()
                {
                    return new WildDog();
                }
                public ITiger GetTiger()
                {
                    return new WildTiger();
                }
            }





            // Classe Client "Program.cs"
            using Pattern.Creational.AbstractFactory;


            class Program
            {
                static void Main()
                {
                    Console.WriteLine("***Abstract Factory Pattern Demo***\n");
                    //Making a wild dog through WildAnimalFactory
                    IAnimalFactory wildAnimalFactory = new WildAnimalFactory();

                    IDog wildDog = wildAnimalFactory.GetDog();

                    wildDog.Speak();
                    wildDog.Action();

                    //Making a wild tiger through WildAnimalFactory
                    ITiger wildTiger = wildAnimalFactory.GetTiger();

                    wildTiger.Speak();
                    wildTiger.Action();

                    Console.WriteLine("******************");
                    
                    //Making a pet dog through PetAnimalFactory
                    IAnimalFactory petAnimalFactory = new PetAnimalFactory();

                    IDog petDog = petAnimalFactory.GetDog();

                    petDog.Speak();
                    petDog.Action();

                    //Making a pet tiger through PetAnimalFactory
                    ITiger petTiger = petAnimalFactory.GetTiger();

                    petTiger.Speak();
                    petTiger.Action();


                    Console.ReadKey();
                }
            }

. Pattern Estruturais

    . Proxy

        . Definição

            . É um padrão estrutural que fornece um objeto substituto para controlar o acesso a outro objeto, podendo 
                adicionar comportamentos extras antes ou depois da operação real.

        . Conceito

            . Um proxy é como um substituto para um objeto real. Quando o cliente usa o proxy, ele acha que está 
                falando diretamente com o objeto verdadeiro — mas, na verdade, está falando com o substituto.

            . Isso é útil porque nem sempre é possível acessar o objeto real diretamente.

            . Pode ser por causa de:

                . segurança,

                . desempenho,

                . o objeto real ser pesado para carregar,

                . ou porque ele está em outro computador.

            . Então o padrão Proxy ajuda criando uma classe intermediária, que age como se fosse o objeto 
                verdadeiro e serve de ponte para ele.

            . Resumindo: Proxy é um objeto que fica no lugar do real e controla o acesso a ele.

        . Ilustração

                            +-------------------+                       +-------------------+
                            | Subject           |                       | Program           |
                            | <<Absract Class>> |                       | <<Class>>         |
                            +-------------------+                       +-------------------+
                            |                   |                       |                   |
                            +-------------------+                       +-------------------+
                            | + DoSomeWork      |                       | + Main            |
                            +-------------------+                       +-------------------+
                                    ^
                                   / \
                                    |
                    +-------------------------------+
                    |                               |
            +-------------------+       +-------------------+
            | Proxy             |       | ConcreteSubject   |
            | <<Class>>         |       | <<Class>>         |
            +-------------------+       +-------------------+
            | # subject         |       |                   |
            +-------------------+       +-------------------+
            | + DoSomeWork      |       | + DoSomeWork      |
            +-------------------+       +-------------------+

        . Exemplo

            // Abstract Classe Subject
            namespace Pattern.Structural.Proxy;

            public abstract class Subject
            {
                public abstract void DoSomeWork();
            }


            // Classe ConcreteSubject
            namespace Pattern.Structural.Proxy;

            public class ConcreteSubject : Subject
            {
                public override void DoSomeWork()
                {
                    Console.WriteLine("ConcreteSubject.DoSomeWork()");
                }
            }


            // Classe Proxy
            namespace Pattern.Structural.Proxy;

            public class Proxy : Subject
            {
                Subject subject;
                public override void DoSomeWork()
                {
                    Console.WriteLine("Proxy call happening now...");
                    //Lazy initialization:We'll not instantiate until the method is
                    //called
                    if (subject == null)
                    {
                        subject = new ConcreteSubject();
                    }
                    subject.DoSomeWork();
                }
            }


            // Classe "Client" "Program.cs"
            using Pattern.Structural.Proxy;

            class Program
            {
                static void Main()
                {
                    Console.WriteLine("***Proxy Pattern Demo***\n");

                    Proxy px = new Proxy();
                    px.DoSomeWork();

                    Console.ReadKey();
                }
            }

    . Decorator

        . Definição

            . Permite adicionar responsabilidades (comportamentos) a um objeto dinamicamente, 
                colocando-o dentro de outro objeto que envolva o original. Decorators 
                oferecem uma alternativa flexível à herança para estender funcionalidades.
    
        . Conceito

            . Este padrão promove o conceito de que sua classe deve ser fechada para modificação,
                mas aberta para extensão. Em outras palavras, você pode adicionar uma funcionalidade 
                sem atrapalhar as funcionalidades existentes. O conceito é útil quando você deseja 
                adicionar alguma funcionalidade especial a um objeto específico em vez de toda 
                a classe. Este padrão prefere a composição de objetos à herança. Depois de 
                dominar essa técnica, você pode adicionar novas
                responsabilidades a um objeto sem afetar as classes subjacentes.

        . Ilustração



                            +---------------------+
                            |     Component       |
                            | <<Abstract Class>>  |
                            |---------------------|
                            | + MakeHouse()       |
                            +----------+----------+
                                    ^
                                    |
                        +-----------+-----------+
                        |                       |
            +--------------------------+   +------------------------------------------------------------+
            |     ConcreteComponent    |   |    AbstractDecorator                                       |
            |                          |   |    <<Abstract Class>>                                      |
            |--------------------------|   |------------------------------------------------------------|
            | + MakeHouse()            |   | - _component: Component                                    |
            +--------------------------+   |------------------------------------------------------------+
                                           | + AbstractDecorator(Component component) <<constructor>>   |
                                           | + SetTheComponent()                                        |
                                           | + MakeHouse()                                              |
                                           +-----------+------------------------------------------------+
                                                                        ^
                                                                        |
                                                    +-------------------+------------------+
                                                    |                                      |
                                        +---------------------------+        +---------------------------+
                                        |    ConcreteDecoratorA     |        |    ConcreteDecoratorB     |
                                        |---------------------------|        |---------------------------|
                                        | + MakeHouse()             |        | + MakeHouse()             |
                                        | + AddFloor()              |        | + PaintTheHouse()         |
                                        +---------------------------+        +---------------------------+

        . Exemplo


            namespace Pattern.Structural.Decorator;
            public abstract class Component
            {
                public abstract void MakeHouse();
            }




            namespace Pattern.Structural.Decorator;

            public abstract class AbstractDecorator: Component
            {
                
                protected Component _component;

                public void SetTheComponent(Component component)
                {
                    this._component = component;
                }

                public override void MakeHouse()
                {
                    if ( _component != null)
                    {
                        _component.MakeHouse();
                    }
                }

                protected AbstractDecorator( Component component)
                {
                    this._component = component;
                }

            }




            namespace Pattern.Structural.Decorator;

            public class ConcreteComponent : Component
            {

                public override void MakeHouse()
                {
                    Console.WriteLine("WriteLine(\"A casa original está completa. Ela está fechada para modificações!!!\"");
                }
            }





            namespace Pattern.Structural.Decorator;

            public class ConcreteDecoratorA: AbstractDecorator
            {
                public override void MakeHouse()
                {
                    base.MakeHouse();
                    AddFloor();
                    Console.WriteLine("A casa foi decorada com o estilo A.");
                }
                void AddFloor()
                {
                    Console.WriteLine("Adicionando mais um andar do ConcreteDecoratorA.");
                }

                public ConcreteDecoratorA(Component component): base(component)
                {

                }
            }


            using System.ComponentModel;

            namespace Pattern.Structural.Decorator;

            public class ConcreteDecoratorB: AbstractDecorator
            {
                public override void MakeHouse()
                {
                    Console.WriteLine("");

                    base.MakeHouse();
                    Console.WriteLine("Usando outro Decorator");

                    AddGarage();

                    Console.WriteLine("A casa foi decorada com o estilo B.");
                }

                void AddGarage()
                {
                    Console.WriteLine("Garagem foi adicionada pelo ConcreteDecorateB.");
                }

                public ConcreteDecoratorB( Component component) : base(component)
                {
                    
                }
            }



            using Pattern.Structural.Decorator;

            class Program
            {
                static void Main()
                {
                    Console.WriteLine("***Decorator Pattern Demo***\n");

                    ConcreteComponent cc = new ConcreteComponent();

                    ConcreteDecoratorA decoratorA = new ConcreteDecoratorA(cc);
                    // decoratorA.SetTheComponent(cc);

                    decoratorA.MakeHouse();

                    ConcreteDecoratorB decoratorB = new ConcreteDecoratorB(decoratorA);
                    // decoratorB.SetTheComponent(decoratorA);
                    decoratorB.MakeHouse();


                    Console.ReadKey();
                }
            }

    . Adapter

        . Definição

            . Permite que interfaces incompatíveis trabalhem juntas, convertendo a interface de uma 
                classe em outra interface esperada pelos clientes


        . Ilustração

            +------------------------+
            |      ITwoPinPlug       |  <<Target>>
            |------------------------|
            | + Connect2Pins()       |
            +-----------+------------+
                        ^
                        |
            +-----------+------------+
            |     TwoPinOutlet       |  (Cliente usa isso)
            |------------------------|
            | + SupplyPower(ITwoPinPlug) |
            +------------------------+

            +------------------------+
            |     ThreePinDevice     |  <<Adaptee>>
            |------------------------|
            | + Connect3Pins()       |
            +------------------------+

            +------------------------+
            |     PlugAdapter        |  <<Adapter>>
            |------------------------|
            | - device: ThreePinDevice |
            |------------------------|
            | + PlugAdapter(device)  |
            | + Connect2Pins()       |
            |     (chama device.Connect3Pins()) |
            +------------------------+

            +------------------------+
            |        Program         |
            +------------------------+
            | + Main()               |
            +------------------------+

        . Exemplo:

            using System;

            namespace AdapterExample2
            {
                // Target - Interface que o sistema espera
                public interface ITwoPinPlug
                {
                    void Connect2Pins();
                }

                // Adaptee - Classe incompatível
                public class ThreePinDevice
                {
                    public void Connect3Pins()
                    {
                        Console.WriteLine("Three-pin device connected using 3 pins.");
                    }
                }

                // Adapter - converte a interface
                public class PlugAdapter : ITwoPinPlug
                {
                    private readonly ThreePinDevice device;

                    public PlugAdapter(ThreePinDevice device)
                    {
                        this.device = device;
                    }

                    public void Connect2Pins()
                    {
                        Console.WriteLine("Adapter converting 2-pin request to 3-pin...");
                        device.Connect3Pins();
                    }
                }

                // Cliente
                public class TwoPinOutlet
                {
                    public void SupplyPower(ITwoPinPlug plug)
                    {
                        Console.WriteLine("Outlet supplying power...");
                        plug.Connect2Pins();
                    }
                }

                class Program
                {
                    static void Main()
                    {
                        var outlet = new TwoPinOutlet();

                        // Aparelho incompatível
                        var modernDevice = new ThreePinDevice();

                        // Adaptando o aparelho para 2 pinos
                        ITwoPinPlug adapter = new PlugAdapter(modernDevice);

                        // Cliente funciona normalmente
                        outlet.SupplyPower(adapter);

                        Console.ReadKey();
                    }
                }
            }

    . Facade

        . Definição

            . Fornece uma interface unificada para um conjunto de interfaces em um subsistema. O 
                pattern "Facade" define uma interface de nível superior que facilita o uso do 
                subsistema.        

        . Conceito

            . Este padrão suporta baixo acoplamento. Com este padrão, você pode enfatizar a
                abstração e ocultar os detalhes complexos expondo uma interface simples.

        . Ilustração

            . Neste exemplo, seus clientes podem construir ou destruir um tipo específico de robô
                invocando métodos simples como "ConstructMilanoRobot" e "DestroyMilanoRobot".
                Do ponto de vista do cliente, ele precisa interagir apenas com um "Facade"
                (consulte o arquivo Program.cs). A classe RobotFacade assume total responsabilidade 
                pela criação ou destruição de um tipo específico de robô. Esse "Facade" se comunica 
                com cada um desses subsistemas (RobotHands, RobotBody, RobotColor) para atender 
                à solicitação do cliente. Os clientes não precisam se preocupar com
                o processo de criação ou destruição ou com a sequência de chamadas desses métodos.


                +------------------------+
                |        Program         |
                +------------------------+
                | + Main()               |
                +------------------------+
                            |
                            | usa
                            v
                +------------------------+
                |      RobotFacade       |
                +------------------------+
                | - rb : RobotBody       |
                | - rh : RobotHands      |----------------------------------------------------------+
                | - rc : RobotColor      |                                                          |
                +------------------------+                                                          |
                | + RobotFacade()        |                                                          |
                | + ConstructMilano()    |----------------------+                                   |
                | + ConstructRobonaut()  |                      |                                   |
                | + DestroyMilano()      |                      |                                   |
                | + DestroyRobonaut()    |                      |                                   |
                +------------------------+                      |                                   |
                    |                                           |                                   |
                    |                                           |                                   |
                    v                                           v                                   v
                +------------------------+        +------------------------+            +------------------------+
                |       RobotBody        |        |      RobotHands        |            |      RobotColor        |
                +------------------------+        +------------------------+            |                        |
                | + CreateHands()        |        | + ResetMilanoHands()   |            +------------------------+
                | + CreateRemaining()    |        | + ResetRobonautHands() |            | + SetDefaultColor()    |
                | + DestroyHands()       |        | + SetMilanoHands()     |            | + SetGreenColor()      |
                | + DestroyRemaining()   |        | + SetRobonautHands()   |            +------------------------+ 
                +------------------------+        +------------------------+
                           

            . Exemplo:

                // RobotBody.cs

                namespace Pattern.Structural.Facade;

                public class RobotBody
                {
                    public void CreateHands()
                    {
                        Console.WriteLine("Hands manufactured");
                    }
                    public void CreateRemainingParts()
                    {
                        Console.WriteLine("Remaining parts (other than hands) are created");
                    }
                    public void DestroyHands()
                    {
                        Console.WriteLine("The robot's hands are destroyed");
                    }
                    public void DestroyRemainingParts()
                    {
                        Console.WriteLine("The robot's remaining parts are destroyed");
                    }
                }



                //RobotColor.cs
                namespace Pattern.Structural.Facade;

                public class RobotColor
                {
                    public void SetDefaultColor()
                    {
                        Console.WriteLine("This is steel color robot.");
                    }
                    public void SetGreenColor()
                    {
                        Console.WriteLine("This is a green color robot.");
                    }
                }


                // RobotHands.cs
                namespace Pattern.Structural.Facade;

                public class RobotHands
                {
                    public void SetMilanoHands()
                    {
                        Console.WriteLine("The robot will have EH1 Milano hands");
                    }
                    public void SetRobonautHands()
                    {
                        Console.WriteLine("The robot will have Robonaut hands");
                    }
                    public void ResetMilanoHands()
                    {
                        Console.WriteLine("EH1 Milano hands are about to be destroyed");
                    }
                    public void ResetRobonautHands()
                    {
                        Console.WriteLine("Robonaut hands are about to be destroyed");
                    }
                }




                // RobotFacade.cs

                namespace Pattern.Structural.Facade;

                public class RobotFacade
                {
                    RobotColor rc;
                    RobotHands rh;
                    RobotBody rb;
                    public RobotFacade()
                    {
                        rc = new RobotColor();
                        rh = new RobotHands();
                        rb = new RobotBody();
                    }
                    public void ConstructMilanoRobot()
                    {
                        Console.WriteLine("Creation of a Milano Robot Start");
                        rc.SetDefaultColor();
                        rh.SetMilanoHands();
                        rb.CreateHands();
                        rb.CreateRemainingParts();
                        Console.WriteLine("Milano Robot Creation End");
                        Console.WriteLine();
                    }
                    public void ConstructRobonautRobot()
                    {
                        Console.WriteLine("Initiating the creational process of a Robonaut Robot");
                        rc.SetGreenColor();
                        rh.SetRobonautHands(); 
                        rb.CreateHands();
                        rb.CreateRemainingParts();
                        Console.WriteLine("A Robonaut Robot is created");
                        Console.WriteLine();
                    }
                    public void DestroyMilanoRobot()
                    {
                        Console.WriteLine("Milano Robot's destruction process is started");
                        rh.ResetMilanoHands();
                        rb.DestroyHands();
                        rb.DestroyRemainingParts();
                        Console.WriteLine("Milano Robot's destruction process is over");
                        Console.WriteLine();
                    }
                    public void DestroyRobonautRobot()
                    {
                        Console.WriteLine("Initiating a Robonaut Robot's destruction process.");
                        rh.ResetRobonautHands();
                        rb.DestroyHands();
                        rb.DestroyRemainingParts();
                        Console.WriteLine("A Robonaut Robot is destroyed");
                        Console.WriteLine();
                    }
                }



                // Program.cs
                using Pattern.Structural.Facade;

                Console.WriteLine("***Facade Pattern Demo***\n");
                //Creating Robots
                RobotFacade rf1 = new RobotFacade();
                rf1.ConstructMilanoRobot();
                RobotFacade rf2 = new RobotFacade();
                rf2.ConstructRobonautRobot();
                //Destroying robots
                rf1.DestroyMilanoRobot();
                rf2.DestroyRobonautRobot();
                Console.ReadLine();

    . Flyweight

        . Definição

            . Flyweight é um padrão estrutural que reduz o uso de memória compartilhando objetos de forma eficiente 
                quando muitos objetos similares precisam ser criados. Ele permite que grandes quantidades de objetos
                sejam representados por poucos objetos compartilhados.        

        . Ilustração

            +-------------------------------------------------------+
            |        RobotFactory                                   |
            +-------------------------------------------------------+
            | - shapes : (collection)                               |  // ex.: Dictionary<string, IRobot>
            +-------------------------------------------------------+
            | + TotalObjectsCreated : int {get;}                    |
            +-------------------------------------------------------+
            | + GetRobotFromFactory( robotType : string ) : IRobot  |
            +-------------------------------------------------------+


            +----------------------------+
            |          IRobot            | <<interface>>
            +----------------------------+
            | + Print(color : string)    |
            +----------------------------+


            +----------------------------+
            |          LargeRobot        |
            +----------------------------+
            | + Print(color : string)    |  // implementação de IRobot
            +----------------------------+
                    ^
                    |
                    implements IRobot


            +----------------------------+
            |          SmallRobot        |
            +----------------------------+
            | + Print(color : string)    |  // implementação de IRobot
            +----------------------------+
                    ^
                    |
                    implements IRobot


            +----------------------------+
            |           Program          |
            +----------------------------+
            | + Main() : void            |
            +----------------------------+


        . Exemplo:


            namespace Pattern.Structural.Flyweight;

            /// <summary>
            /// The 'Flyweight' interface
            /// </summary>
            public interface IRobot
            {
                void Print();
            }



            namespace Pattern.Structural.Flyweight;
            /// <summary>
            /// A 'ConcreteFlyweight' class
            /// </summary>
            class LargeRobot : IRobot
            {
                public void Print()
                {
                    Console.WriteLine("I am a large Robot");
                }
            }



            namespace Pattern.Structural.Flyweight;

            /// <summary>
            /// A 'ConcreteFlyweight' class
            /// </summary>
            class SmallRobot : IRobot
            {
                public void Print()
                {
                    Console.WriteLine("This is a small Robot");
                }
            }



            // RobotFactory.cs
            namespace Pattern.Structural.Flyweight;

            public class RobotFactory
            {
                Dictionary<string, IRobot> shapes = new Dictionary<string, IRobot>();

                public int TotalObjectsCreated
                {
                    get {  return shapes.Count; }
                }

                public IRobot GetRobotFromFactory(string robotType)
                {
                    IRobot robotCategory = null;

                    if (shapes.ContainsKey(robotType))
                    {
                        robotCategory = shapes[robotType];
                    }
                    else
                    {
                        switch (robotType)
                        {
                            case "Small":

                                robotCategory = new SmallRobot();

                                shapes.Add(robotType, robotCategory);

                                break;
                            case "Large":
                                robotCategory = new LargeRobot();
                                shapes.Add(robotType, robotCategory);
                                break;
                            default:
                                throw new Exception("Robot Factory can created only small and large robots");
                        }

                    }

                    return robotCategory;
                }
            }



            using Pattern.Structural.Flyweight;


            public class Program
            {
                static void Main(string[] args)
                {
                    Console.WriteLine("***Flyweight Pattern Demo***\n");

                    RobotFactory myfactory = new RobotFactory();

                    IRobot shape = myfactory.GetRobotFromFactory("Small");

                    shape.Print();

                    for (int i = 0; i < 2; i++)
                    {
                        shape = myfactory.GetRobotFromFactory("Small");
                        shape.Print();
                    }

                    int NumOfDistinctRobots = myfactory.TotalObjectsCreated;

                    Console.WriteLine("\n Now, total numbers of distinct robot objects is = {0}\n", NumOfDistinctRobots);

                    /*Here we are trying to get the 5 more Large robots.
                    Note that: now onwards we need not create additional small
                    robots because we have already created one of this category */
                    for (int i = 0; i < 5; i++)
                    {
                        shape = myfactory.GetRobotFromFactory("Large");
                        shape.Print();
                    }

                    NumOfDistinctRobots = myfactory.TotalObjectsCreated;

                    Console.WriteLine("\n Distinct Robot objects created till now = {0}", NumOfDistinctRobots);

                    Console.ReadKey();
                }
            }

    . Composite

        . Definição

            . Composite é um padrão estrutural que permite compor objetos em estruturas de árvore, 
                para que objetos individuais (folhas) e composições de objetos (nós) sejam tratados 
                de forma uniforme.    

        . Ilustração

                                                +------------------------+
                                                |        Program         |
                                                +------------------------+
                                                | + Main() : void        |
                                                +------------------------+

                                                +------------------------+
                                                |      IEmployee         | 
                                                |    <<interface>>       |
                                                +------------------------+
                                                | + PrintStructures()    |
                                                +------------------------+
                                                            ^
                                                            |
                                                            |
                                    +-------------------------------------------------------+
                                    |                                                       |
                                    |                                                       |
                +---------------------------------------+                   +--------------------------------+
                |          CompositeEmployee            |                   |           Employee             |
                +---------------------------------------+                   +--------------------------------+
                | - controls : List<IEmployee>          |                   | - dept : string                |
                | - dept     : string                   |                   | - name : string                |
                | - name     : string                   |                   +--------------------------------+
                +---------------------------------------+                   | + Employee(name, dept)         |
                | + CompositeEmployee(name, dept)       |                   | + PrintStructures() : void     |
                | + Add(emp: IEmployee) : void          |                   +--------------------------------+
                | + Remove(emp: IEmployee) : void       |
                | + PrintStructures() : void            |
                +---------------------------------------+


    . Exemplo



        namespace Pattern.Structural.Composite;

        public interface IEmployee
        {
            void PrintStructure();
        }



        namespace Pattern.Structural.Composite;

        public class CompositeEmployee: IEmployee
        {
            public string? name { get; set; }
            public string? dept { get; set; }

            private List<IEmployee> controls = new();

            public CompositeEmployee()
            {
                
            }
            public CompositeEmployee( string name, string dept)
            {
                this.name = name;
                this.dept = dept;
                //controls = new List<IEmployee>();
            }

            public void Add( IEmployee e)
            {
                controls.Add(e);
            }

            public void Remove( IEmployee e)
            {
                controls.Remove(e);
            }

            public void PrintStructure()
            {
                Console.WriteLine($"\t {this.name} works in {this.dept}");

                foreach (IEmployee emp in controls)
                {
                    emp.PrintStructure();
                }
            }
        }






        namespace Pattern.Structural.Composite;

        public class Employee : IEmployee
        {
            public string? name { get; set; }
            public string? dept { get; set; }

            public Employee()
            {
                
            }
            public Employee(string name, string dept)
            {
                this.name = name;
                this.dept = dept;
            }

            public void PrintStructure()
            {
                Console.WriteLine($"\t {this.name} works in {this.dept}");
            }
        }





        using Pattern.Structural.Composite;
        using Pattern.Structural.Flyweight;


        public class Program
        {
            static void Main(string[] args)
            {

                Console.WriteLine("**** Composite Pattern Demo ****");

                CompositeEmployee principal = new CompositeEmployee() { name = "Dr.S.Som (Principal)", dept = "Planning-Supervising-Managing" };

                CompositeEmployee hodMat = new CompositeEmployee() { name = "Ms. A. Mathur (HOD)", dept = "Mathematics Department" };

                CompositeEmployee hodCompSc = new CompositeEmployee() { name = "Ms. B. Sharma (HOD-CSE)", dept = "Computer Science Department" };

                Employee mathTeacher1 = new Employee(){ name = "Mr. C. Gupta (Teacher 1)", dept = "Mathematics" };
                Employee mathTeacher2 = new Employee(){ name = "Ms. D. Iyer (Teacher 2)", dept = "Mathematics" };


                Employee cseTeacher1 = new Employee(){ name = "Mr. E. Khan (Teacher 1)", dept = "Computer Science" };
                Employee cseTeacher2 = new Employee(){ name = "Ms. F. Singh (Teacher 2)", dept = "Computer Science" };
                Employee cseTeacher3 = new Employee(){ name = "Mr. G. Verma (Teacher 3)", dept = "Computer Science" };

                hodMat.Add( mathTeacher1);
                hodMat.Add( mathTeacher2);

                hodCompSc.Add( cseTeacher1);
                hodCompSc.Add( cseTeacher2);
                hodCompSc.Add( cseTeacher3);

                principal.Add( hodMat);
                principal.Add( hodCompSc);

                Console.WriteLine("\nTestando a estrutura principal do objeto");

                principal.PrintStructure();

                Console.WriteLine("\n Testing the structure of a HOD object:");
                Console.WriteLine("Teachers working at Computer Science department: ");

                hodCompSc.PrintStructure();

                Console.WriteLine("\n Testing the structure of a leaf node:");
                mathTeacher1.PrintStructure();
                //Suppose, one computer teacher is leaving now from the organization.
                hodCompSc.Remove(cseTeacher2);
                Console.WriteLine("\n After CSE Teacher-2 resigned, the organization has following members: ");
                principal.PrintStructure();

                Console.ReadKey();
            }
        }
