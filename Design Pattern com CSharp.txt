Design Pattern com CSharp
-------------------------

. Gang of Four (GoF) 

    . Conjunto de 23 soluções clássicas para problemas de projeto recorrentes no desenvolvimento de 
        software orientado a objetos, documentadas no livro de 1994 "Design Patterns: Elements of 
        Reusable Object-Oriented Software". O termo "Gang of Four" refere-se aos quatro autores 
        do livro: Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides. Esses padrões são 
        categorizados em três tipos (Criacional, Estrutural e Comportamental) e promovem a 
        criação de código mais flexível, reutilizável e sustentáve

    . Os três tipos de padrões GoF

        . Criacionais: Focam em como criar objetos de forma flexível e controlada.
        
            . Singleton: Garante que uma classe tenha apenas uma única instância e fornece um 
                            ponto de acesso global para ela.
            . Prototype: Especifica os tipos de objetos para criar utilizando uma intância prototipada, 
                            criando um novo objeto copiando neste prtotipo.
            . Builder: Separa a construção de um objeto complexo de sua representação, permitindo 
                        que o mesmo processo gere diferentes representações.
            . Factory Method: Cria uma instância de várias classes derivadas, mas permite que 
                                subclasses decidam qual classe instanciar.
            . Abstract Factory: Permite criar famílias de objetos relacionados sem especificar 
                                suas classes concretas.
            . Prototype: Cria novas instâncias através da cópia de objetos existentes.

        . Estruturais: Lidaram com a maneira de compor classes e objetos para formar estruturas maiores.
        
            . Proxy: Forneça um substituto ou marcador para outro objeto, a fim de controlar o acesso a ele.
            . Decorator: Atribua responsabilidades adicionais a um objeto dinamicamente. Os decoradores 
                            fornecem uma alternativa flexível à criação de subclasses para estender a 
                            funcionalidade.
            . Adapter: Permite que objetos com interfaces incompatíveis trabalhem juntos.
            . Facade: Fornece uma interface unificada para um conjunto de interfaces em um subsistema. Facade 
                        define uma interface de nível superior que facilita o uso do subsistema.
            . Flyweight: Uso de compartilhamento para dar suporte a um grande número de objetos de 
                            granularidade fina de forma eficiente.
            . Composite: Composição de objetos em estruturas de árvore para representar hierarquias parte-todo. 
                            O recurso Composite permite que os clientes tratem objetos individuais e 
                            composições de objetos de forma uniforme.
            . Bridge: Desacopla uma abstração de sua implementação para que ambas possam variar independentemente.

        . Comportamentais: Descrevem como objetos interagem e distribuem responsabilidades entre si 
                            de forma flexível e eficiente.

            . Visitor: Representa uma operação a ser realizada nos elementos de uma estrutura de objeto. 
                        O Visitor permite definir uma nova operação sem alterar as classes dos elementos 
                        sobre os quais ela opera.
            . Observer: Define uma dependência de um para muitos entre objetos, de forma que, quando um objeto 
                        mudar de estado, todos os seus dependentes sejam notificados e atualizados automaticamente.
            . Strategy: Define uma família de algoritmos, encapsula cada um e os torna intercambiáveis, 
                        permitindo que o algoritmo varie independentemente do cliente que o usa.
            . Template: Defina o esqueleto de um algoritmo em uma operação, delegando algumas etapas para subclasses.
                        O padrão Template Method permite que subclasses redefinam certas etapas de um algoritmo
                        sem alterar a estrutura do algoritmo.
            . Command: Encapsula uma solicitação como um objeto, permitindo assim parametrizar clientes com
                        solicitações diferentes, enfileirar ou registrar solicitações e oferecer suporte a 
                        operações reversíveis.
            . Iterator:
            . Memento:
            . State:
            . Mediator:
            . Chain of Responsibility: Permite que uma solicitação percorra uma cadeia de manipuladores, 
                                        onde cada manipulador decide se processa a solicitação ou a 
                                        encaminha para o próximo. 
            . Interpreter:
    
    . Design Patterns adicionais:

        . Simple Factor:
        . Null Object:
        . MVC:
        . 
