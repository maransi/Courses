Design Pattern com CSharp
-------------------------

. Gang of Four (GoF) 

    . Conjunto de 23 soluções clássicas para problemas de projeto recorrentes no desenvolvimento de 
        software orientado a objetos, documentadas no livro de 1994 "Design Patterns: Elements of 
        Reusable Object-Oriented Software". O termo "Gang of Four" refere-se aos quatro autores 
        do livro: Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides. Esses padrões são 
        categorizados em três tipos (Criacional, Estrutural e Comportamental) e promovem a 
        criação de código mais flexível, reutilizável e sustentáve

    . Os três tipos de padrões GoF

        . Criacionais: Focam em como criar objetos de forma flexível e controlada.
        
            . Singleton: Garante que uma classe tenha apenas uma única instância e fornece um 
                            ponto de acesso global para ela.
            . Prototype: Especifica os tipos de objetos para criar utilizando uma intância prototipada, 
                            criando um novo objeto copiando neste prtotipo.
            . Builder: Separa a construção de um objeto complexo de sua representação, permitindo 
                        que o mesmo processo gere diferentes representações.
            . Factory Method: Cria uma instância de várias classes derivadas, mas permite que 
                                subclasses decidam qual classe instanciar.
            . Abstract Factory: Permite criar famílias de objetos relacionados sem especificar 
                                suas classes concretas.
            . Prototype: Cria novas instâncias através da cópia de objetos existentes.

        . Estruturais: Lidaram com a maneira de compor classes e objetos para formar estruturas maiores.
        
            . Proxy: Forneça um substituto ou marcador para outro objeto, a fim de controlar o acesso a ele.
            . Decorator: Atribui responsabilidades adicionais a um objeto dinamicamente. Os decoradores 
                            fornecem uma alternativa flexível à criação de subclasses para estender a 
                            funcionalidade.
            . Adapter: Permite que objetos com interfaces incompatíveis trabalhem juntos.
            . Facade: Fornece uma interface unificada para um conjunto de interfaces em um subsistema. Facade 
                        define uma interface de nível superior que facilita o uso do subsistema.
            . Flyweight: Uso de compartilhamento para dar suporte a um grande número de objetos de 
                            granularidade fina de forma eficiente.
            . Composite: Composição de objetos em estruturas de árvore para representar hierarquias parte-todo. 
                            O recurso Composite permite que os clientes tratem objetos individuais e 
                            composições de objetos de forma uniforme.
            . Bridge: Desacopla uma abstração de sua implementação para que ambas possam variar independentemente.

        . Comportamentais: Descrevem como objetos interagem e distribuem responsabilidades entre si 
                            de forma flexível e eficiente.

            . Visitor: Representa uma operação a ser realizada nos elementos de uma estrutura de objeto. 
                        O Visitor permite definir uma nova operação sem alterar as classes dos elementos 
                        sobre os quais ela opera.
            . Observer: Define uma dependência de um para muitos entre objetos, de forma que, quando um objeto 
                        mudar de estado, todos os seus dependentes sejam notificados e atualizados automaticamente.
            . Strategy: Define uma família de algoritmos, encapsula cada um e os torna intercambiáveis, 
                        permitindo que o algoritmo varie independentemente do cliente que o usa.
            . Template: Defina o esqueleto de um algoritmo em uma operação, delegando algumas etapas para subclasses.
                        O padrão Template Method permite que subclasses redefinam certas etapas de um algoritmo
                        sem alterar a estrutura do algoritmo.
            . Command: Encapsula uma solicitação como um objeto, permitindo assim parametrizar clientes com
                        solicitações diferentes, enfileirar ou registrar solicitações e oferecer suporte a 
                        operações reversíveis.
            . Iterator: Fornece uma maneira de acessar os elementos de um objeto agregado sequencialmente sem
                        expor sua representação subjacente.
            . Memento: Sem violar o encapsulamento, capture e externalize o estado interno de um objeto para que
                        o objeto possa ser restaurado a esse estado posteriormente.
            . State: Permite que um objeto altere seu comportamento quando seu estado interno mudar. O objeto 
                        parecerá mudar de classe.
            . Mediator: Centralizar a comunicação entre objetos, fazendo com que eles não se comuniquem diretamente 
                        entre si, mas sim através de um objeto mediador.
            . Chain of Responsibility: Permite que uma solicitação percorra uma cadeia de manipuladores, 
                                        onde cada manipulador decide se processa a solicitação ou a 
                                        encaminha para o próximo. 
            . Interpreter: Dada uma linguagem, defina uma representação para sua gramática juntamente com um 
                            interpretador que use a representação para interpretar frases na linguagem.
    
    . Design Patterns adicionais:

        . Simple Factor: Cria um objeto sem expor a lógica de criação para o cliente.
        . Null Object: Fornece um objeto “nulo” com comportamento padrão, em vez de usar null. Em vez de retornar 
                        null e obrigar o código cliente a verificar if(obj != null), Você retorna um objeto especial, 
                        que implementa a mesma interface, seguindo um comportamento neutro, seguro e vazio.

        . MVC: padrão arquitetural que separa uma aplicação em três componentes principais: model (dados e regras de negócio),
                View (interface com o usuário), Controller (controle do fluxo e orquestração das ações). O objetivo do MVC 
                é organizar o código, separar responsabilidades e tornar o sistema mais manutenível, testável e escalável.

. Pattern Criacionais 

    . Singleton

        . Definição
            
            . Garante que uma classe tenha apenas uma única instância e fornece um ponto de acesso global para ela.

        . Conceito

            . Uma determinada classe deve ter apenas uma instância. Você pode usar essa instância sempre que precisar e, portanto, 
                evitar a criação de objetos desnecessários.

        . Ilustração

                Client(Program.cs)


                Singleton


            . O construtor é private, assim não poderá ser instanciado (new)

            . Antes de tentar criar um objeto, verificamos se existe uma cópia disponível. Se
                não existir, criamos novo objeto; caso contrário, reutilizamos a existente.

        . Exemplo

            // Singleton
            using System;
            namespace  Pattern.Creational.Singleton
            {               
                public sealed class Singleton       // sealed impedi que a classe Singleton seja herdada por outras classes
                {
                    private static readonly Singleton instance = new Singleton();
                    private int numberOfInstances = 0;

                    //Private constructor is used to prevent
                    //creation of instances with 'new' keyword outside this class
                    private Singleton()
                    {
                        Console.WriteLine("Instantiating inside the private constructor.");
                        numberOfInstances++;
                        Console.WriteLine("Number of instances ={0}", numberOfInstances);
                    }


                    // Detalhe importante, o bloco abaixo é uma propriedade e não um método. 
                    // Se terminasse com "()" seria um método e poderiamos retornar o "instance" com 
                    // "return instance"
                    public static Singleton Instance
                    {
                        get
                        {
                            Console.WriteLine("We already have an instance now.Use it.");
                            return instance;
                        }
                    }
                }
            }        


            // Program

            using Pattern.Creational.Singleton;

            class Program
            {
                static void Main()
                {
                    Console.WriteLine("***Singleton Pattern Demo***\n");
                    //Console.WriteLine(Singleton.MyInt);
                    // Private Constructor.So,we cannot use 'new' keyword.
                    Console.WriteLine("Trying to create instance s1.");
                    Singleton s1 = Singleton.Instance;
                    Console.WriteLine("Trying to create instance s2.");
                    Singleton s2 = Singleton.Instance;
                    if (s1 == s2)
                    {
                        Console.WriteLine("Only one instance exists.");
                    }
                    else
                    {
                        Console.WriteLine("Different instances exist.");
                    }
                    Console.Read();
                }
            }

    . Prototype

        . Definição

            .  Especifica os tipos de objetos para criar utilizando uma intância prototipada, criando um novo objeto 
                copiando neste prtotipo.

        . Conceito

            . Fornece um método para criar, ou clonar, uma instância de um objeto existente. 

        . Ilustração


                            BasicCar    <-------    Client( Program.cs )
                            ^      ^
                            |      |
                            |      |
                        Nano   Ford

            . BasiCar é o prototipo. 
            . Nano e Ford são as classes concretas prototipadas, que implementam o método "clone"
            . Client inicialemente cria o objeto prototipada com os objetos Nano e Ford, posteriormente
                alteramos o preço da classe prototipada.

        . Exemplo

            // BasicCar
            using System;

            namespace  Pattern.Creational.Prototype
            {
                public abstract class BasicCar
                {
                    public string? ModelName { get; set; }
                    public int Price { get; set; }
                    public static int SetPrice()
                    {
                        int price = 0;
                        Random r = new Random();
                        int p = r.Next(200000, 500000);
                        price = p;
                        return price;
                    }
                    public abstract BasicCar Clone();
                }
            }


        
            //Nano.cs
            using System;

            namespace  Pattern.Creational.Prototype
            {
                public class Nano : BasicCar
                {
                    public Nano(string m)
                    {
                        ModelName = m;
                    }
                    public override BasicCar Clone()
                    {
                        return (Nano)this.MemberwiseClone();    // MemberwiseClone() -> cria uma cópia shallow do objeto, 
                    }                                           // copiando todos os valores dos campos (fields) para 
                }                                               // um novo objeto da mesma classe.
            }        



            //Ford.cs
            using System;

            namespace  Pattern.Creational.Prototype
            {
                public class Ford : BasicCar
                {
                    public Ford(string m)
                    {
                        ModelName = m;
                    }
                    public override BasicCar Clone()
                    {
                        return (Ford)this.MemberwiseClone();
                    }
                }
            }



            // Client( Program.cs )
            using Pattern.Creational.Prototype;

            class Program
            {
                static void Main()
                {
                    Console.WriteLine("***Prototype Pattern Demo***\n");

                    //Base or Original Copy
                    BasicCar nanoBase = new Nano("Green Nano") { Price = 100000 };
                    BasicCar fordBase = new Ford("Ford Yellow") { Price = 500000 };
                    
                    BasicCar bcNano;
                    
                    //Nano
                    bcNano = nanoBase.Clone();
                    bcNano.Price = nanoBase.Price + BasicCar.SetPrice();
                    Console.WriteLine("Car is: {0}, and it's price is Rs. {1}", bcNano.ModelName, bcNano.Price);
                    
                    //Ford
                    bcNano = fordBase.Clone();
                    bcNano.Price = fordBase.Price + BasicCar.SetPrice();
                    Console.WriteLine("Car is: {0}, and it's price is Rs. {1}", bcNano.ModelName, bcNano.Price);

                    Console.ReadLine();
                }
            }

    . Builder

        . Definição

            . Separa a construção de um objeto complexo de sua representação, permitindo que o mesmo processo gere 
                diferentes representações.

        . Conceito 

            . É util para criar objetos complexos, que tem multiplas partes. O processo de criação de um objeto terá
                partes independentes. O processo de criação não se importa como as partes são montadas.
                
        . Ilustração

                                Director    <>----------  Builder

                                                            ^
                                                            |
                                                            |

                                                        ConcreteBuilder ------> Product



        . Exemplo

            // Builders common interface
            using System;
            using System.Collections.Generic;

            namespace  Pattern.Creational.Builder
            {
                internal interface IBuilder
                {
                    void StartUpOperations();
                    void BuildBody();
                    void InsertWheels();
                    void AddHeadlights();
                    void EndOperations();
                    Product GetVehicle();
                }
            }


            // ConcreteBuilder: Car
            using Pattern.Creational.Builder;

            class Car : IBuilder
            {
                private string brandName;
                private Product product;

                public Car(string brand)
                {
                    product = new Product();
                    this.brandName = brand;
                }

                public void StartUpOperations()
                { //Starting with brandname
                    product.Add(string.Format("Car Model name :{0}", this.
                    brandName));
                }

                public void BuildBody()
                {
                    product.Add("This is a body of a Car");
                }

                public void InsertWheels()
                {
                    product.Add("4 wheels are added");
                }

                public void AddHeadlights()
                {
                    product.Add("2 Headlights are added");
                }

                public void EndOperations()
                { //Nothing in this case
                }

                public Product GetVehicle()
                {
                    return product;
                }
            }


            // ConcreteBuilder:Motorcycle
            using Pattern.Creational.Builder;

            class MotorCycle : IBuilder
            {
                private string brandName;
                private Product product;
                public MotorCycle(string brand)
                {
                    product = new Product();
                    this.brandName = brand;
                }
                public void StartUpOperations()
                { //Nothing in this case
                }
                public void BuildBody()
                {
                    product.Add("This is a body of a Motorcycle");
                }
                public void InsertWheels()
                {
                    product.Add("2 wheels are added");
                }
                public void AddHeadlights()
                {
                    product.Add("1 Headlights are added");
                }
                public void EndOperations()
                {
                    //Finishing up with brandname
                    product.Add(string.Format("Motorcycle Model name :{0}",
                    this.brandName));
                }
                public Product GetVehicle()
                {
                    return product;
                }
            }



            // "Product"
            namespace  Pattern.Creational.Builder;

            class Product
            {
                // We can use any data structure that you prefer e.g.List<string> etc.
                private LinkedList<string> parts;
                public Product()
                {
                    parts = new LinkedList<string>();
                }
                public void Add(string part)
                {
                    //Adding parts
                    parts.AddLast(part);
                }
                public void Show()
                {
                    Console.WriteLine("\nProduct completed as below :");
                    foreach (string part in parts)
                        Console.WriteLine(part);
                }
            }



            // "Director"
            using Pattern.Creational.Builder;

            class Director
            {
                IBuilder builder;
                // A series of steps-in real life, steps are complex.
                public void Construct(IBuilder builder)
                {
                    this.builder = builder;
                    builder.StartUpOperations();
                    builder.BuildBody();
                    builder.InsertWheels();
                    builder.AddHeadlights();
                    builder.EndOperations();
                }
            }

    . Factory Method
    
        . Definição

            . Define uma interface para a criação de objetos, mas deixa as subclasses decidir qual classe
                será instanciada. O padrão Factory Method permite que uma classe diferencie a subclasse a 
                ser instanciada.

        . Ilustração

                                +-----------------------+               +-----------------------+       +-----------------------+
                                |     IAnimalFactory    |               |       Client          |       |       IAnimal         |
                                |   <<Abstract Class>>  |               |      <<Class>>        |       |       <<Interface>>   |
                                +-----------------------+               +-----------------------+       +-----------------------+
                                |                       |               |                       |       |                       |
                                +-----------------------+               +-----------------------+       +-----------------------+
                                | + CreateAnimal        |               | # Main                |       | + Action              |
                                +-----------------------+               +-----------------------+       | + Speak               |
                                            ^                                                           +-----------------------+
                                        /_\
                                            |
                            +---------------------------+
                            |                           |
            +-----------------------+       +-----------------------+   +-----------------------+   +-----------------------+
            |     IAnimalFactory    |       |       TiegerFactory   |   |           Dog         |   |       Tiger           |
            |   <<Abstract Class>>  |       |       <<Class>>       |   |         <<Class>>     |   |       <<Class>>       |
            +-----------------------+       +-----------------------+   +-----------------------+   +-----------------------+
            |                       |       |                       |   |                       |   |                       |
            +-----------------------+       +-----------------------+   +-----------------------+   +-----------------------+ 
            | + CreateAnimal        |       | + CreateAnimal        |   | + Action              |   | + Action              |
            +-----------------------+       +-----------------------+   | + Speak               |   | + Speak               |
                                                                        +-----------------------+   +-----------------------+

        . Exemplo

            . Primeira Versão

                // Interface para as classes de criação
                namespace  Pattern.Creational.FactoryMethod;

                public interface IAnimal
                {
                    void Speak();
                    void Action();
                }


                // Interface para as classe de fabricação

                namespace  Pattern.Creational.FactoryMethod;

                public abstract class IAnimalFactory
                {
                    //Remember the GoF definition which says "....Factory method lets a class
                    //defer instantiation to subclasses." Following method will create a Tiger
                    //or Dog But at this point it does not know whether it will get a Dog or a
                    //Tiger. It will be decided by the subclasses i.e.DogFactory or TigerFactory.
                    //So, the following method is acting like a factory (of creation).

                    public abstract IAnimal CreateAnimal();
                }            


                // Classes de criação
                namespace  Pattern.Creational.FactoryMethod;

                public class Dog : IAnimal
                {
                    public void Speak()
                    {
                        Console.WriteLine("Dog says: Bow-Wow.");
                    }
                    public void Action()
                    {
                        Console.WriteLine("Dogs prefer barking...\n");
                    }
                }


                // Classe de criação
                namespace  Pattern.Creational.FactoryMethod;

                public class Tiger: IAnimal
                {
                    public void Speak()
                    {
                        Console.WriteLine("Tiger say: Halum.");
                    }

                    public void Action()
                    {
                        Console.WriteLine("Tigers prefer hunting....\n");
                    }
                }



                // Factory da classe Dog
                namespace  Pattern.Creational.FactoryMethod;

                public class DogFactory: IAnimalFactory
                {
                    public override IAnimal CreateAnimal()
                    {
                        return new Dog();
                    }
                }


                // Factory da classe Tiger
                namespace  Pattern.Creational.FactoryMethod;

                public class TigerFactory: IAnimalFactory
                {
                    public override IAnimal CreateAnimal()
                    {
                        return new Tiger();
                    }
                }



                // Classe "client" para efetuar as chamadas
                using Pattern.Creational.FactoryMethod;


                class Program
                {
                    static void Main()
                    {
                        Console.WriteLine("*** Factory Pattern Demo***\n");

                        IAnimalFactory tigerFactory = new TigerFactory();
                        IAnimalFactory dogFactory = new DogFactory();

                        IAnimal tiger = tigerFactory.CreateAnimal();

                        IAnimal dog = dogFactory.CreateAnimal();

                        tiger.Speak();
                        tiger.Action();

                        dog.Speak();
                        dog.Action();

                        Console.ReadKey();
                    }
                }

            . Melhorias

                // Inserção do método MakeAnimal, assim todas as Factory implementarão automaticamente esse método.
                // Quando for chamado o método MakeAnimal das classes [Dog/Tiger]Factory, a chamada será da classe
                // abstrata pai "IAnimalFactory" e consequentemente retornará a classe de criação Dog/Tiger
                namespace  Pattern.Creational.FactoryMethod;

                public abstract class IAnimalFactory
                {
                    public abstract IAnimal CreateAnimal();

                    // Método inserido
                    public IAnimal MakeAnimal()
                    {
                        IAnimal animal = CreateAnimal();

                        animal.Speak();
                        animal.Action();

                        return animal;
                    }
                }




                using Pattern.Creational.FactoryMethod;


                class Program
                {
                    static void Main()
                    {
                        Console.WriteLine("*** Factory Pattern Demo***\n");

                        IAnimalFactory tigerFactory = new TigerFactory();
                        IAnimalFactory dogFactory = new DogFactory();

                        /*  Trecho substituido
                        IAnimal tiger = tigerFactory.CreateAnimal();
                        IAnimal dog = dogFactory.CreateAnimal();
                        */

                        // Linha inserida
                        IAnimal tiger = tigerFactory.MakeAnimal();

                        // Linha inserida
                        IAnimal dog = dogFactory.MakeAnimal();
                        
                        tiger.Speak();
                        tiger.Action();

                        dog.Speak();
                        dog.Action();

                        Console.ReadKey();
                    }
                }

    . Abstract Factory

        . Definição

            . É um padrão que fornece uma interface para criar grupos de objetos relacionados entre si, garantindo 
                que o código cliente use apenas interfaces/abstrações, nunca classes concretas.

            . Suponha que queiramos categorizar cachorros e tigres, e escolhemos obter um animal pet (cachorro ou tigre);
                ou um animal selvagem (cachorro ou tigre) através de uma fabrica. Introduziremos duas fabricas concretas:
                WildAnimalFactory (responsável pela criação de animias selvagens) e PetAnimalFactory (responsável pela 
                criação dos animais pet).


        .Exemplo

            // Interface IDog
            namespace  Pattern.Creational.AbstractFactory;

            public interface IDog
            {
                void Speak();
                void Action();
            }


            // Interface ITiger
            namespace  Pattern.Creational.AbstractFactory;

            public interface ITiger
            {
                void Speak();
                void Action();
            }


            // Classe PetDog
            namespace  Pattern.Creational.AbstractFactory;

            class PetDog : IDog
            {
                public void Speak()
                {
                    Console.WriteLine("Pet Dog says: Bow-Wow.");
                }
                public void Action()
                {
                    Console.WriteLine("Pet Dogs prefer to stay at home.\n");
                }
            }


            // Classe PetTiger
            namespace  Pattern.Creational.AbstractFactory;

            class PetTiger : ITiger
            {
                public void Speak()
                {
                    Console.WriteLine("Pet Tiger says: Halum.");
                }
                public void Action()
                {
                    Console.WriteLine("Pet Tigers play in an animal circus.\n");
                }
            }


            // Classe WildDog
            namespace  Pattern.Creational.AbstractFactory;

            class WildDog : IDog
            {
                public void Speak()
                {
                    Console.WriteLine("Wild Dog says: Bow-Wow.");
                }
                public void Action()
                {
                    Console.WriteLine(@"Wild Dogs prefer to roam freely in
                    jungles.\n");
                }
            }


            // Classe WildTiger
            namespace  Pattern.Creational.AbstractFactory;

            class WildTiger : ITiger
            {
                public void Speak()
                {
                    Console.WriteLine("Wild Tiger says: Halum.");
                }
                public void Action()
                {
                    Console.WriteLine("Wild Tigers prefer hunting in jungles.\n");
                }
            }


            // Interface IAnimalFactory
            namespace  Pattern.Creational.AbstractFactory;

            public interface IAnimalFactory
            {
                IDog GetDog();
                ITiger GetTiger();
            }



            // Classe Factory PetAnimalFactory
            namespace  Pattern.Creational.AbstractFactory;

            public class PetAnimalFactory : IAnimalFactory
            {
                public IDog GetDog()
                {
                    return new PetDog();
                }
                public ITiger GetTiger()
                {
                    return new PetTiger();
                }
            }


            // Classe Factory WildAnimalFactory
            namespace  Pattern.Creational.AbstractFactory;

            public class WildAnimalFactory : IAnimalFactory
            {
                public IDog GetDog()
                {
                    return new WildDog();
                }
                public ITiger GetTiger()
                {
                    return new WildTiger();
                }
            }





            // Classe Client "Program.cs"
            using Pattern.Creational.AbstractFactory;


            class Program
            {
                static void Main()
                {
                    Console.WriteLine("***Abstract Factory Pattern Demo***\n");
                    //Making a wild dog through WildAnimalFactory
                    IAnimalFactory wildAnimalFactory = new WildAnimalFactory();

                    IDog wildDog = wildAnimalFactory.GetDog();

                    wildDog.Speak();
                    wildDog.Action();

                    //Making a wild tiger through WildAnimalFactory
                    ITiger wildTiger = wildAnimalFactory.GetTiger();

                    wildTiger.Speak();
                    wildTiger.Action();

                    Console.WriteLine("******************");
                    
                    //Making a pet dog through PetAnimalFactory
                    IAnimalFactory petAnimalFactory = new PetAnimalFactory();

                    IDog petDog = petAnimalFactory.GetDog();

                    petDog.Speak();
                    petDog.Action();

                    //Making a pet tiger through PetAnimalFactory
                    ITiger petTiger = petAnimalFactory.GetTiger();

                    petTiger.Speak();
                    petTiger.Action();


                    Console.ReadKey();
                }
            }


. Pattern Estruturais

    . Proxy

        . Definição

            . É um padrão estrutural que fornece um objeto substituto para controlar o acesso a outro objeto, podendo 
                adicionar comportamentos extras antes ou depois da operação real.

        . Conceito

            . Um proxy é como um substituto para um objeto real. Quando o cliente usa o proxy, ele acha que está 
                falando diretamente com o objeto verdadeiro — mas, na verdade, está falando com o substituto.

            . Isso é útil porque nem sempre é possível acessar o objeto real diretamente.

            . Pode ser por causa de:

                . segurança,

                . desempenho,

                . o objeto real ser pesado para carregar,

                . ou porque ele está em outro computador.

            . Então o padrão Proxy ajuda criando uma classe intermediária, que age como se fosse o objeto 
                verdadeiro e serve de ponte para ele.

            . Resumindo: Proxy é um objeto que fica no lugar do real e controla o acesso a ele.

        . Ilustração

                            +-------------------+                       +-------------------+
                            | Subject           |                       | Program           |
                            | <<Absract Class>> |                       | <<Class>>         |
                            +-------------------+                       +-------------------+
                            |                   |                       |                   |
                            +-------------------+                       +-------------------+
                            | + DoSomeWork      |                       | + Main            |
                            +-------------------+                       +-------------------+
                                    ^
                                   / \
                                    |
                    +-------------------------------+
                    |                               |
            +-------------------+       +-------------------+
            | Proxy             |       | ConcreteSubject   |
            | <<Class>>         |       | <<Class>>         |
            +-------------------+       +-------------------+
            | # subject         |       |                   |
            +-------------------+       +-------------------+
            | + DoSomeWork      |       | + DoSomeWork      |
            +-------------------+       +-------------------+

        . Exemplo

            // Abstract Classe Subject
            namespace Pattern.Structural.Proxy;

            public abstract class Subject
            {
                public abstract void DoSomeWork();
            }


            // Classe ConcreteSubject
            namespace Pattern.Structural.Proxy;

            public class ConcreteSubject : Subject
            {
                public override void DoSomeWork()
                {
                    Console.WriteLine("ConcreteSubject.DoSomeWork()");
                }
            }


            // Classe Proxy
            namespace Pattern.Structural.Proxy;

            public class Proxy : Subject
            {
                Subject subject;
                public override void DoSomeWork()
                {
                    Console.WriteLine("Proxy call happening now...");
                    //Lazy initialization:We'll not instantiate until the method is
                    //called
                    if (subject == null)
                    {
                        subject = new ConcreteSubject();
                    }
                    subject.DoSomeWork();
                }
            }


            // Classe "Client" "Program.cs"
            using Pattern.Structural.Proxy;

            class Program
            {
                static void Main()
                {
                    Console.WriteLine("***Proxy Pattern Demo***\n");

                    Proxy px = new Proxy();
                    px.DoSomeWork();

                    Console.ReadKey();
                }
            }

    . Decorator

        . Definição

            . Permite adicionar responsabilidades (comportamentos) a um objeto dinamicamente, 
                colocando-o dentro de outro objeto que envolva o original. Decorators 
                oferecem uma alternativa flexível à herança para estender funcionalidades.
    
        . Conceito

            . Este padrão promove o conceito de que sua classe deve ser fechada para modificação,
                mas aberta para extensão. Em outras palavras, você pode adicionar uma funcionalidade 
                sem atrapalhar as funcionalidades existentes. O conceito é útil quando você deseja 
                adicionar alguma funcionalidade especial a um objeto específico em vez de toda 
                a classe. Este padrão prefere a composição de objetos à herança. Depois de 
                dominar essa técnica, você pode adicionar novas
                responsabilidades a um objeto sem afetar as classes subjacentes.

        . Ilustração



                            +---------------------+
                            |     Component       |
                            | <<Abstract Class>>  |
                            |---------------------|
                            | + MakeHouse()       |
                            +----------+----------+
                                    ^
                                    |
                        +-----------+-----------+
                        |                       |
            +--------------------------+   +------------------------------------------------------------+
            |     ConcreteComponent    |   |    AbstractDecorator                                       |
            |                          |   |    <<Abstract Class>>                                      |
            |--------------------------|   |------------------------------------------------------------|
            | + MakeHouse()            |   | - _component: Component                                    |
            +--------------------------+   |------------------------------------------------------------+
                                           | + AbstractDecorator(Component component) <<constructor>>   |
                                           | + SetTheComponent()                                        |
                                           | + MakeHouse()                                              |
                                           +-----------+------------------------------------------------+
                                                                        ^
                                                                        |
                                                    +-------------------+------------------+
                                                    |                                      |
                                        +---------------------------+        +---------------------------+
                                        |    ConcreteDecoratorA     |        |    ConcreteDecoratorB     |
                                        |---------------------------|        |---------------------------|
                                        | + MakeHouse()             |        | + MakeHouse()             |
                                        | + AddFloor()              |        | + PaintTheHouse()         |
                                        +---------------------------+        +---------------------------+

        . Exemplo


            namespace Pattern.Structural.Decorator;
            public abstract class Component
            {
                public abstract void MakeHouse();
            }




            namespace Pattern.Structural.Decorator;

            public abstract class AbstractDecorator: Component
            {
                
                protected Component _component;

                public void SetTheComponent(Component component)
                {
                    this._component = component;
                }

                public override void MakeHouse()
                {
                    if ( _component != null)
                    {
                        _component.MakeHouse();
                    }
                }

                protected AbstractDecorator( Component component)
                {
                    this._component = component;
                }

            }




            namespace Pattern.Structural.Decorator;

            public class ConcreteComponent : Component
            {

                public override void MakeHouse()
                {
                    Console.WriteLine("WriteLine(\"A casa original está completa. Ela está fechada para modificações!!!\"");
                }
            }





            namespace Pattern.Structural.Decorator;

            public class ConcreteDecoratorA: AbstractDecorator
            {
                public override void MakeHouse()
                {
                    base.MakeHouse();
                    AddFloor();
                    Console.WriteLine("A casa foi decorada com o estilo A.");
                }
                void AddFloor()
                {
                    Console.WriteLine("Adicionando mais um andar do ConcreteDecoratorA.");
                }

                public ConcreteDecoratorA(Component component): base(component)
                {

                }
            }


            using System.ComponentModel;

            namespace Pattern.Structural.Decorator;

            public class ConcreteDecoratorB: AbstractDecorator
            {
                public override void MakeHouse()
                {
                    Console.WriteLine("");

                    base.MakeHouse();
                    Console.WriteLine("Usando outro Decorator");

                    AddGarage();

                    Console.WriteLine("A casa foi decorada com o estilo B.");
                }

                void AddGarage()
                {
                    Console.WriteLine("Garagem foi adicionada pelo ConcreteDecorateB.");
                }

                public ConcreteDecoratorB( Component component) : base(component)
                {
                    
                }
            }



            using Pattern.Structural.Decorator;

            class Program
            {
                static void Main()
                {
                    Console.WriteLine("***Decorator Pattern Demo***\n");

                    ConcreteComponent cc = new ConcreteComponent();

                    ConcreteDecoratorA decoratorA = new ConcreteDecoratorA(cc);
                    // decoratorA.SetTheComponent(cc);

                    decoratorA.MakeHouse();

                    ConcreteDecoratorB decoratorB = new ConcreteDecoratorB(decoratorA);
                    // decoratorB.SetTheComponent(decoratorA);
                    decoratorB.MakeHouse();


                    Console.ReadKey();
                }
            }


    . Adapter

        . Definição

            . Permite que interfaces incompatíveis trabalhem juntas, convertendo a interface de uma 
                classe em outra interface esperada pelos clientes


        . Ilustração

            +------------------------+
            |      ITwoPinPlug       |  <<Target>>
            |------------------------|
            | + Connect2Pins()       |
            +-----------+------------+
                        ^
                        |
            +-----------+------------+
            |     TwoPinOutlet       |  (Cliente usa isso)
            |------------------------|
            | + SupplyPower(ITwoPinPlug) |
            +------------------------+

            +------------------------+
            |     ThreePinDevice     |  <<Adaptee>>
            |------------------------|
            | + Connect3Pins()       |
            +------------------------+

            +------------------------+
            |     PlugAdapter        |  <<Adapter>>
            |------------------------|
            | - device: ThreePinDevice |
            |------------------------|
            | + PlugAdapter(device)  |
            | + Connect2Pins()       |
            |     (chama device.Connect3Pins()) |
            +------------------------+

            +------------------------+
            |        Program         |
            +------------------------+
            | + Main()               |
            +------------------------+

        . Exemplo:

            using System;

            namespace AdapterExample2
            {
                // Target - Interface que o sistema espera
                public interface ITwoPinPlug
                {
                    void Connect2Pins();
                }

                // Adaptee - Classe incompatível
                public class ThreePinDevice
                {
                    public void Connect3Pins()
                    {
                        Console.WriteLine("Three-pin device connected using 3 pins.");
                    }
                }

                // Adapter - converte a interface
                public class PlugAdapter : ITwoPinPlug
                {
                    private readonly ThreePinDevice device;

                    public PlugAdapter(ThreePinDevice device)
                    {
                        this.device = device;
                    }

                    public void Connect2Pins()
                    {
                        Console.WriteLine("Adapter converting 2-pin request to 3-pin...");
                        device.Connect3Pins();
                    }
                }

                // Cliente
                public class TwoPinOutlet
                {
                    public void SupplyPower(ITwoPinPlug plug)
                    {
                        Console.WriteLine("Outlet supplying power...");
                        plug.Connect2Pins();
                    }
                }

                class Program
                {
                    static void Main()
                    {
                        var outlet = new TwoPinOutlet();

                        // Aparelho incompatível
                        var modernDevice = new ThreePinDevice();

                        // Adaptando o aparelho para 2 pinos
                        ITwoPinPlug adapter = new PlugAdapter(modernDevice);

                        // Cliente funciona normalmente
                        outlet.SupplyPower(adapter);

                        Console.ReadKey();
                    }
                }
            }

    . Facade
    