Fundamentos C# - Balta

Instalação AspNetCore 3.1
-------------------------

https://balta.io/blog/dotnet-instalacao-configuracao-e-primeiros-passos#criando-seu-primeiro-app
https://www.tutorialsteacher.com/csharp
https://www.javatpoint.com/c-sharp-tutorial


    . Acesse o link abaixo para baixar o .NET Core 3.1

        https://dotnet.microsoft.com/download

    . Acesse o download "All .NET Core downloads" e baixe a versão 3.1

    . Acesse o link "Package manager instructions" 

    . Localize a versão do Ubuntu que está sendo utilizado, copie e execute os comandos no 
        terminal:

        wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
        sudo dpkg -i packages-microsoft-prod.deb

        sudo dpkg --purge packages-microsoft-prod && sudo dpkg -i packages-microsoft-prod.deb
        sudo apt-get update

        sudo apt-get install -y gpg
        wget -O - https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor -o microsoft.asc.gpg
        sudo mv microsoft.asc.gpg /etc/apt/trusted.gpg.d/
        wget https://packages.microsoft.com/config/ubuntu/20.04/prod.list
        sudo mv prod.list /etc/apt/sources.list.d/microsoft-prod.list
        sudo chown root:root /etc/apt/trusted.gpg.d/microsoft.asc.gpg
        sudo chown root:root /etc/apt/sources.list.d/microsoft-prod.list

        # Comando para o Ubuntu 22.04 em diante
        # wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.0g-2ubuntu4_amd64.deb
        # sudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb
        
        sudo apt-get update; \
        sudo apt-get install -y apt-transport-https && \
        sudo apt-get update && \
        sudo apt-get install -y dotnet-sdk-5.0

        sudo apt-get install -y apt-transport-https && \
        sudo apt-get update && \
        sudo apt-get install -y aspnetcore-runtime-5.0

        sudo apt-get install -y dotnet-runtime-5.0

    . Para testar a instalação execute os comandos abaixo:

        dotnet --version
        dotnet --help
        dotnet --list
        dotnet --list-runtimes
        dotnet --list-sdks


Instalação das extensões do VSCode
----------------------------------

        C# 
        C# Extensions
        C# XML Documentation Comments
        vscode-icons (Opcional)

    . Atalhos:

        Ctrl + K + D ou Shit + Alt + F:             Identa todo o seu código automaticamente;
        Ctrl + K + C:                               comenta um bloco de linhas;
        Ctrl + K + U:                               descomenta um bloco de linhas;
        Alt + Left Arrow:                           durante a programação, volta um método que você estava navegando;
        Alt + Right Arrow:                          durante a programação, avança um método que você estava navegando;
        Ctrl + .:                                   implementa o método/classe inexistente que você acabou de escrever;
        Ctrl + M + O:                               esconde todas as regions da classe atual;
        Ctrl + Shift + B:                           compila todos os projetos;
        F5:                                         manda depurar um projeto;
        Ctrl + F5:                                  manda executar um projeto;
        F10:                                        durante a depuração, avança uma linha;
        F11:                                        durante a depuração, avança uma linha entrando nos detalhes da mesma;


Configurar Visual Studio Code para .NETCore
-------------------------------------------

    . Acesse File / Preferences / Settings

    . Digite C#

    . Acesse "C# Configuration / CSharp Format Enabled" e habilite a configuração

    . Digite "Format on save" e habilite a configuração

    . Digite "Final" e habilite a configuração "Files: Insert final newline" e habilite a configuração


.NET Core Command-Line Interface (CLI)    
--------------------------------------

    . Digite no terminal "dotnet --info" para apresentar informações variadas da instação do dotnet

    . Digite no terminal "dotnet new" irá apresentar as várias possibilidades de criar diversos projetos, exemplo:

        dotnet new mvc

        dotnet run

        #Acesse o navegador e digite a URL: https://localhost:5001/ para ver o resultado do projeto criado.

    . Ctrl + C no terminal acaba com a execução do projeto:

https://www.infoq.com/br/articles/netcore-cli/    


    . Comandos dotnet cli:

        dotnet new console          => Novo Console Application
        dotnet new classlib         => Nova Class Library
        dotnet new web              => Novo projeto ASP.NET Core
        dotnet new mvc              => Novo projeto ASP.NET Core
        dotnet new webapi           => Novo projeto ASP.NET Core
        dotnet new mstest           => Novo projeto Microsoft Test

Instalar pacotes através do Nuget.org
-------------------------------------

    . Ao ser compilada, uma biblioteca gera um arquivo DLL. Será esta DLL que os outros projetos irão utilizar. 
        O NuGet aproveita desta característica da plataforma para definir seus pacotes.

    . Na prática, um pacote NuGet é um arquivo compactado com a extensão .nupkg que contém um código compilado (DLL), 
        outros arquivos relacionados a este código (como imagens, etc.) e um arquivo de configuração que contém 
        informações sobre o pacote, como: número de versão, criador, etc.

    . Estes pacotes .nupkg podem ser publicados em repositórios públicos ou privados, onde os desenvolvedores podem 
        consumi-los, adicionando-os em seus projetos e utilizando no código as funcionalidades que fornecerem.

    . Em se tratando de projeto, como se fosse as dependências de bibliotecas.

    . Acesse o site nuget.org, digite "Microsoft Entity Framework Core" e faça a pesquisa.

    . Acesse o item Microsoft.EntityFrameworkCore.

    . Acesse uma das versões, atualmente 5.0.5.
    
    . Acesse a aba .NetCli.

    . Copie o comando sugerido por esse caminho:

        dotnet add package Microsoft.EntityFrameworkCore --version 5.0.5

    . Acesse o terminal, vá na pasta do projeto e execute o comando acima. Cuidado é necessário acessar a pasta do projeto
        e não da solução, exemplo: ~/workspace-two/CSharpBasico/helloWorld.


    . Após a execução, no terminal, execute um dos comandos abaixo:

        dotnet restore

        ou

        dotnet build

    . Acesse o Visual Studio Code "code ." para entrar no projeto e acesse o arquivo com extensão "*.csproj". Podemos verificar 
        que agora temos o pacote dentro da aplicação:

        <ItemGroup>
            <PackageReference Include="Microsoft.EntityFrameworkCore" Version="5.0.5" />
        </ItemGroup>

    . Retorne ao Home do site nuget.org e digite "Pomelo Entity Framework core" e acesse o link do MySQL.

    . Acesse a aba "PackageReference" e copie o comando sugerido:

    . Acesse novamente o arquivo com a extensão *.csproj e insira a dependência copiada dentro do nó "ItemGroup":

        <ItemGroup>
            <PackageReference Include="Microsoft.EntityFrameworkCore" Version="5.0.5" />
            <PackageReference Include="Pomelo.EntityFrameworkCore.MySql" Version="5.0.0-alpha.2" />    
        </ItemGroup>

    . Salve o conteúdo do arquivo, o VsCode irá pedir para dar o "Restore", confirme o restore.

    . Se quiser podemos dar o "dotnet restore", ou o "dotnet build", no terminal.

    . Caso haja a necessidade de retirar alguma dependência do nó "ItemGroup", acesse o terminal, e execute os comandos abaixo:

        dotnet clean
        dotnet restore


Documentação do C# e o que eu posso fazer com C#
------------------------------------------------

    . A documentação da Microsoft encontra-se no link abaixo:

        https://docs.microsoft.com/pt-br/dotnet/csharp


Criando uma Solution
--------------------

    . Crie uma pasta com o nome CSharpBasico

    . Digite o comando abaixo para verificar as opções do compilador dotnet:

        dotnet new

    . Dentro da pasta CSharpBasico digite o comando abaixo:

        dotnet new sln --name CSharpBasico

    . Para acessar a solução com o VisualStudio Code digite o comando abaixo:

        code .

    . Dentro da "Solution" criaremos um projeto, do tipo console:

        dotnet new console -n HelloWorld -o helloWorld
        
        -n : name da aplicação (Nome do projeto HelloWorld.csproj )
        -o : output (nome da pasta que será criado para criar as classes)

    . Para baixar todos os pacotes do projeto usamos o comando abaixo:

        dotnet restore

        . Basicamente o "restore" é feito somente a primeira vez que abrimos o projeto para baixar os pacotes de dependência.

    . A estrutura de pastas ficará:

        HelloWorld
        |
        +------ obj
        |
        + HelloWorld.csproj
        + Program.cs

    . Agora precisamos associar o projeto a solution

        dotnet sln add helloWorld/

    . Digite o comando abaixo para verificar os projetos que compoem a solution:

        dotnet sln list

    . Para limpar os arquivos de cache execute o comando abaixo:

        dotnet clean

    . Para compilar o projeto execute os comandos abaixo:

        dotnet clean
        dotnet build


    . O arquivo Program.cs possui um método main. Para executarmos a classe Program.cs digite os
        comandos abaixo:

        cd CSharpBasico/helloWorld

        dotnet run


Variáveis de Ambiente
---------------------

    . Para trabalhar com variáveis de ambiente podemos passar como parâmetro no comando "dotnet run":

        dotnet run --enviroment=$SEU_AMBIENTE
        dotnet run --enviroment=development
        dotnet run --enviroment=production


Dica para alterar a versão do dotnet de um projeto "console"
------------------------------------------------------------

    . Criando o projeto já com a versão desejada:

        dotnet new console -n HelloWorld -o helloWorld --framework [net5.0 / netcoreapp3.1]

        dotnet new console -n HelloWorld -o helloWorld -f [net5.0 / netcoreapp3.1]

    . Acesse o arquivo .csproj e altere o valor da tag <TargetFramework> para.

        netcoreapp3.1
        net5.0

        Exemplo:

        <Project Sdk="Microsoft.NET.Sdk">
            <PropertyGroup>
                <OutputType>Exe</OutputType>
                <TargetFramework>netcoreapp3.1</TargetFramework>
            </PropertyGroup>
        </Project>


Dica de como alterar a versão do AspNetCore em um novo Projeto
--------------------------------------------------------------

    . As configurações abaixo só funcionarão se houver mais de um SDK instalado no sistema operacional.

    . Acesse nosso diretório de projetos e crie as pastas abaixo:

        mkdir curso_api_netcore
        mkdir curso_api_netcore/src
        cd curso_api_netcore

    . No terminal digite o comando abaixo para verificar a versão dos SDKs disponível

        dotnet --list-sdks

    . Acesse o code e dentro da pasta curso_api_netcore/src crie o arquivo global.json

    . Coloque o conteúdo abaixo no arquivo global.json:

        {
            "sdk" : {
                "version" : "3.1.408"
            }     

        }

    . Acesse o terminal novamente, acesse a pasta curso_api_netcore/src e verifique a versão do SDK:

        dotnet --version

    . Acesse qualquer outra pasta e verifique novamente a versão

        dotnet --version

    . Se tudo der certo, teremos um SDK na pasta src diferente das outras pastas

    . Acesse a pasta src e digite o comando abaixo:

        dotnet new -n teste -o teste

    . Acesse a pasta do projeto teste dentro do VSCode e verifique o conteúdo do arquivo teste.csproj

        <Project Sdk="Microsoft.NET.Sdk.Web">

        <PropertyGroup>
            <TargetFramework>netcoreapp3.1</TargetFramework>
        </PropertyGroup>

        </Project>

    . Veja que o <TargetFramework> está configurado automaticamente para o SDK 3.1


Debugando dentro do VSCode
--------------------------

    . Digite Ctrl + Shift + P

    . Digite ".Net: Generate Assests for Build and Debug" para criar o "launch.json" e o "task.json"

    ou 

    . Acesse o projeto, vá para a área de Debug, acione a criação do "launch.json".

    ou

    . Dentro da pasta src acesse o VSCode, ao entrar pela primeira vez ele irá fazer uma pergunta para colocar o build e o debug no projeto,
        "Install C# Extensions", responda "Yes".

        code .

        . Ao responder "Yes", o VSCode ira criar uma pasta do projeto .vscode. Dentro desta pasta teremos dois arquivos
            ( launch.json e tasks.json). Esses arquivos criados automaticamente tem as configurações para depuração.

        . Podemos acessar a execução do projeto do icone com triângulo na barra vertical do VSCode, que surgira a "Side Bar".
            Neste ponto surgirá os botões de execução do projeto. 

        . Execute o projeto e no navegador execute a URL abaixo:

            http://localhost:5000/WeatherForecast

    
    . Pare a aplicação, e elimine os arquivos abaixo do projeto:

        /WeatherForecast.cs
        Controllers/WeatherForecastController.cs
        
    . No VSCode acesse a opção Terminal / Run Task... e escolha a opção "build"


.NET Standard
-------------

        +-----------------------------+-----------------------------+-----------------------------+
        |    .NET FRAMEWORK           |          .NET Core          |        XAMARIN              |
        +-----------------------------+-----------------------------+-----------------------------+
        |   WPF        Windows Forms  |          UWP                |     iOS                     |
        |        ASP.NET              |      ASP.NET Core           |               Android       |
        |                             |                             |    OS X                     |
        +-----------------------------+-----------------------------+-----------------------------+
        |                          .NET STANDARD LIBRARY                                          |
        |                                                                                         |
        +-----------------------------+-----------------------------+-----------------------------+

        +-----------------------------+-----------------------------+-----------------------------+
        |                       COMMON INFRASTRUCTURE                                             |
        +-----------------------------+-----------------------------+-----------------------------+
        |       Compilers             |     Languages               |        Runtime Components   |
        +-----------------------------+-----------------------------+-----------------------------+


Escopo de Programa
------------------

    using System;               // Importações

    namespace HelloWorld        // Equivalente aos pacotes/divisões lógica
    {
        class Program           // Definição da classe
        {
            static void Main(string[] args)     // Método
            {
                string texto = "Hello World";

                Console.WriteLine(texto);
            }
        }
    }
    

    . Namespace, Using

        . Crie dentro do projeto a classe abaixo Oi.cs:

            using System;

            namespace Teste
            {
                class Oi
                {
                    public void BoaNoite( string nome)
                    {
                        Console.WriteLine("Boa Noite " + nome);
                    }

                }
            }

        . Altere o Program.cs como abaixo:

            using System;
            using Teste;            // Importe da package "Teste" para acessar a classe Oi

            namespace HelloWorld
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        Oi oi = new Oi();

                        oi.BoaNoite("Marco");
                    }
                }
            }

        . Sugestão:
            
            . Crie o nome das namespace levemente parecido com a pasta do projeto, por exemplo:

                namespace Tutorial.Calculo
                {
                    ...
                }

                . Coloque a classe na pasta [Nome do projeto].Tutorial.Calculo. Se ambos forem iguais dará erro durante a compilação, 
                    pois não encontrará as referências das classes nas packages/namespace.


    . Variáveis, Constante

        . Uma variável pode ser iniciada pelo tipo (int, long, float, ...), ou pela palavra reservada "var":

            int idade = 10;
            var idade = 10;

            . "var" obriga que um valor seja informado, pois é através dele que o compilador determina o tipo da variável.

                int idade;      // Válido
                var idade;      // Inválido

        . Declaração de constantes

            const int IDADE_MINIMA = 10;
            const var IDADE_MINIMA = 10;
            const var IDADE_MINIMA;     // Inválido


Tipagem de Dados
----------------

    Tipos por valor ou primitivos:

        . São alocados diretamente na pilha.
        . Não precisam ser inicializados com o operador new.
        . A variável armazena o valor diretamente.
        . A atribuição de uma variável a outra copia o conteúdo, criando efetivamente outra cópia da variável.
        . Normalmente usados com tipos de pequeno tamanho (menos que 16 bytes), onde o uso de referências traria um custo muito grande.
        . Podem ser automaticamente convertidos para referências em um processo chamado “boxing”,

        Tipo        Implementação
        ----        -------------
        byte 	    Inteiro de 8 bits sem sinal (0 a 255).
        sbyte 	    Inteiro de 8 bits com sinal (-127 a 128).
        ushort 	    Inteiro de 16 bits sem sinal (0 a 65 535).
        short 	    Inteiro de 16 bits com sinal (-32 768 a 32 767).
        uint 	    Inteiro de 32 bits sem sinal (0 a 4 294 967 295).
        int 	    Inteiro de 32 bits com sinal (-2 147 483 648 a 2 147 483 647).
        ulong 	    Inteiro de 64 bits sem sinal (0 a 18 446 744 073 709 551 615).
        long 	    Inteiro de 64 bits com sinal (-9 223 372 036 854 775 808 a 9 223 372 036 854 775 807).
        double 	    Ponto flutuante binário IEEE de 8 bytes (±5.0×10-324 a ±1.7×10308), 15 dígitos decimais de precisão.
        float 	    Ponto flutuante binário IEEE de 4 bytes (±1.5×10-45 a ±3.4×1038), 7 dígitos decimais de precisão.
        decimal 	Ponto flutuante decimal de 128 bits. (1.0×10-28 a 7.9×1028), 28 dígitos decimais de precisão.
        bool 	    Pode ter os valores true e false. Não é compatível com inteiro.
        char 	    Um único caractere Unicode de 16 bits. Não é compatível com inteiro.


        . float, double e decimal são tipos para uso com casas decimais. O decimal mais usado para valores monetários com calculos financeiro.

            double salario = 2.500; 

            float salario = 2.500f;     // Float é necessário colocar a letra "f" quando for declarar "hardcode"

            decimal salario = 2.500m    // Idem para decimal, porém a letra é o "m"

        . var

            . Substitui o nome de um tipo
            . Será do tipo do primeiro valor atribuido
            . Rcomendado o uso ( DEixe pra usar va quando j´dominar os tipos)

            . A grande vantagem em usar o var é na economia de código, por exemplo:

                IEnumerable<Cliente> clientes = new IEnumerable<Cliente>();

                ou

                var clientes = new IEnumerable<Cliente>();

        . Object é usado da mesma forma do var

            var idade = 10;

            object idade = 10;

            . O tipo object é mais versatil do que o var:

                object idade;       // Não dá erro como o var

        . Tipos definidos pelo usuário:

            enum

                Permite declarar uma seqüência de identificadores associados, mas incompatíveis com inteiros e com outras enumerações. 
                Praticamente idêntico às enumerações do Delphi. Exemplo:

                enum Days { Sun, // 0
                            Mon, // 1
                            Tue, 
                            Wed, 
                            Thu, 
                            Fri, 
                            Sat}; // 6


                enum Categories
                {
                    Electronics = 1,  
                    Food = 5, 
                    Automotive = 6, 
                    Arts = 10, 
                    BeautyCare = 11, 
                    Fashion = 15,
                    WomanFashion = 15
                }

                enum WeekDays
                {
                    Monday, 
                    Tuesday,
                    Wednesday,
                    Thursday, 
                    Friday, 
                    Saturday,
                    Sunday 
                }

                Console.WriteLine(WeekDays.Friday); //output: Friday 
                int day = (int) WeekDays.Friday; // enum to int conversion
                Console.WriteLine(day); //output: 4 
                        
                var wd = (WeekDays) 5; // int to enum conversion
                Console.WriteLine(wd);//output: Saturday 

            struct

                Permite declarar tipos que contém vários valores, identificados por um nome. Semelhante ao record do Delphi. Exemplo:

                    public struct Point { 
                        public int x, y; 
                        
                        public Point(int p1, int p2) { 
                            x = p1; 
                            y = p2;    
                        } 
                    }

                As structs possuem algumas características em comum com as classes:

                    . Podem ter métodos.
                    . Podem ter construtores. Entretanto, existem diferenças em relação às classes:
                    . Elas são tipos por valor enquanto as classes são tipos por referência.
                    . Não podemos declarar um construtor que não aceite argumentos.
                    . Podemos atribuir à variável this, correspondente ao self no Delphi;
                    . Não suportam herança; elas são implicitamente sealed.

                As structs fornecem uma alternativa mais “leve e barata” às classes, onde o custo do uso das classes 
                (alocação dinâmica de memória, métodos virtuais e uso de ponteiros) seria muito caro. Por exemplo, um ponto (coordenada X, Y).

    Tipos por Referência, ou complexos:

        . São alocados em um heap e sujeitos à “coleta de lixo” (“garbage collection”) quando não forem mais usados.
        . Devem ser inicializados com o operador new.
        . A variável armazena uma “referência”, uma espécie de ponteiro; o conteúdo em si fica no heap.
        . A atribuição de uma variável a outra copia a referência; podemos ter muitas variáveis referindo-se ao mesmo valor.
        . Normalmente usados com tipos de grande tamanho (mais que 16 bytes), onde o custo da alocação dinâmica é relativamente 
            pequeno frente a sua flexibilidade.
        . Podem conter o valor null, embora se usarmos uma variável com o valor null a exception NullReferenceException será gerada.


        Arrays

            Um array é sempre criado dinamicamente em tempo de execução. Podemos ter arrays de várias dimensões e arrays de arrays. 
            Veja um exemplo de criação e inicialização de um array de inteiros de uma dimensão:

                int[] myIntArray = new int[5] { 1, 2, 3, 4, 5 };

        Class

            Tipo definido pelo usuário e correspondem a uma class no Delphi As classes são sempre derivadas de object e podem conter campos, 
            métodos e propriedades. Uma classe pode derivar de uma única outra classe, e também de várias interfaces. Veja um exemplo:

                public class Tempo {
                    protected int H; protected int M; protected int S;

                    public Tempo() {
                        Ajusta(0, 0, 0);
                    }

                    public Tempo(int _H, int _M, int _S) {
                        Ajusta(_H, _M, _S);
                    }

                    public void Ajusta(int _H, int _M, int _S) {
                        H = _H; M = _M; S = _S;
                        Normaliza();
                    }

                    public string ParaString() {
                        return string.Format("{0}:{1}:{2}", new object[] {H, M, S});
                    }
                    
                    void Normaliza() {
                        M = M + S / 60;
                        S = S % 60;
                        H = H + M / 60;
                        M = M % 60;
                    }

                    public double Hora {
                        get {
                            return H + (M / 60.0) + (S / 3600.0);
                        }

                        set {
                            M = 0; S = 0;
                            H = (int) value;
                            double Sobra = value - H;
                            S = (int)(Sobra * 3600);
                            Normaliza();
                        }
                    }

                    override public string ToString() {
                        return ParaString();
                    }
                }

        Interface

            Tipo definido pelo usuário. Uma interface é uma espécie de classe, mas contém apenas os “protótipos” dos métodos, 
            sem a sua implementação. Corresponde no Delphi a uma interface. Uma classe, além de ser derivada de outra, pode 
            implementar várias interfaces. Veja um exemplo:

	
                // Declara a interface
                interface IControl
                {
                    void Paint();
                }
    
                // Cria um interface derivada
                interface ITextBox: IControl
                {
                    void SetText(string text);
                }
        
                // A classe implementa a interface
                class TextBox: ITextBox
                {
                    void IControl.Paint() {...}
                    void ITextBox.SetText(string text) {...}
                }

        Delegate

            Tipo definido pelo usuário. É um “ponteiro de função orientado a objeto. Podemos atribuir uma lista de métodos a um delegate e 
            chamá-los ao invocar o delegate. O delegate corresponde mais ou menos a um “procedure of object” do Delphi, mas pode também apontar 
            para métodos static (métodos class no Delphi) e para uma lista de métodos.Veja um exemplo:


                // Declara um delegate. É um método que não aceita argumentos e retorna inteiros
                delegate int MyDelegate();

                // Declara uma classe. Note que os métodos tem a mesma “assinatura” do delegate acima:
                // retornam um inteiro e não aceitam argumentos
                public class MyClass
                {
                    public int InstanceMethod ()
                    {
                        Console.WriteLine("A message from the instance method.");
            
                        return 0;
                    }

                    static public int StaticMethod ()
                    {
                        Console.WriteLine("A message from the static method.");
                        return 0;
                    }
                }

                public class MainClass
                {
                    static public void Main ()
                    {
                        MyClass p = new MyClass();
                        
                        // Mapeia o delegate ao método da classe criada acima
                        MyDelegate d = new MyDelegate(p.InstanceMethod);
                        
                        // Chama o método via delegate
                        d();
                        
                        // Mapeia outro método (agora é static)
                        d = new MyDelegate(MyClass.StaticMethod);
                
                        // Chama o método via delegate
                        d();
                    }
                }

        Tipo string

            As strings são tecnicamente um tipo por referência, mas possuem algumas características especiais:

                . Não precisam ser inicializadas com o operador new.
                . A atribuição de uma variável a outra funciona como se copiasse o conteúdo, criando efetivamente outra cópia da variável.
                . Uma string contendo o valor null é uma string vazia; não é um erro usá-la.
                . Você não pode criar uma classe derivada de string.

            As strings contêm caracteres Unicode e podem ter até 1G de comprimento. Veja um exemplo:

                // Declara e inicializa uma string
                string Name = "Mary";

                // Copia para outra string. Se alterarmos uma delas, a outra manterá o seu valor
                string NewName = Name;

                // Atribui à string antiga
                Name = "John";

                // Exibe "John - Mary"
                System.Console.WriteLine(Name + " - " + NewName);

    Nullabel Types

        . Significa vazio, nada
        . Diferente de zero ou uma string vazia
        . Todo tipo primitivo, ou complexo, pode receber o valor null
        . O tipo deve ser marcado como Nullable Type

        . Podemos atribuir null a um objeto, desde que o mesmo seja marcado como nullable, usando interrogação na frente do tipo.
        . Se uma chamada a um valor nulo for feita um erro sera apresentado.

            int? idade = null;

        . Trabalhando com strings nulas:

            static void Salvar( string texto ){

                if ( string.IsNullOrEmpty( texto ) ){
                    throw new Exception( "Texto não pode ser nulo" );
                }
            }

        

System
------

    . No .NET tudo começa de um tipo base chamado "system"
    . Ele é a base de todos os objetos no .NET
    . Todos os tipos é devirados do "System"

Valores Padrões
---------------

    int, float, decimal => 0
    bool => false
    char => '\0'
    String => ""

Conversão Implícita
-------------------

    . Conversões implícitas ocorre quando somente fazemos a passagem de dados e com tipos compatíveis:

        float valor = 25.8f;
        int outro = 25;

        valor = outro;      // Conversão implicita, é permitido converter inteiro para float

        outro = valor;      // Erro de conversão, float não pode ser convertido para int;

    . Retorno no passo "Tipagem de Dados" e observe o valor máximo de cada tipo. O tamanho de cada tipo também limitará 
        a conversão implícita.

    . Conversões implícita válidas:

        De	        Para
        --          ----
        sbyte	    short , int, long, float, double, ou decimal
        byte	    short , ushort, int, uint, long, ulong, float, double, ou decimal
        short	    int , long, float, double, ou decimal
        ushort	    int , uint, long, ulong, float, double, ou decimal
        int	        long , float, double, ou decimal
        uint	    long , ulong, float, double, ou decimal
        long	    float , double, ou decimal


Conversão Explícita
-------------------

    . Para realizar este tipo, você deve declarar à frente da variável da direita e entre parênteses o tipo de dado que deseja.

        Exemplo 1:

            using System;

            namespace ConversionExplicit
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        sbyte a = 10;
                        short b = (short)a;
                        int c = (int)b;
                        long d = (long)c;
                        float e = (long)d;
                        double f = (float)e;
                        Console.Write(f);
                        Console.Read();
                    }
                }
            }

        Exemplo 2

        namespace ConversionExplicitRefenceType
        {
            class Humano
            {
                //Propriedades e Métodos
            }
            class Feminino : Humano
            {
                //Propriedades e Métodos
            }
            class Masculino : Humano
            {
                //Propriedades e Métodos
            }
            class Program
            {
                static void Main(string[] args)
                {
                    Feminino Mulher = new Feminino();
                    Humano SerHumano = Mulher;
                    Feminino OutraMulher = (Feminino)SerHumano;

                    // Feminino OutraMulher = SerHumano as Feminino;        // Outra forma "as"
                }
            }
        }


Parse
-----

    int.Parse() - lança uma exceção se a conversão falhar;

    As exceções possíveis usando ambos os métodos são:

        Exceção 	            Condição
        -------                 --------
        ArgumentNullException 	s é  null.
        FormatException 	    s não esta em um formato válido
        OverflowException 	    s esta fora da faixa dos números inteiros

        Conversão para int usando Int.Parse() 	            resultado
        -------------------------------------               ---------
        string valor1 = "100"                               O valor é convertido sem erros
        int valor2 = int.Parse(valor1); 	                valor2 = 100

        string valor1 =null;                                
        int valor2 = int.Parse(valor1); 	                Lança a exceção ArgumentNullException
        
        string valor1 = "100.99";               
        int valor2 = int.Parse(valor1); 	                Lança a exceção FormatException

        string valor1 = "999999999999999999999999999999";
        int valor2 = int.Parse(valor1); 	                Lança a exceção OverflowException


TryParse
--------

    int.TryParse() - Se a conversão falhar retorna zero;


    Conversão para int usando Int.TryParse() 	            resultado
    ----------------------------------------                ---------
    string valor1 = "100"
    int resultado;                                          O valor é convertido sem erros.
    bool sucesso = int.TryParse(valor1, out resultado); 	resultado = 1000  e sucesso = true

    string valor1 = null;
    int resultado;                                          Conversão falhou
    bool sucesso = int.TryParse(valor1, out resultado); 	resultado = 0  e sucesso = false

    string valor1 = "100.99"
    int resultado;                                          Conversão falhou
    bool sucesso = int.Parse(valor1, out resultado); 	    resultado = 0  e sucesso = false

    string valor1 = "999999999999999999999"
    int resultado;                                          Conversão falhou
    bool sucesso = int.Parse(valor1, out resultado); 	    resultado = 0  e sucesso = false

Convert
-------

    . Convert.ToInt32 é utilizado para converter outros tipos de objeto (object, bool, string, etc) em um int, 
        internamente ele utiliza int.Parse, porem adicionando a feature de retornar zero se o valor convertido 
        for null, no mais é igual ao int.Parse.

        int x = Convert.ToInt32("123");// 123
        int x = Convert.ToInt32("");//System.FormatException
        int x = Convert.ToInt32("123@");//System.FormatException
        int x = Convert.ToInt32(null);// 0

    . Sugestão: 
        
        Se você tem uma string e espera que sempre lhe retorne um inteiro (por exemplo, o retorno de uma chamada a um web service) 
        você deve utilizar int.Parse. 
        
        Se você esta fazendo leitura de dados inseridos pelo usuário, você deve usar int.TryParse que possui um melhor controle na 
        situação do usuário inserir entradas inválidas.

        Você deve utilizar Convert.ToInt32 nos mesmos casos citados acima para int.Parse porem quando o argumento não for do tipo string.


Operadores de comparação
------------------------

    ==      igual
    !=      diferente
    >       Maior que
    <       Menor que
    >=
    <=

    Exemplo:

        int x = 25;

        x == 0;     // False
        x != 0;     // True
        x > 0;      // True
        x < 0;      // False


Operadores Lógicos
------------------

    &&      And
    ||      Or
    !       Not

    Exemplo:

        int x= 12;

        bool entre = ( x > 25 ) && ( x < 40 );      // False
        bool ou = ( x < 25 ) || ( x < 40 );         // True
        bool negacao = !( x < 25 );                 // False



Operadores Condicionais - IF
---------------------------    

    Exemplo 1:

        if(condition)
        {
            // code block to be executed when if condition evaluates to true
        }

    Exemplo 2:

        if (condicao)
            Console.log("Fim");

    Exemplo 2:

        if(condition1)
        {
            // code block to be executed when if condition1 evaluates to true
        }
        else if(condition2)
        {
            // code block to be executed when 
            //      condition1 evaluates to flase
            //      condition2 evaluates to true
        }
        else if(condition3)
        {
            // code block to be executed when 
            //      condition1 evaluates to flase
            //      condition2 evaluates to false
            //      condition3 evaluates to true
        }

    . Podemos substituir IFs por Operadores Ternários:

        int x = 10;
        int y = 20;
        int max = (x > y) ? x : y;



Switch
------

    int x = 10;

    switch (x)
    { 
        case 5:
            Console.WriteLine("Value of x is 5");
            break;
        case 10:
            Console.WriteLine("Value of x is 10");
            break;
        case 15:
            Console.WriteLine("Value of x is 15");
            break;
        default:
            Console.WriteLine("Unknown value");
            break;
    }

    . The switch cases without break, return, or goto statement or with the same constant values would give a compile-time error.

For
---

    Exemplo 1

        for(int i = 0; i < 10; i++)
        {
            Console.WriteLine("Value of i: {0}", i);
        }

    Exemplo 2

        for(int i = 0; i < 10; i++)
            Console.WriteLine("Value of i: {0}", i);

    Exemplo 3

        int i = 0;

        for(;;)
        {
            if (i < 10)
            {
                Console.WriteLine("Value of i: {0}", i);
                i++;
            }
            else
                break;
        }

    Exemplo 4

        for(int i = 10; i > 0; i--)
        {
            Console.WriteLine("Value of i: {0}", i);
        }


While
-----

    Exemplo 1

        int i = 0; // initialization

        while (i < 10) // condition
        {
            Console.WriteLine("i = {0}", i);

            i++; // increment
        }

    Exemplo 2

        int i = 0;

        while (true)
        {
            Console.WriteLine("i = {0}", i);

            i++;

            if (i > 10)
                break;
        }


C# Class
--------

    . No vSCode algumas atalhos (Snippet) estão disponíveis para facilitar na implementação do código:

        prop + [Ctrl + Space]

            public int MyProperty { get; set; }


        propfull + [Ctrl + Space]

            private int myVar;
            public int MyProperty
            {
                get { return myVar; }
                set { myVar = value; }
            }

        ctor  + [Ctrl + Space]  - Implementa o construtor

            public Calculadora(Parameters)
            {
                
            }

        for  + [Ctrl + Space]  -  monta um laço for padrão;

        if + [Ctrl + Space]  -  monta uma estrutura if padrão;

        cw + [Ctrl + Space]  -  chama um Console.WriteLine();

        do + [Ctrl + Space]  -  cria um bloco do/while;

        equals + [Ctrl + Space]  -  sobrescreve o método equals de Object;

        foreach + [Ctrl + Space]  -  monta um laço foreach padrão;

        try + [Ctrl + Space]  -  cria um bloco try/catch padrão;

        while + [Ctrl + Space]  -  cria um bloco while padrão;



    . Template de Exemplo

        using System;                       // 1. Importação das bibliotecas. Equivalente aos imports do java

        namespace SysUtil.Tutorial          // 2. Área de configuração para divisão lógica das classes, equivalente as packages do java
        {
            // 3. Modificador de acesso
            public class MyClass    // 4. Nome da classe
            {
                public string  myField = string.Empty;  // 5. Propriedade de classe

                public MyClass()                        // 6. Construtor
                {
                }

                public void MyMethod(int parameter1, string parameter2)     // 7. Método/Função
                {
                    Console.WriteLine("First Parameter {0}, second parameter {1}", 
                                                                parameter1, parameter2);
                }

                public int MyAutoImplementedProperty { get; set; }      // 8. Auto-implemented property

                private int myPropertyVar;                              // 9. Propriedade
                
                public int MyProperty                                   // 9. Propriedade
                {
                    get { return myPropertyVar; }
                    set { myPropertyVar = value; }
                } 
            }
        }

    . Propriedades podem ser declaradas de duas formas:

        . Simplificada - Quando não existe necessidade de nenhuma lógica/regra ( vide item 8 )

        . Completa - Quando a necessidade de alguma lógica extra, por exemplo:

            private int _myPropertyVar;

            public int MyProperty
            {
                get {
                    return _myPropertyVar / 2;
                }

                set {
                    if (value > 100)
                        _myPropertyVar = 100;
                    else
                        _myPropertyVar = value; ;
                }
            }


    . Podemos iniciar uma classe de duas formas:

        Calculadora calc = new Calculadora(10, 10);

        int m = calc.soma();

        ou

        Calculadora calc = new Calculadora{a = 10, b = 10};

        int m = calc.soma();

    . Podemos deixar os parâmetros dos métodos opcionais. Basta na assinatura do método dar um valor para o parâmetro:

        public int soma( int a, int b, bool formata = false );

        . Dessa forma se houver o uso deste método somente com dois parâmetros não dará erro.

    . Exemplos

        Exemplo 1 - Usando o tipo do objeto a classe

            // IMPORTANTE: Para se criar os objetos como abaixo, as classes é obrigatório ter um construtor sem parâmetros. Pois na parte "new Student(){...}" o construtor que está
            //              sendo chamado é o construtor sem parâmetros. Podemos criar construtores com parâmetros, mas é obrigatório sem parâmetros.
            
            Student student = new Student(){ Id = 1, Name = "MARCO ANTONIO", LastName = "SILVA", Address = new Address(){ Id = 1, StreetName = "RUA CARIOBA 360", City = "SÃO PAULO", State = "SP", ZipCode = "02423-100" }  };

            System.Console.WriteLine( student.Id );
            System.Console.WriteLine( student.Name );
            System.Console.WriteLine( student.Address.ToString());

        Exemplo 2 - Usando o tipo do objeto de forma anônima. Nesse caso não se trata de classe e não fazemos mensão nenhuma a qq classe, usando o tipo "var"

            var student = new { Id = 1, Name = "MARCO ANTONIO", LastName = "SILVA", address = new { Id = 1, StreetName = "RUA CARIOBA 360", City = "SÃO PAULO", State = "SP", ZipCode = "02423-100" }  };

            System.Console.WriteLine( student.Id );
            System.Console.WriteLine( student.Name );
            System.Console.WriteLine( student.Address.ToString());


String
------

    . Guid - O struct Guid representa um identificador único global: um valor de 16 bytes que, se gerado randomicamente, irá gerar um identificador (quase) único

            var id = Guid.NewGuid();

            var idString = id.ToString();

            System.Console.WriteLine( id );     // 2c04a03a-f15d-44b0-a85e-f90fce3e2141

    . Interpolação:

            var price = 10.2;

            string texto = string.Format("O preço do produto é {0}", price );

            System.Console.WriteLine( texto );  // O preço do produto é 10,2

    
            ou

            var price = 10.2;

            string texto = $"O preço do produto é {price}";

            System.Console.WriteLine( texto );  // O preço do produto é 10,2


    . Comparação de strings

        string texto = "Testando";

        System.Console.WriteLine( texto.CompareTo("Testando") );        // Exibirá "0"
        System.Console.WriteLine( texto.CompareTo("testando") );        // Exibirá "1"
        
                
        System.Console.WriteLine( texto.Contains("Test" ) );        // Exibirá True
        System.Console.WriteLine( texto.Contains("test" ) );        // Exibirá False
        System.Console.WriteLine( texto.Contains("testando", StringComparison.OrdinalIgnoreCase ) );        // Exibirá True

        . CompareTo retorna um inteiro 0 - ok e 1 - Não Ok

        . StringComparison.OrdinalIgnoreCase - Ignora o case sensitive.

    . StartsWith e EntsWith

        string texto = "Testando";

        System.Console.WriteLine( texto.StartsWith("Test") );        // Exibirá true
        System.Console.WriteLine( texto.EndsWith("test") );        // Exibirá false

    . Equals

        string texto = "Testando";

        System.Console.WriteLine( texto.Equals("Testando") );        // Exibirá true
        System.Console.WriteLine( texto.Equals("testando") );        // Exibirá false
        System.Console.WriteLine( texto.Equals("testando", StringComparison.OrdinalIgnoreCase) );        // Exibirá true

        . Equals é utilizado em outros tipo de objetos.

    . IndexOf   - Retorna a posição da string dentro de outra string    texto.IndexOf("esta") // exibirá 1

    . ToUpper e ToLower para deixar em caixa alta e baixa

    . Replace para trocar um texto por outro

    . Split para quebrar em um array

    . Substring( inicio, tamanho )


DateTime
--------

    //assigns default value 01/01/0001 00:00:00
    DateTime dt1 = new DateTime(); 

    int ano = dt3.Year;
    int mes = dt3.Month;
    int day = dt3.Day;
    int hr = dt3.Hour;
    int minuto = dt3.Minute;
    int diaSemana = (int) dt3.DayOfWeek;

    DateTime hoje = DateTime.Now.Date;      // dd/mm/yyyy 00:00:00  - Somente a data do dia, sem hr, min, segundos




    //  I M P O R T A N T E   assigns year, month, day
    DateTime dt2 = new DateTime(2015, 12, 31); 

    //  I M P O R T A N T E     year, month, day, hour, min, seconds
    DateTime dt3 = new DateTime(2015, 12, 31, 5, 10, 20);

    DateTime currentDateTime = DateTime.Now;  //returns current date and time
    DateTime todaysDate = DateTime.Today; // returns today's date


    . Subtração de datas

        Console.WriteLine(dt2 - dt1); //377.05:10:20
        Console.WriteLine( (dt2 - dt1).Days ); // 377
        Console.WriteLine( (dt2 - dt1).TotalDays ); // 377
        Console.WriteLine("Horas: " + (date_2 - date_1).TotalHours );     // Horas: 10152


        DateTime dt1 = new DateTime(2015, 12, 31); 
        DateTime dt2 = new DateTime(2016, 2, 2);

        TimeSpan result = dt2.Subtract(dt1);//33.00:00:00

    . Adição de Datas

        DateTime dataAtual = DateTime.Now;

        System.Console.WriteLine( dataAtual.AddDays(7) );
        System.Console.WriteLine( dataAtual.AddMonths(7) );
        System.Console.WriteLine( dataAtual.AddYears(7) );

    . Operadores 

        DateTime dt1 = new DateTime(2015, 12, 20);  
        DateTime dt2 = new DateTime(2016, 12, 31, 5, 10, 20); 

        TimeSpan time = new TimeSpan(10, 5, 25, 50);

        Console.WriteLine(dt2 + time); // 1/10/2017 10:36:10 AM


        Console.WriteLine(dt1 == dt2); //False
        Console.WriteLine(dt1 != dt2); //True
        Console.WriteLine(dt1 > dt2); //False
        Console.WriteLine(dt1 < dt2); //True
        Console.WriteLine(dt1 >= dt2); //False
        Console.WriteLine(dt1 <= dt2);//True

    . Convertendo String em DateTime

        var str = "5/12/2020";
        DateTime dataResult;

        var isValidDate = DateTime.TryParse(str, out dataResult);

        if (isValidDate)
            Console.WriteLine(dataResult);
        else
            Console.WriteLine($"{str} is not a valid date string");

    . Formatação

        y (year) 
        M (month)
        d (day) 
        h (hour 12)
        H (hour 24)
        m (minute)
        s (second)
        f (second fraction)
        F (second fraction, trailing zeroes are trimmed)t (P.M or A.M) and z (time zone).

        Exemplo:

            DateTime dataAtual = DateTime.Now;

            System.Console.WriteLine( String.Format("{0:dd/MM/yyyy}", dataAtual ) );

    . Datas Nulas

        DateTime? dataPagamento = null;     // Para termos uma data nula é necessário declará-la como "DateTime?"
                                            // obrigatório o uso da interrogação.

    . Comparação de datas

        DateTime hoje = DateTime.Now.Date;

        if ( hoje == DateTime.Now.Date ){
            Console.WriteLine( "São iguais");
        }  

Moeda
-----

    decimal valor = 10536.25m;

    Console.WriteLine(valor.ToString(CultureInfo.CreateSpecificCulture("pt-BR")));          // 10536,25

    Console.WriteLine(valor.ToString("G",   // Formatador númerico                                          
                                        CultureInfo.CreateSpecificCulture("pt-BR")));       // 10536,25

    Console.WriteLine(valor.ToString("C", // Formatador de Moeda/Currency
                                        CultureInfo.CreateSpecificCulture("pt-BR")));       // R$ 10.536,25

    Console.WriteLine(valor.ToString("F",  // Fração, com uma casa decimal a mais
                                        CultureInfo.CreateSpecificCulture("pt-BR")));       // 10536,250

    Console.WriteLine(valor.ToString("N", // Númerico
                                        CultureInfo.CreateSpecificCulture("pt-BR")));       // 10.536,25

Arrays
------

    . Declaração

        int[] evenNums;

        string[] cities;

        int[] evenNums = int[5]{1,2,3,4,5};

        string[] cities = strint[5]{"Ana", "Jose", "Antonio", "Tobias", "Carlos"};

        . Todas as formas acima podem utilizar var no lugar do tipo "var evenNums..."

        int[] evenNums = {1,2,3,4,5};

        string[] cities = {"Ana", "Jose", "Antonio", "Tobias", "Carlos"};

    . Declarações inválidas

        //must specify the size 
        int[] evenNums = new int[]; 

        //number of elements must be equal to the specified size 
        int[] evenNums = new int[5] { 2, 4 };

        //cannot use var with array initializer
        var evenNums = { 2, 4, 6, 8, 10}; 


    . Declaração com inicialização tardia.

        int[] evenNums;

        evenNums = new int[5];
        // or
        evenNums = new int[]{ 2, 4, 6, 8, 10 };

    . Acesso aos elementos utilizando o índice:

        int[] evenNums = new int[5];
        evenNums[0] = 2;
        evenNums[1] = 4;
        //evenNums[6] = 12;  //Throws run-time exception IndexOutOfRange

        Console.WriteLine(evenNums[0]);  //prints 2
        Console.WriteLine(evenNums[1]);  //prints 4

    . Acessando os elementos através de um loop

        int[] evenNums = { 2, 4, 6, 8, 10 };

        for(int i = 0; i < evenNums.Length; i++)
            Console.WriteLine(evenNums[i]);  

        for(int i = 0; i < evenNums.Length; i++)
            evenNums[i] = evenNums[i] + 10;  // update the value of each element by 10

    . Acessando os elementos através de um foreach

        int[] evenNums = { 2, 4, 6, 8, 10}; 
        string[] cities = { "Mumbai", "London", "New York" }; 

        foreach(var item in evenNums)
            Console.WriteLine(item);   

        foreach(var city in cities)
            Console.WriteLine(city);  

    . Métodos do array

        int[] nums = new int[5]{ 10, 15, 16, 8, 6 };

        Array.Sort(nums);                               // sorts array 
        Array.Reverse(nums);                            // sorts array in descending order
        Array.ForEach(nums, n => Console.WriteLine(n)); // iterates array
        Array.BinarySearch(nums, 5);                    // binary search 

    . Passando array como argumento

        public static void Main(){
            int[] nums = { 1, 2, 3, 4, 5 };

            UpdateArray(nums); 

            foreach(var item in nums)
                Console.WriteLine(item);   
        }
                            
        public static void UpdateArray(int[] arr)
        {
            for(int i = 0; i < arr.Length; i++)
                arr[i] = arr[i] + 10;   
        }

    . Exemplo de Sort de Array

        private static void sortedByArray()
        {
            int[] numeros = {2,20,6,15,11,1};
            int[] novosNumero = new int[6];
            int idNovosNumero;

            foreach( int numero in numeros ){
                for ( idNovosNumero = novosNumero.Length - 1; idNovosNumero > 0 ; idNovosNumero-- ){
                    if (novosNumero[ idNovosNumero ] < numero)
                        break;
                }

                for( int i = 0; i < idNovosNumero; i++){
                    novosNumero[i] = novosNumero[ i + 1];
                }

                novosNumero[ idNovosNumero ] = numero;
                
            }

            foreach( int numero in novosNumero ){
                System.Console.WriteLine( numero );
            }



        }


Exception
---------

    . Lista de exceções:

        Exception Class 	            Description
        ---------------                 -----------
        ArgumentException 	            Raised when a non-null argument that is passed to a method is invalid.
        ArgumentNullException 	        Raised when null argument is passed to a method.
        ArgumentOutOfRangeException 	Raised when the value of an argument is outside the range of valid values.
        DivideByZeroException 	        Raised when an integer value is divide by zero.
        FileNotFoundException 	        Raised when a physical file does not exist at the specified location.
        FormatException 	            Raised when a value is not in an appropriate format to be converted from a string by a conversion method such as Parse.
        IndexOutOfRangeException 	    Raised when an array index is outside the lower or upper bounds of an array or collection.
        InvalidOperationException 	    Raised when a method call is invalid in an object's current state.
        KeyNotFoundException 	        Raised when the specified key for accessing a member in a collection is not exists.
        NotSupportedException 	        Raised when a method or operation is not supported.
        NullReferenceException 	        Raised when program access members of null object.
        OverflowException 	            Raised when an arithmetic, casting, or conversion operation results in an overflow.
        OutOfMemoryException 	        Raised when a program does not get enough memory to execute the code.
        StackOverflowException 	        Raised when a stack in memory overflows.
        TimeoutException 	            The time interval allotted to an operation has expired.

    . Sintaxe

        try
        {
            Console.WriteLine("Enter a number: ");

            var num = int.parse(Console.ReadLine());

            Console.WriteLine($"Squre of {num} is {num * num}");
        }
        catch
        {
            Console.Write("Error occurred.");
        }
        finally
        {
            Console.Write("Re-try with a different number.");
        }        

        ou 

        try
        {
            Console.WriteLine("Enter a number: ");

            var num = int.parse(Console.ReadLine());

            Console.WriteLine($"Squre of {num} is {num * num}");
        }
        catch(Exception ex)
        {
            Console.Write("Error info:" + ex.Message);
        }
        finally
        {
            Console.Write("Re-try with a different number.");
        }


        . Levantando uma exceção:

            static void Salvar( string texto ){

                if ( string.IsNullOrEmpty( texto ) ){
//                    throw new Exception( "Texto não pode ser nulo" );
                    throw new ArgumentNullException("Texto não pode ser nulo.");        
                }
            }

    . Custom Exception

        class Student
        {
            public int StudentID { get; set; }
            public string StudentName { get; set; }
        }

        [Serializable]
        class InvalidStudentNameException : Exception
        {
            public InvalidStudentNameException() {  }

            public InvalidStudentNameException(string name)
                : base(String.Format("Invalid Student Name: {0}", name))
            {

            }
        }

        static void Main(string[] args)
        {
            Student newStudent = null;
            
            try
            {               
                newStudent = new Student();
                newStudent.StudentName = "James007";
                
                ValidateStudent(newStudent);
            }
            catch(InvalidStudentNameException ex)
            {
                Console.WriteLine(ex.Message );
            }
            

            Console.ReadKey();
        }

        private static void ValidateStudent(Student std)
        {
            Regex regex = new Regex("^[a-zA-Z]+$");

            if (!regex.IsMatch(std.StudentName))
                throw new InvalidStudentNameException(std.StudentName);
                
        }


Classes Genérica
----------------

    class DataStore<T>
    {
        public T Data { get; set; }
    }


    class KeyValuePair<TKey, TValue>
    {
        public TKey Key { get; set; }
        public TValue Value { get; set; }
    }


    . Instanciando uma classe genérica

        DataStore<string> store = new DataStore<string>();

    . Utilização de classes genérica

        DataStore<string> strStore = new DataStore<string>();
        strStore.Data = "Hello World!";
        //strStore.Data = 123; // compile-time error

        DataStore<int> intStore = new DataStore<int>();
        intStore.Data = 100;
        //intStore.Data = "Hello World!"; // compile-time error

        KeyValuePair<int, string> kvp1 = new KeyValuePair<int, string>();
        kvp1.Key = 100;
        kvp1.Value = "Hundred";

        KeyValuePair<string, string> kvp2 = new KeyValuePair<string, string>();
        kvp2.Key = "IT";
        kvp2.Value = "Information Technology";

    . Campos/Propriedades de classes genéricas

        class DataStore<T>
        {
            public T data;
        }

        ou

        class DataStore<T>
        {
            public T[] data = new T[10];
        }

    . Métodos genéricos

        class DataStore<T>
        {
            private T[] _data = new T[10];
            
            public void AddOrUpdate(int index, T item)
            {
                if(index >= 0 && index < 10)
                    _data[index] = item;
            }

            public T GetData(int index)
            {
                if(index >= 0 && index < 10)
                    return _data[index];
                else 
                    return default(T);
            }
        }

    
        DataStore<string> cities = new DataStore<string>();
        cities.AddOrUpdate(0, "Mumbai");
        cities.AddOrUpdate(1, "Chicago");
        cities.AddOrUpdate(2, "London");

        DataStore<int> empIds = new DataStore<int>();
        empIds.AddOrUpdate(0, 50);
        empIds.AddOrUpdate(1, 65);
        empIds.AddOrUpdate(2, 89);

    . Métodos genéricos sobrecarregados

        public void AddOrUpdate(int index, T data) { }
        public void AddOrUpdate(T data1, T data2) { }
        public void AddOrUpdate<U>(T data1, U data2) { }
        public void AddOrUpdate(T data) { }

    . Métodos genéricos em classes não genéricas

        class Printer
        {
            public void Print<T>(T data)
            {
                Console.WriteLine(data);
            }
        }

        Printer printer = new Printer();
        printer.Print<int>(100);
        printer.Print(200); // type infer from the specified value
        printer.Print<string>("Hello");
        printer.Print("World!"); // type infer from the specified value

Coleções
--------

        . ArrayList

            . ArrayList não aceita Generic e tem menos recursos que o List

            . Criando um arraylist

                using System.Collections;

                ArrayList arlist = new ArrayList(); 
                // or 
                var arlist = new ArrayList();         

            . Adicionando elementos

                // adding elements using ArrayList.Add() method
                var arlist1 = new ArrayList();
                arlist1.Add(1);
                arlist1.Add("Bill");
                arlist1.Add(" ");
                arlist1.Add(true);
                arlist1.Add(4.5);
                arlist1.Add(null);

                // adding elements using object initializer syntax
                var arlist2 = new ArrayList()
                                {
                                    2, "Steve", " ", true, 4.5, null
                                };
            
            . Acessando um elemento de um ArrayList



                var arlist = new ArrayList()
                                {
                                    1,
                                    "Bill",
                                    300,
                                    4.5f
                                };

                //Access individual item using indexer
                int firstElement = (int) arlist[0]; //returns 1
                string secondElement = (string) arlist[1]; //returns "Bill"
                //int secondElement = (int) arlist[1]; //Error: cannot cover string to int

                //using var keyword without explicit casting
                var firstElement = arlist[0]; //returns 1
                var secondElement = arlist[1]; //returns "Bill"
                //var fifthElement = arlist[5]; //Error: Index out of range

                //update elements
                arlist[0] = "Steve"; 
                arlist[1] = 100;
                //arlist[5] = 500; //Error: Index out of range

            . Iterando um ArrayList

                ArrayList arlist = new ArrayList()
                                        {
                                            1,
                                            "Bill",
                                            300,
                                            4.5F
                                        };

                foreach (var item in arlist)
                    Console.Write(item + ", "); //output: 1, Bill, 300, 4.5, 
                            
                for(int i = 0 ; i < arlist.Count; i++)
                    Console.Write(arlist[i] + ", "); //output: 1, Bill, 300, 4.5, 


                pessoas.ForEach( item => { 
                    System.Console.WriteLine( item );
                } );

            . Checando a existência de um item

                ArrayList arList = new ArrayList()
                                {
                                    1,
                                    "Bill",
                                    300,
                                    4.5f,
                                    300
                                };

                Console.WriteLine(arList.Contains(300)); // true
                Console.WriteLine(arList.Contains("Bill")); // true
                Console.WriteLine(arList.Contains(10)); // false
                Console.WriteLine(arList.Contains("Steve")); // false

            . Métodos e propriedades

                ArrayList  Properties

                Properties 	        Description
                ----------          -----------
                Capacity 	        Gets or sets the number of elements that the ArrayList can contain.
                Count 	            Gets the number of elements actually contained in the ArrayList.
                IsFixedSize 	    Gets a value indicating whether the ArrayList has a fixed size.
                IsReadOnly 	        Gets a value indicating whether the ArrayList is read-only.
                Item 	            Gets or sets the element at the specified index.

                ArrayList Methods

                Methods 	            Description
                -------                 -----------
                Add()/AddRange() 	    Add() method adds single elements at the end of ArrayList.
                AddRange()              method adds all the elements from the specified collection into ArrayList.
                Insert()/InsertRange() 	Insert() method insert a single elements at the specified index in ArrayList.
                InsertRange()           method insert all the elements of the specified collection starting from specified index in ArrayList.
                Remove()/RemoveRange() 	Remove() method removes the specified element from the ArrayList.
                RemoveRange()           method removes a range of elements from the ArrayList.
                RemoveAt() 	            Removes the element at the specified index from the ArrayList.
                Sort() 	                Sorts entire elements of the ArrayList.
                Reverse() 	            Reverses the order of the elements in the entire ArrayList.
                Contains 	            Checks whether specified element exists in the ArrayList or not. Returns true if exists otherwise false.
                Clear 	                Removes all the elements in ArrayList.
                CopyTo 	                Copies all the elements or range of elements to compitible Array.
                GetRange 	            Returns specified number of elements from specified index from ArrayList.
                IndexOf 	            Search specified element and returns zero based index if found. Returns -1 if element not found.
                ToArray 	            Returns compitible array from an ArrayList. 

        . List

            . Aceita o uso de Generic

            . Criando uma lista

                List<int> primeNumbers = new List<int>();
                primeNumbers.Add(1); // adding elements using add() method
                primeNumbers.Add(3);
                primeNumbers.Add(5);
                primeNumbers.Add(7);

                var cities = new List<string>();
                cities.Add("New York");
                cities.Add("London");
                cities.Add("Mumbai");
                cities.Add("Chicago");
                cities.Add(null);// nulls are allowed for reference type list

                //adding elements using collection-initializer syntax
                var bigCities = new List<string>()
                                    {
                                        "New York",
                                        "London",
                                        "Mumbai",
                                        "Chicago"                    
                                    };

            . Adicionando objetos num List

                var students = new List<Student>() { 
                    new Student(){ Id = 1, Name="Bill"},
                    new Student(){ Id = 2, Name="Steve"},
                    new Student(){ Id = 3, Name="Ram"},
                    new Student(){ Id = 4, Name="Abdul"}
                };

            . Acessando lista

                List<int> numbers = new List<int>() { 1, 2, 5, 7, 8, 10 };
                Console.WriteLine(numbers[0]); // prints 1
                Console.WriteLine(numbers[1]); // prints 2
                Console.WriteLine(numbers[2]); // prints 5
                Console.WriteLine(numbers[3]); // prints 7

                // using foreach LINQ method
                numbers.ForEach(num => Console.WriteLine(num + ", "));//prints 1, 2, 5, 7, 8, 10,

                // using for loop
                for(int i = 0; i < numbers.Count; i++)
                    Console.WriteLine(numbers[i]);

            . Verificando a existência de um item

                var numbers = new List<int>(){ 10, 20, 30, 40 };
                numbers.Contains(10); // returns true
                numbers.Contains(11); // returns false
                numbers.Contains(20); // returns true

            . List<T> Class Properties and Methods

                Property 	    Usage
                --------        -----
                Items 	        Gets or sets the element at the specified index
                Count 	        Returns the total number of elements exists in the List<T>

                Method 	        Usage
                ------          -----
                Add 	        Adds an element at the end of a List<T>.
                AddRange 	    Adds elements of the specified collection at the end of a List<T>.
                BinarySearch 	Search the element and returns an index of the element.
                Clear 	        Removes all the elements from a List<T>.
                Contains 	    Checks whether the specified element exists or not in a List<T>.
                Find 	        Finds the first element based on the specified predicate function.
                Foreach 	    Iterates through a List<T>.
                Insert 	        Inserts an element at the specified index in a List<T>.
                InsertRange 	Inserts elements of another collection at the specified index.
                Remove 	        Removes the first occurrence of the specified element.
                RemoveAt 	    Removes the element at the specified index.
                RemoveRange 	Removes all the elements that match the supplied predicate function.
                Sort 	        Sorts all the elements.
                TrimExcess 	    Sets the capacity to the actual number of elements.
                TrueForAll 	    Determines whether every element in the List<T> matches the conditions defined by the specified predicate. 


EBM - Expression Bodied Member
------------------------------

https://www.macoratti.net/18/01/c_expbodmem1.htm


Generics
--------

http://dotnetpattern.com/csharp-generics