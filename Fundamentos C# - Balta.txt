Pagina 569
Estudar o tópico https://docs.fluentvalidation.net/en/latest/index.html

1. Herança, polimorfismo e interfaces
2. Exceções e tratamento de erros (try, catch, finally, throw, custom exceptions)
3. Coleções genéricas (List, Dictionary, Queue, Stack, HashSet, etc.)
4. LINQ (Language Integrated Query)
5. Eventos e delegates avançados
6. Expressões lambda avançadas
7. Métodos de extensão
8. Propriedades avançadas (get/set customizados, expression-bodied members)
9. Partial classes e partial methods
10. Records (C# 9+)
11. Tuplas e deconstruction
12. Pattern matching (switch avançado, is, when, etc.)
13. Async/await e programação assíncrona
14. Manipulação de arquivos e streams
15. Reflection e atributos (attributes)
16. Nullable Reference Types (C# 8+)
17. Span<T> e Memory<T> (para alta performance)
18. Dynamic e ExpandoObject
19. Unsafe code e ponteiros (para cenários avançados)
20. Testes unitários e boas práticas de testes em C#
21. Internacionalização e localização
22. Serialização (JSON, XML, Binary)
23. Dependency Injection (conceito e uso em projetos .NET)
24. Memory management e garbage collection
25. Interoperação com código nativo (P/Invoke)
26. Generics
27. Métodos de extensão (extension methods) C#

Fundamentos C# - Balta
----------------------

Instalação AspNetCore 3.1
-------------------------

    https://balta.io/blog/dotnet-instalacao-configuracao-e-primeiros-passos#criando-seu-primeiro-app
    https://www.tutorialsteacher.com/csharp
    https://www.javatpoint.com/c-sharp-tutorial


    . Acesse o link abaixo para baixar o .NET Core 3.1

        https://dotnet.microsoft.com/download

    . Acesse o download "All .NET Core downloads" e baixe a versão 3.1

    . Acesse o link "Package manager instructions" 

    . Instalaçao para as versões do Ubuntu 20.04

        . Localize a versão do Ubuntu que está sendo utilizado, copie e execute os comandos no 
            terminal:

            wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
            sudo dpkg -i packages-microsoft-prod.deb

            sudo dpkg --purge packages-microsoft-prod && sudo dpkg -i packages-microsoft-prod.deb
            sudo apt-get update

            sudo apt-get install -y gpg
            wget -O - https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor -o microsoft.asc.gpg
            sudo mv microsoft.asc.gpg /etc/apt/trusted.gpg.d/
            wget https://packages.microsoft.com/config/ubuntu/20.04/prod.list
            sudo mv prod.list /etc/apt/sources.list.d/microsoft-prod.list
            sudo chown root:root /etc/apt/trusted.gpg.d/microsoft.asc.gpg
            sudo chown root:root /etc/apt/sources.list.d/microsoft-prod.list

            # Comando para o Ubuntu 22.04 em diante
            # wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.0g-2ubuntu4_amd64.deb
            # sudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb
            
            sudo apt-get update; \
            sudo apt-get install -y apt-transport-https && \
            sudo apt-get update && \
            sudo apt-get install -y dotnet-sdk-5.0

            sudo apt-get install -y apt-transport-https && \
            sudo apt-get update && \
            sudo apt-get install -y aspnetcore-runtime-5.0

            sudo apt-get install -y dotnet-runtime-5.0

        . Para testar a instalação execute os comandos abaixo:

            dotnet --version
            dotnet --help
            dotnet --list
            dotnet --list-runtimes
            dotnet --list-sdks
    
    . Instalação para as versões acima do Ubuntu 22.04

        wget https://dot.net/v1/dotnet-install.sh
        chmod +x dotnet-install.sh

        export DOTNET_INSTALL_DIR=$HOME/.dotnet 
        
        ./dotnet-install.sh --install-dir $HOME/.dotnet -c 3.1
        ./dotnet-install.sh --install-dir $HOME/.dotnet -c 5.0
        ./dotnet-install.sh --install-dir $HOME/.dotnet -c 6.0
        ./dotnet-install.sh --install-dir $HOME/.dotnet -c 7.0

        dotnet --version

        # Caso o comando "dotnet" não se comportar como um executável, crie o link abaixo:
        sudo ln -s /home/$USER/.dotnet/dotnet /usr/bin/dotnet

        # insira as linhas abaixo no arquivo ".bashrc"
        echo 'export PATH="$HOME/.dotnet:$HOME/.dotnet/tools:$PATH"' >> ~/.bashrc
        echo 'export DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1' >> ~/.bashrc
        echo 'export DOTNET_ROOT=$HOME/.dotnet' >> ~/.bashrc

        source ~/.bashrc

        # insira as linhas abaixo no arquivo ".zshrc"
        echo 'export PATH="$HOME/.dotnet:$HOME/.dotnet/tools:$PATH"' >> ~/.zshrc
        echo 'export DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=1' >> ~/.zshrc
        echo 'export DOTNET_ROOT=$HOME/.dotnet' >> ~/.zshrc

        source ~/.zshrc

        dotnet --version
        dotnet --list-runtimes
        dotnet --list-sdks

Instalação das extensões do VSCode
----------------------------------

        C# 
        C# Extensions
        C# XML Documentation Comments
        Docker
        vscode-icons (Opcional)
        NuGet Gallery
        VZ Dotnet File Template
        Dotnet Project References
        Auto-Using for C#
        Bracket Pair Colorization Toggler
        Error Lens
        RapidApi


    Testar
        Dotnet Solution Explorer
        Dotnet New Extension
        Net Core Extension Pack
        C# Utilities
        Nuget Package Manager
        Visual Nuget
        C# Developer Extension Package
        Auto closet tag
        C# Snippets
        vscode-solution-explorer
        Razor Snippets
        ASP.Net Helper
        


    . Atalhos:

        Ctrl + K + D ou Shit + Alt + F:             Identa todo o seu código automaticamente;
        Ctrl + K + C:                               comenta um bloco de linhas;
        Ctrl + K + U:                               descomenta um bloco de linhas;
        Alt + Left Arrow:                           durante a programação, volta um método que você estava navegando;
        Alt + Right Arrow:                          durante a programação, avança um método que você estava navegando;
        Ctrl + .:                                   implementa o método/classe inexistente que você acabou de escrever;
        Ctrl + M + O:                               esconde todas as regions da classe atual;
        Ctrl + Shift + B:                           compila todos os projetos;
        F5:                                         manda depurar um projeto;
        Ctrl + F5:                                  manda executar um projeto;
        F10:                                        durante a depuração, avança uma linha;
        F11:                                        durante a depuração, avança uma linha entrando nos detalhes da mesma;

Configurar Visual Studio Code para .NETCore
-------------------------------------------

    . Acesse File / Preferences / Settings

    . Digite C#

    . Acesse "OmniSharp / CSharp: Format: Enabled" e habilite a configuração

    . Digite "Format on save" e habilite a configuração

    . Digite "Final" e habilite a configuração "Files: Insert final newline" e habilite a configuração

.NET Core Command-Line Interface (CLI)    
--------------------------------------

    . No terminal digite o comando abaixo para verificar as versões dos SDKs disponível

        dotnet --list-sdks

    . No terminal digite o comando abaixo para verificar as versões das runtimes disponíveis:

        dotnet --list-runtimes

    . No terminal digite o comando abaixo para verificar mais detalhes sobre as informações da runtime e SDK em uso:

        dotnet --info

    . Comandos dotnet cli:

        dotnet new selecionado      => Nova solution de projetos
        dotnet new console          => Novo Console Application
        dotnet new classlib         => Nova Class Library
        dotnet new web              => Novo projeto ASP.NET Core
        dotnet new mvc              => Novo projeto ASP.NET Core
        dotnet new webapi           => Novo projeto ASP.NET Core
        dotnet new mstest           => Novo projeto Microsoft Test

Documentação do C# e o que eu posso fazer com C#
------------------------------------------------

    . A documentação da Microsoft encontra-se no link abaixo:

        https://docs.microsoft.com/pt-br/dotnet/csharp

Criando uma Solution
--------------------

    . Criando o projeto já com a versão desejada:

        dotnet new console -n InvestmentControl -o ./src/investimentControl --framework [netcoreapp3.1 / net5.0 / net6.0 / net7.0 / net8.0 / net9.0 ]
        dotnet new console -n InvestmentControl -o ./src/investimentControl -f [netcoreapp3.1 / net5.0 / net6.0 / net7.0 / net8.0 / net9.0 ]

    . Podemos verificar as opções do compilador dotnet com o comando abaixo:

        dotnet new

    . Variáveis de Ambiente

        . Para trabalhar com variáveis de ambiente podemos passar como parâmetro no comando "dotnet run":

            dotnet run --enviroment=$SEU_AMBIENTE
            dotnet run --enviroment=development
            dotnet run --enviroment=production

    . Demo

        . Dentro da pasta CSharpBasico digite o comando abaixo:

            dotnet new sln --name CSharpBasico

        . Crie a pasta "src"

            mkdir src

        . Dentro da "Solution" criaremos um projeto, do tipo console:

            dotnet new console -n InvestmentControl -o ./src/investimentControl
            
            -n : name da aplicação (Nome do projeto InvestmentControl.csproj )
            -o : output (nome da pasta que será criado para criar as classes)

        . Agora precisamos associar o projeto a solution

            dotnet sln add ./src/investimentControl/

        . Digite o comando abaixo para verificar os projetos que compoem a solution:

            dotnet sln list

        . Dentro da pasta da solution digite o comando abaixo:

            dotnet build
            dotnet run --project ./src/investimentControl/

    . Para acessar a solução com o VisualStudio Code digite o comando abaixo:

        code .

    . A estrutura de pastas ficará:

        CSharpBasico
            |
            +----- src
            |       |
            |       +-----  investimentControl
            |                    |
            |                    +-----  bin
            |                    |
            |                    +-----  obj
            |                    |
            |                    + investimentControl
            |                    |
            |                    + Program.cs
            |
            + CSharpBasico.sln

    . Para limpar os arquivos de cache execute o comando abaixo:

        dotnet clean

    . Para compilar o projeto execute os comandos abaixo:

        dotnet clean
        dotnet build

    . O arquivo Program.cs em um projeto .NET é o ponto de entrada principal da aplicação. 
        Ele pode conter o método Main, do .NET 6 em diante houve uma mudança importante: a partir do .NET 6, 
        o C# passou a suportar o chamado "top-level statements" (instruções de nível superior). Isso significa 
        que não é mais obrigado a declarar explicitamente a classe Program e o método Main. Você pode escrever 
        o código diretamente no arquivo Program.cs, e o compilador cria o método Main automaticamente nos bastidores. 
        O arquivo Program.cs pode ficar assim:

        Console.WriteLine("Hello, World!");

    . Porém, se quiser, ainda pode usar a estrutura tradicional com a classe Program e o método Main:

        public class Program
        {
            public static void Main(string[] args)
            {
                Console.WriteLine("Hello, World!");
            }
        }

    . No caso de aplicações console (como seu projeto InvestmentControl), o Main é responsável por iniciar a execução 
        do código, podendo criar objetos, chamar métodos e controlar o fluxo do programa.

    . Demo

        . Acesse o arquivo "src/investimentControl/Program.cs" e altere o código conforme abaixo:

            // Linha alterada
            Console.WriteLine("InvestmentControl System");

        . Execute o comando abaixo na pasta raiz da solution:

            dotnet run --project ./src/investimentControl

        . Acesse a pasta raiz do projeto console e execute o comando abaixo

            cd CSharpBasico/src/investimentControl

            dotnet run

Dica para alterar a versão do dotnet de um projeto "console"
------------------------------------------------------------



    . Para baixar todos os pacotes do projeto usamos o comando abaixo:

        dotnet restore

        . Basicamente o "restore" é feito somente a primeira vez que abrimos o projeto para baixar os pacotes de dependência.

    . Para limpar ps arquivos de build antigos, execute o comando abaixo:

        dotnet clean

    . Para compilar o projeto e gerar os arquivos necessários para execução.

        dotnet build

    . Acesse o arquivo .csproj e altere o valor da tag <TargetFramework> para.

        net6
        net7

        Exemplo:

        <Project Sdk="Microsoft.NET.Sdk">
            <PropertyGroup>
                <OutputType>Exe</OutputType>
                <TargetFramework>net6</TargetFramework>     <!-- Parametro alterado -->
            </PropertyGroup>
        </Project>

    . O comando para verificar a versão do dotnet utilizada no projeto é:

        dotnet list ./src/investimentControl/ package     

    . Demo

        . Execute o comando abaixo na raiz da solution:

            dotnet list ./src/investimentControl/ package       # Saida:  [net8.0]: No packages were found for this framework. 

        . Altere a versão do dotnet do projeto console. Altere a linha abaixo no arquivo ./src/invetimentControl/InvestimentControl.csproj"

            <Project Sdk="Microsoft.NET.Sdk">

                <PropertyGroup>
                    <OutputType>Exe</OutputType>
                    <TargetFramework>net6.0</TargetFramework>       <!-- Linha alterada -->
                    <ImplicitUsings>enable</ImplicitUsings>
                    <Nullable>enable</Nullable>
                </PropertyGroup>

            </Project>

        . Execute o comando abaixo na raiz da solution:

            dotnet clean
            dotnet retore
            dotnet build
      
            dotnet list ./src/investimentControl/ package       # Saida:  [net6.0]: No packages were found for this framework. 

        . Acesse o arquivo "src/investimentControl/InvestmentControl.csproj" e retorne o projeto para a versão que foi criado "net8.0"

        . Execute o comando abaixo na raiz da solution:

            dotnet clean
            dotnet retore
            dotnet build
      
            dotnet list ./src/investimentControl/ package       # Saida:  [net8.0]: No packages were found for this framework. 

Debugando dentro do VSCode
--------------------------

    . Acesse o projeto, vá para a área de Debug, acione link "create a launch.json file"

    ou

    . Dentro da pasta "src/investimentControl" acesse o VSCode

        cd src/investimentControl

        code .

    . Ao entrar pela primeira vez ele irá fazer uma pergunta para colocar o build e o debug no projeto:

        "Required assets to build and debug are missing from '...'. Add then?", responda "Yes"


    . Ao responder "Yes", o VSCode ira criar uma pasta do projeto .vscode. Dentro desta pasta teremos dois arquivos
        ( launch.json e tasks.json). Esses arquivos criados automaticamente tem as configurações para depuração.

    . Podemos acessar a execução do projeto do icone com triângulo na barra vertical do VSCode, que surgira a "Side Bar".
        Neste ponto surgirá os botões de execução do projeto. 

    . Caso o projeto for um projeto Web:

        . Execute o projeto e no navegador execute a URL abaixo:

            http://localhost:5000/WeatherForecast

        . Caso exiba a mensagem: "unable to generate assets to build and debug. omnisharp server is not running" siga os passos abaixo:

            . Acesse a opção "Arquivos/Preferência/Configurações"

            . Digite "OmniSharp" e faça a localização:

            . Encontre a opção "OmniSharp Auto Start" e desabilite.

            . Acesse as extensões, na barra lateral do VSCode, clique na extensão C# e faça um Downgrade da versão para 1.23.17

            . Apague do seu projeto a pasta ".vscode"

            . Digite Ctrl + Shift + P

            . Digite ".Net: Generate Assests for Build and Debug" para criar o "launch.json" e o "task.json"

            . Saia e entre no VSCode. Verifique na entrada se a instalação do OmniSharp ocorreu com sucesso.

            . Retorne a opção "OmniSharp Auto Start" e habilite.

    . Pare a aplicação, e elimine os arquivos abaixo do projeto:

        /WeatherForecast.cs
        Controllers/WeatherForecastController.cs
        
    . No VSCode acesse a opção Terminal / Run Task... e escolha a opção "build"

    . Demo

        . Acesse o projeto, vá para a área de Debug, acione link "create a launch.json file"

            . Escolha a opção ".NET5...."

            . Faça a gravação do arquivo "launch.json"

        . Acesse o arquivo "Program.cs" e adicione um "breakpoint na linha com o "Console.WriteLine"

        . Pressione F5, ou o botão de play na área de debug

        . Quando a execução para no "breakpoint", pressione o botão F10 para ir para a próxima linha

    . Os botões para realizar a execução do debug são:

        F5              Inicia o debug
        Ctrl + F5       Inicia o debug, mas não para nos breakpoints
        F10             Movimenta para a próxima linha
        F11             Acessa o código do método da linha em execução, caso essa chamar outra rotina.

    . Na área de debug do VS Code, os principais quadros e suas funções são:

        . Variables:    Exibe todas as variáveis locais, parâmetros e seus valores atuais durante a execução do código. 
                        Permite inspecionar o estado do programa em cada ponto do debug.

        . Watch:        Permite adicionar variáveis ou expressões específicas para monitorar seus valores ao longo da 
                        execução, independentemente do escopo atual.

        . Call Stack:   Mostra a pilha de chamadas de métodos/funções, permitindo ver a sequência de execuções que levou ao 
                        ponto atual. Útil para entender o fluxo do programa e navegar entre métodos.

        . Breakpoints:  Lista todos os breakpoints definidos no código, permitindo ativar, desativar ou removê-los facilmente.


Instalar pacotes através do Nuget.org
-------------------------------------

    . Ao ser compilada, uma biblioteca gera um arquivo DLL. Será esta DLL que os outros projetos irão utilizar. 
        O NuGet aproveita desta característica da plataforma para definir seus pacotes.

    . Na prática, um pacote NuGet é um arquivo compactado com a extensão .nupkg que contém um código compilado (DLL), 
        outros arquivos relacionados a este código (como imagens, etc.) e um arquivo de configuração que contém 
        informações sobre o pacote, como: número de versão, criador, etc.

    . Estes pacotes .nupkg podem ser publicados em repositórios públicos ou privados, onde os desenvolvedores podem 
        consumi-los, adicionando-os em seus projetos e utilizando no código as funcionalidades que fornecerem.

    . Em se tratando de projeto, como se fosse as dependências de bibliotecas.

    . Demo

        . Acesse o site nuget.org, digite "Newtonsoft.Json" e faça a pesquisa.

        . Acesse o item Newtonsoft.Json

        . Acesse uma das versões, atualmente 13.0.3
        
        . Acesse a aba .NetCli.

        . Copie o comando sugerido por esse caminho

        . Acesse a pasta do projeto console e execute o comando copiado

            # dotnet add package Newtonsoft.Json
            dotnet add package Newtonsoft.Json --version 13.0.3

        . Após a execução, no terminal, execute um dos comandos abaixo:

            dotnet restore

            ou

            dotnet build

        . Insira as linhas abaixo na classe "Program.cs"

            // linha inserida
            using Newtonsoft.Json;

            // See https://aka.ms/new-console-template for more information
            Console.WriteLine("Investment Control System");

            // Trecho de código inserido
            Product product = new Product();
            product.Name = "Apple";
            product.Expiry = new DateTime(2008, 12, 28);
            product.Sizes = new string[] { "Small" };

            string json = JsonConvert.SerializeObject(product);

            Console.WriteLine(json);

            class Product
            {
                public string? Name { get; set; }
                public DateTime Expiry { get; set; }
                public string[]? Sizes { get; set; }
            }
            // Fim da inserção

        . Execute o comando na pasta do projeto console:

            dotnet run

        . Acesse o arquivo com extensão "*.csproj" e verifique que agora temos o pacote dentro da aplicação:

            <ItemGroup>
                <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
            </ItemGroup>

        . Retorne ao Home do site nuget.org, digite "Spectre.Console" e copie o comando sugerido por esse caminho:

        . Acesse a pasta do projeto console e execute o comando copiado

            # Para criar interfaces de linha de comando ricas e interativas:
            dotnet add package Spectre.Console --version 0.50.0

            dotnet restore

            dotnet build

        . Altere o código da classe "Program.cs" deixando como abaixo:

            // Linha inserida
            using Spectre.Console;

            // See https://aka.ms/new-console-template for more information
            Console.WriteLine("Investment Control System");

            //////////////////////////////
            // Trecho de código inserdo //
            //////////////////////////////

            // Ask the user to confirm
            var confirmation = AnsiConsole.Prompt(
                new TextPrompt<bool>("Run prompt example?")
                    .AddChoice(true)
                    .AddChoice(false)
                    .DefaultValue(true)
                    .WithConverter(choice => choice ? "y" : "n"));

            var password = AnsiConsole.Prompt(
                new TextPrompt<string>("Enter password:")
                    .Secret());

            // Echo the confirmation back to the terminal
            Console.WriteLine(confirmation ? "Confirmed" : "Declined");

            // Echo the password back to the terminal
            Console.WriteLine($"Your password is {password}");

            /////////////////////
            // Fim da inserção //
            ////////////////////

        . Acesse novamente o arquivo com a extensão *.csproj e verifique a dependência copiada dentro do nó "ItemGroup":

            <ItemGroup>
                <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
                <PackageReference Include="Spectre.Console" Version="0.50.0" />
            </ItemGroup>

        . Se quiser podemos dar o "dotnet restore", ou o "dotnet build", no terminal.

        . Caso haja a necessidade de retirar alguma dependência do nó "ItemGroup", acesse o terminal, e execute os comandos abaixo:

            dotnet clean
            dotnet restore

    . Outras bibliotecas que interagem com projetos console que podem ser testadas:

        Serilog             Para logging estruturado:

            dotnet add package Serilog

        Dapper              Para acesso a banco de dados de forma simples e performática:

            dotnet add package Dapper

        CsvHelper           Para leitura e escrita de arquivos CSV:

            dotnet add package CsvHelper

        Polly               Para políticas de resiliência e tratamento de falhas (retry, circuit breaker, etc.):

            dotnet add package Polly

        Spectre.Console     Para criar interfaces de linha de comando ricas e interativas:

            dotnet add package Spectre.Console

        FluentValidation    Para validação de objetos:

            dotnet add package FluentValidation

        AutoMapper          Para mapeamento automático de objetos:

            dotnet add package AutoMapper

.NET Standard
-------------

        +-----------------------------+-----------------------------+-----------------------------+
        |    .NET FRAMEWORK           |          .NET Core          |        XAMARIN              |
        +-----------------------------+-----------------------------+-----------------------------+
        |   WPF        Windows Forms  |          UWP                |     iOS                     |
        |        ASP.NET              |      ASP.NET Core           |               Android       |
        |                             |                             |    OS X                     |
        +-----------------------------+-----------------------------+-----------------------------+
        |                          .NET STANDARD LIBRARY                                          |
        |                                                                                         |
        +-----------------------------+-----------------------------+-----------------------------+

        +-----------------------------+-----------------------------+-----------------------------+
        |                       COMMON INFRASTRUCTURE                                             |
        +-----------------------------+-----------------------------+-----------------------------+
        |       Compilers             |     Languages               |        Runtime Components   |
        +-----------------------------+-----------------------------+-----------------------------+

Sequências de Escape/"Escape Sequences"
---------------------------------------

    . São combinações de caracteres usadas dentro de strings para representar caracteres especiais que não podem ser 
        inseridos diretamente no texto, como quebras de linha, tabulações, aspas, entre outros.

    . Elas começam com uma barra invertida (\). Alguns exemplos comuns:

        \n — Nova linha (line feed)
        \r — Retorno de carro (carriage return)
        \t — Tabulação
        \\ — Barra invertida literal
        \" — Aspas duplas dentro de uma string
        \' — Aspas simples
        \0 — Caractere nulo

    . Exemplos:

        Console.WriteLine("Primeira linha\nSegunda linha\tcom tabulação");
        Console.WriteLine("Aspas duplas: \"texto entre aspas\"");


    . Demo

        . Altere o conteúdo da classe "Program.cs" conforme abaixo:

            // Linhas inseridas

            // \n — Nova linha
            Console.WriteLine("Primeira linha\nSegunda linha");

            // Primeira linha
            // Segunda linha

            // \t — Tabulação
            Console.WriteLine("Coluna 1\tColuna 2");

            // Coluna 1        Coluna 2

            // \\ — Barra invertida literal
            Console.WriteLine("Caminho: C:\\Users\\Marco");

            // Caminho: C:\Users\Marco

            // \" — Aspas duplas dentro de uma string
            Console.WriteLine("Ele disse: \"Olá, mundo!\"");

            // Ele disse: "Olá, mundo!"


            // \' — Aspas simples
            Console.WriteLine("Aspas simples: \'a\'");

            // Aspas simples: 'a'

            // \r — Retorno de carro
            Console.WriteLine("Texto antes do retorno\r\nNovo texto");

            // Texto antes do retorno
            // Novo texto

            // \0 — Caractere nulo
            string textoComNulo = "ABC\0DEF";
            Console.WriteLine("Texto com caractere nulo: " + textoComNulo);

            // Texto com caractere nulo: ABC?DEF

            // Fim da inserção

        . Execute o projeto e veja o resultado.

            dotnet run --project ./src/investimentControl

Tipagem de Dados
----------------

    . Tipos por valor ou primitivos:

        . São alocados diretamente na pilha.
        . Não precisam ser inicializados com o operador new.
        . A variável armazena o valor diretamente.
        . A atribuição de uma variável a outra copia o conteúdo, criando efetivamente outra cópia da variável.
        . Normalmente usados com tipos de pequeno tamanho (menos que 16 bytes), onde o uso de referências traria um custo muito grande.
        . Podem ser automaticamente convertidos para referências em um processo chamado “boxing”,

        Tipo        Implementação
        ----        -------------
        byte 	    Inteiro de 8 bits sem sinal (0 a 255).
        sbyte 	    Inteiro de 8 bits com sinal (-127 a 128).
        ushort 	    Inteiro de 16 bits sem sinal (0 a 65 535).
        short 	    Inteiro de 16 bits com sinal (-32 768 a 32 767).
        uint 	    Inteiro de 32 bits sem sinal (0 a 4 294 967 295).
        int 	    Inteiro de 32 bits com sinal (-2 147 483 648 a 2 147 483 647).
        ulong 	    Inteiro de 64 bits sem sinal (0 a 18 446 744 073 709 551 615).
        long 	    Inteiro de 64 bits com sinal (-9 223 372 036 854 775 808 a 9 223 372 036 854 775 807).
        double 	    Ponto flutuante binário IEEE de 8 bytes (±5.0×10-324 a ±1.7×10308), 15 dígitos decimais de precisão.
        float 	    Ponto flutuante binário IEEE de 4 bytes (±1.5×10-45 a ±3.4×1038), 7 dígitos decimais de precisão.
        decimal 	Ponto flutuante decimal de 128 bits. (1.0×10-28 a 7.9×1028), 28 dígitos decimais de precisão.
        bool 	    Pode ter os valores true e false. Não é compatível com inteiro.
        char 	    Um único caractere Unicode de 16 bits. Não é compatível com inteiro.


        . float, double e decimal são tipos para uso com casas decimais. O decimal mais usado para valores monetários com calculos financeiro.

            int qtdEstoque = 10;

            long qtdEstoque = 10L;      // para declarar números long é necessário colocar a letra "L"

            double salario = 2.500; 

            float salario = 2.500f;     // Float é necessário colocar a letra "f" quando for declarar "hardcode"

            decimal salario = 2.500m    // Idem para decimal, porém a letra é o "m"

        . Evite float e double para valores monetários, mesmo que "funcionem", pois podem causar erros de arredondamento imperceptíveis, 
            mas perigosos em cálculos acumulados, como juros compostos, faturas ou salários

            . O tipo decimal tem alta precisão e baixa perda de dados em operações com casas decimais, o que é ideal para cálculos financeiros.

                decimal preco = 1299.99m;
                decimal imposto = 0.15m;
                decimal total = preco * (1 + imposto);

                Console.WriteLine($"Total com imposto: {total:C}");

        . Números explícitos informados na inicialização de variáveis, sem casas decimais, são considerados do tipo int por padrão.
            Números com casas decimais são considerados do tipo double por padrão.

            int x = 10;        // 10 é int
            double y = 2.5;    // 2.5 é double

        . var

            . Substitui o nome de um tipo

            . Será do tipo do primeiro valor atribuido

            . Recomendado o uso ( Deixe pra usar var quando já dominar os tipos)

            . A grande vantagem em usar o var é na economia de código, por exemplo:

                IEnumerable<Cliente> clientes = new IEnumerable<Cliente>();

                ou

                var clientes = new IEnumerable<Cliente>();

            . Uma variável pode ser iniciada pelo tipo (int, long, float, ...), ou pela palavra reservada "var":

                int idade = 10;
                var idade = 10;

                . "var" obriga que um valor seja informado, pois é através dele que o compilador determina o tipo da variável.

                    int idade;      // Válido
                    var idade;      // Inválido

        . Constantes

            const int IDADE_MINIMA = 10;
            const var IDADE_MINIMA = 10;
            const var IDADE_MINIMA;     // Inválido

        . Object é usado da mesma forma do var

            var idade = 10;

            object idade = 10;

            . O tipo object é mais versatil do que o var:

                object idade;       // Não dá erro como o var

        . Tipos definidos pelo usuário:

            . enum

                . Permite declarar uma seqüência de identificadores associados, mas incompatíveis com inteiros e com outras enumerações. 
                    Praticamente idêntico às enumerações do Delphi. Exemplo:

                    enum Days { Sun, // 0
                                Mon, // 1
                                Tue, 
                                Wed, 
                                Thu, 
                                Fri, 
                                Sat}; // 6

                    enum Categories
                    {
                        Electronics = 1,  
                        Food = 5, 
                        Automotive = 6, 
                        Arts = 10, 
                        BeautyCare = 11, 
                        Fashion = 15,
                        WomanFashion = 15
                    }

                . Em C#, o lugar mais comum e recomendado para declarar um enum é fora dos métodos, mas dentro de uma classe, struct ou namespace. 
                    Não é permitido declarar um enum diretamente dentro de um método.

                    // Enum fora da classe (nível de namespace):
                    enum ClasseAtivo
                    {
                        RendaVariavel,
                        RendaFixa,
                        Criptomoeda,
                        FundoInvestimento,
                        COE
                    }

                    class Program
                    {
                        static void Main(string[] args)
                        {
                            ...
                        }
                    }


                    // Enum dentro da classe, mas fora dos métodos:
                    class Program
                    {
                        enum ClasseAtivo
                        {
                            RendaVariavel,
                            RendaFixa,
                            Criptomoeda,
                            FundoInvestimento,
                            COE
                        }

                        static void Main(string[] args)
                        {
                            ...
                        }
                    }

            . Demo

                . Substitua o conteúdo da classe "Program.cs" pelo conteúdo abaixo:

                    class Program
                    {
                        enum ClasseAtivo
                        {
                            RendaVariavel,
                            RendaFixa,
                            Criptomoeda,
                            FundoInvestimento,
                            COE
                        }


                        static void Main(string[] args)
                        {
                            var rendaVariavel = ClasseAtivo.RendaVariavel;

                            var rv = (ClasseAtivo)0;

                            var rvValue = (int)rendaVariavel;

                            Console.WriteLine($"{ClasseAtivo.RendaVariavel} é composto por Ações, FIIs e ETFs. {rendaVariavel} e {rv} é o valor da variável e \"{rvValue}\" é o valor do enum convertido de inteiro.");
                            // Saída: Sunday, referente ao dia 0 da semana. Sunday é o primeiro dia da semana.
                        }
                    }

            . Record -  É um tipo de referência introduzido no C# 9.0, projetado para representar objetos imutáveis e com foco em 
                        igualdade de valor (value-based equality), ou seja, dois records com os mesmos valores em suas propriedades são 
                        considerados iguais, diferente das classes tradicionais que comparam por referência.

                . Características principais dos records:

                    . São imutáveis por padrão (mas podem ser mutáveis).

                    . Comparação de igualdade baseada nos valores das propriedades.

                    . Suporte a "with-expressions" para criar cópias com alterações.

                    . Sintaxe concisa para declaração.

                . Exemplos:

                    1. Record simples (imutável por padrão):

                        public record Pessoa(string Nome, int Idade);
                    
                        var pessoa1 = new Pessoa("Maria", 30);
                        var pessoa2 = new Pessoa("Maria", 30);
                        
                        Console.WriteLine(pessoa1 == pessoa2); // True (igualdade por valor)

                    2. Usando with-expressions:

                        var pessoa3 = pessoa1 with { Idade = 31 };

                        Console.WriteLine(pessoa3); // Pessoa { Nome = Maria, Idade = 31 }

                    3. Record com propriedades nomeadas:

                        public record Produto       // +------> podemos utilizar "set" no lugar do "init" para deixar mutável
                        {                           // |        o record, porém não é recomendado
                            public string Nome { get; init; }           //      |
                            public decimal Preco { get; init; }         //      +--->   Neste caso poderiamos alterar a propriedade 
                        }                                               //              do objeto record: 
                                                                        //
                                                                        //                  var produto = new Produto{ Nome = "Mouse", Preco = 50m };
                                                                        //                  produto.preco = 10m;
                        
                        // Propriedades nomeadas ----+
                        //                           |
                        //                           V
                        var produto = new Produto { Nome = "Notebook", Preco = 3500m };

                    4. Record mutável (não recomendado, mas possível):

                        public record Carro
                        {
                            public string Modelo { get; set; }
                            public int Ano { get; set; }
                        }

                . Record é uma excelente opção para substituir classes DTOs (Data Transfer Objects) em APIs no C#.
                        Pessoa { Nome = Maria, Idade = 31 }
                        Produto: Notebook, Preço: 3500
                        Cachorro: Rex, Raça: Labrador


                    . São ideais para esse cenário porque:

                        . São imutáveis por padrão, o que aumenta a segurança e previsibilidade dos dados.

                        . Possuem igualdade baseada em valor, facilitando comparações e testes.

                        . Têm sintaxe concisa, reduzindo o código boilerplate.

                        . Suportam with-expressions, permitindo criar cópias modificadas facilmente.

                    . Exemplo:
                        
                        // Record
                        public record ProdutoRequest(string Nome, decimal Preco);

                        // Controller API
                        [HttpPost]
                        public IActionResult CriarProduto([FromBody] ProdutoRequest request)
                        {
                            // request.Nome e request.Preco disponíveis aqui
                            ...
                        }

            . Demo

                . Altere o conteúdo da classe "Program.cs" com o conteúdo abaixo:

                    public record Investidor(string Nome, string Email, decimal TotalInvestido, DateTime DataInclusao);

                    class Program
                    {
                        static void Main(string[] args)
                        {
                            var investidor1 = new Investidor("Jose Silva", "jose.silva@email.com.br", 1000m, DateTime.Today);
                            var investidor2 = new Investidor("Jose Silva", "jose.silva@email.com.br", 1000m, DateTime.Today);

                            Console.WriteLine(investidor1);
                            Console.WriteLine(investidor2);

                            Console.WriteLine(investidor1 == investidor2);
                        }

                    }

                . Execute o projeto e veja o resultado:

                    dotnet run --project ./src/investimentControl

                    # Saída:    
                    Investidor { Nome = Jose Silva, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }
                    Investidor { Nome = Jose Silva, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }
                    True

                . Insira a linha abaixo na classe "Program.cs":

                    public record Investidor(string Nome, string Email, decimal TotalInvestido, DateTime DataInclusao);

                    class Program
                    {
                        static void Main(string[] args)
                        {
                            var investidor1 = new Investidor("Jose Silva", "jose.silva@email.com.br", 1000m, DateTime.Today);
                            var investidor2 = new Investidor("Jose Silva", "jose.silva@email.com.br", 1000m, DateTime.Today);

                            Console.WriteLine(investidor1);
                            Console.WriteLine(investidor2);

                            Console.WriteLine(investidor1 == investidor2);

                            // Linha inserida
                            var investidor3 = investidor1 with { Nome = "Maria" };

                            // Linha inserida
                            Console.WriteLine(investidor3);
                        }

                    }

                . Execute o projeto e veja o resultado:

                    dotnet run --project ./src/investimentControl

                    # Saída:    
                    Investidor { Nome = Jose Silva, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }
                    Investidor { Nome = Jose Silva, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }
                    True
                    Investidor { Nome = Maria, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }

                . Insira a linha abaixo na classe "Program.cs":

                    public record Investidor(string Nome, string Email, decimal TotalInvestido, DateTime DataInclusao);

                    // Record inserido
                    public record Conta
                    {
                        public string agencia { get; init; }
                        public string nrConta ( get; init; )
                    }

                    class Program
                    {

                        static void Main(string[] args)
                        {
                            var investidor1 = new Investidor("Jose Silva", "jose.silva@email.com.br", 1000m, DateTime.Today);
                            var investidor2 = new Investidor("Jose Silva", "jose.silva@email.com.br", 1000m, DateTime.Today);

                            Console.WriteLine(investidor1);
                            Console.WriteLine(investidor2);

                            Console.WriteLine(investidor1 == investidor2);

                            var investidor3 = investidor1 with { Nome = "Maria" };

                            Console.WriteLine(investidor3);

                            // Linha inserida
                            var conta = new Conta(){ agencia : "001", nrConta : "12345"};
                            
                            // Linha inserida
                            Console.WriteLine($"Conta -> {conta}");
                        }

                    }

                . Execute o projeto e veja o resultado:

                    dotnet run --project ./src/investimentControl
                
                    # Saída:    
                    Investidor { Nome = Jose Silva, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }
                    Investidor { Nome = Jose Silva, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }
                    True
                    Investidor { Nome = Maria, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }
                    Conta { agencia = 001, nrConta = 12345 }

                . Insira a linha abaixo na classe "Program.cs":

                    using System.ComponentModel;

                    public record Investidor(string Nome, string Email, decimal TotalInvestido, DateTime DataInclusao);

                    public record Conta
                    {
                        public string? agencia { get; init; }
                        public string? nrConta { get; init; }
                    }

                    // Record inserido
                    public record ContaAplicacao : Conta
                    {
                        public Investidor? Investidor { get; init; }
                        public DateTime DataAbertura { get; init; }
                    }

                    class Program
                    {

                        static void Main(string[] args)
                        {
                            var investidor1 = new Investidor("Jose Silva", "jose.silva@email.com.br", 1000m, DateTime.Today);
                            var investidor2 = new Investidor("Jose Silva", "jose.silva@email.com.br", 1000m, DateTime.Today);

                            Console.WriteLine(investidor1);
                            Console.WriteLine(investidor2);

                            Console.WriteLine(investidor1 == investidor2);

                            var investidor3 = investidor1 with { Nome = "Maria" };

                            Console.WriteLine(investidor3);

                            var conta = new Conta() { agencia = "001", nrConta = "12345" };

                            Console.WriteLine($"{conta}");

                            // Linha inserida
                            var contaAplicacao = new ContaAplicacao()
                            {
                                agencia = "001",
                                nrConta = "12345",
                                Investidor = investidor3,
                                DataAbertura = DateTime.Today
                            };

                            // Linha inserida
                            Console.WriteLine($"{contaAplicacao}");

                        }

                    }

                . Execute o projeto e veja o resultado:

                    dotnet run --project ./src/investimentControl
                
                    # Saída:    
                    Investidor { Nome = Jose Silva, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }
                    Investidor { Nome = Jose Silva, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }
                    True
                    Investidor { Nome = Maria, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }
                    Conta { agencia = 001, nrConta = 12345 }
                    ContaAplicacao { agencia = 001, nrConta = 12345, Investidor = Investidor { Nome = Maria, Email = jose.silva@email.com.br, TotalInvestido = 1000, DataInclusao = 07/15/2025 00:00:00 }, DataAbertura = 07/15/2025 00:00:00 }

            . struct 
            
                . (estrutura) é um tipo de valor que permite agrupar vários dados sob um mesmo nome, semelhante a uma classe, 
                        mas com algumas diferenças importantes:

                    . São tipos por valor (alocados na stack, não no heap).

                    . Não suportam herança (são implicitamente sealed).

                    . Podem ter métodos, propriedades, construtores (desde que aceitem parâmetros), e implementar interfaces.

                    . Podem ter um construtor sem parâmetros definido pelo usuário (caso não tenha, o compilador gera um padrão).

                    . São ideais para representar pequenos conjuntos de dados que não precisam de identidade única.

                . Exemplo:

                        public struct Point { 
                            public int x, y; 
                            
                            // Construtor com parâmetros
                            public Point(int p1, int p2) { 
                                x = p1; 
                                y = p2;    
                            } 
                        }

                        // Método
                        public void Print()
                        {
                            Console.WriteLine($"({X}, {Y})");
                        }

                        class Program
                        {
                            static void Main()
                            {
                                // Instanciando struct
                                Point p1 = new Point(10, 20);
                                p1.Print(); // Saída: (10, 20)

                                // Structs podem ser criadas sem usar new (mas os campos precisam ser inicializados antes do uso)
                                Point p2;
                                p2.X = 5;
                                p2.Y = 15;
                                p2.Print(); // Saída: (5, 15)
                            }
                        }

            . Demo

                . Atualize o código da classe "Program.cs" com o conteúdo abaixo:

                    using System;

                    public struct Investor
                    {
                        // Propriedades
                        public string Name { get; set; }
                        public string Email { get; set; }
                        public decimal TotalInvested { get; set; }
                        public DateTime RegistrationDate { get; set; }

                        // Construtor com parâmetros
                        public Investor(string name, string email, decimal totalInvested, DateTime registrationDate)
                        {
                            Name = name;
                            Email = email;
                            TotalInvested = totalInvested;
                            RegistrationDate = registrationDate;
                        }

                        // Método para exibir informações do investidor
                        public void ShowInfo()
                        {
                            Console.WriteLine($"Nome: {Name}");
                            Console.WriteLine($"Email: {Email}");
                            Console.WriteLine($"Total Investido: {TotalInvested:C}");
                            Console.WriteLine($"Data de Cadastro: {RegistrationDate:dd/MM/yyyy}");
                        }
                    }

                    // Exemplo de uso
                    class Program
                    {
                        static void Main()
                        {
                            Investor investor = new Investor("Ana Souza", "ana@email.com", 15000m, DateTime.Now);
                            investor.ShowInfo();
                        }
                    }

                . Execute o projeto e veja o resultado:

                    dotnet run --project ./src/investimentControl

                    # Saída:    
                    Nome: Ana Souza
                    Email: ana@email.com
                    Total Investido: ¤15,000.00
                    Data de Cadastro: 15/07/2025

    . Tipos por Referência, ou complexos:

        . São alocados em um heap e sujeitos à “coleta de lixo” (“garbage collection”) quando não forem mais usados.

        . Devem ser inicializados com o operador new.

        . A variável armazena uma “referência”, uma espécie de ponteiro; o conteúdo em si fica no heap.

        . A atribuição de uma variável a outra copia a referência; podemos ter muitas variáveis referindo-se ao mesmo valor.

        . Normalmente usados com tipos de grande tamanho (mais que 16 bytes), onde o custo da alocação dinâmica é relativamente 

            pequeno frente a sua flexibilidade.

        . Podem conter o valor null, embora se usarmos uma variável com o valor null a exception NullReferenceException será gerada.

        . Arrays

            . Um array é sempre criado dinamicamente em tempo de execução. Podemos ter arrays de várias dimensões e arrays de arrays. 
                Veja um exemplo de criação e inicialização de um array de inteiros de uma dimensão:

                int[] myIntArray = new int[5] { 1, 2, 3, 4, 5 };

            . Existe um tópico mais a frente que detalha melhor o uso de Arrays

        . Tipo string

            As strings são tecnicamente um tipo por referência, mas possuem algumas características especiais:

                . Não precisam ser inicializadas com o operador new.
                . A atribuição de uma variável a outra funciona como se copiasse o conteúdo, criando efetivamente outra cópia da variável.
                . Uma string contendo o valor null é uma string vazia; não é um erro usá-la.
                . Você não pode criar uma classe derivada de string.

            As strings contêm caracteres Unicode e podem ter até 1G de comprimento. Veja um exemplo:

                // Declara e inicializa uma string
                string Name = "Mary";

                // Copia para outra string. Se alterarmos uma delas, a outra manterá o seu valor
                string NewName = Name;

                // Atribui à string antiga
                Name = "John";

                // Exibe "John - Mary"
                System.Console.WriteLine(Name + " - " + NewName);

    . Nullable Types

        . Significa vazio, nada
        . Diferente de zero ou uma string vazia
        . Todo tipo primitivo, ou complexo, pode receber o valor null
        . O tipo deve ser marcado como Nullable Type

        . Podemos atribuir null a um objeto, desde que o mesmo seja marcado como nullable, usando interrogação na frente do tipo.
        . Se uma chamada a um valor nulo for feita um erro sera apresentado.
        . O ? após o tipo indica que a variável pode receber null.
        . O ! é usado para informar ao compilador que você garante que o valor não será nulo naquele ponto.

            string? nome = null;    // 'nome' pode ser nulo

            ou

            public class Pessoa
            {
                public string Nome { get; set; } = null!; // Diz ao compilador que será atribuído depois
            }

            ou

            string? texto = ObterTexto();
            Console.WriteLine(texto!.Length); // Garante ao compilador que texto não é nulo aqui

            void ImprimirNome(Pessoa pessoa)
            {
                Console.WriteLine(pessoa.Nome!); // Garante ao compilador que Nome não é nulo
            }

        . Quando adicionamos <nullable>enable</nullable> no seu .csproj, o compilador passa a emitir avisos quando você pode estar usando 
            referências nulas de forma insegura, ajudando a evitar erros de NullReferenceException.

            . Habilitar tipos de referência anuláveis:

                <PropertyGroup>
                    <Nullable>enable</Nullable>
                </PropertyGroup> 

            . Desabilitar tipos de referência anuláveis:

                <PropertyGroup>
                    <Nullable>disable</Nullable>
                </PropertyGroup>

            . Valores possíveis:

                enable: Ativa os avisos e recursos de tipos de referência anuláveis.
                disable: Desativa os avisos e recursos.
                warnings: Apenas mostra avisos, sem ativar o recurso.
                annotations: Apenas ativa as anotações, sem avisos.

            . Resumo
                
                . Com <Nullable>enable</Nullable>, você pode usar string? para indicar que uma string pode ser nula, e o compilador 
                    vai avisar se você esquecer de tratar possíveis valores nulos.

                . Ajuda a tornar o código mais seguro e menos propenso a erros de referência nula.

        . Trabalhando com strings nulas:

            static void Salvar( string texto ){

                if ( string.IsNullOrEmpty( texto ) ){
                    throw new Exception( "Texto não pode ser nulo" );
                }

                if (string.IsNullOrWhiteSpace(texto))
                {
                    throw new Exception( "String é nula, vazia ou só espaços" );
                }

                if (texto == null)
                {
                    throw new Exception("String é nula");
                }
            }

System
------

    . No .NET tudo começa de um tipo base chamado "system"
    . Ele é a base de todos os objetos no .NET
    . Todos os tipos é devirados do "System"

Valores Padrões
---------------

    int, float, decimal => 0
    bool => false
    char => '\0'
    String => ""

Conversão Implícita
-------------------

    . Conversões implícitas ocorre quando somente fazemos a passagem de dados e com tipos compatíveis:

        float valor = 25.8f;
        int outro = 25;

        valor = outro;      // Conversão implicita, é permitido converter inteiro para float

        outro = valor;      // Erro de conversão, float não pode ser convertido para int;

    . Retorne no passo "Tipagem de Dados" e observe o valor máximo de cada tipo. O tamanho de cada tipo também limitará 
        a conversão implícita.

    . Conversões implícita válidas:

        De	        Para
        --          ----
        sbyte	    short , int, long, float, double, ou decimal
        byte	    short , ushort, int, uint, long, ulong, float, double, ou decimal
        short	    int , long, float, double, ou decimal
        ushort	    int , uint, long, ulong, float, double, ou decimal
        int	        long , float, double, ou decimal
        uint	    long , ulong, float, double, ou decimal
        long	    float , double, ou decimal

Conversão Explícita
-------------------

    . Para realizar este tipo, você deve declarar à frente da variável da direita e entre parênteses o tipo de dado que deseja.

        Exemplo 1:

            using System;

            namespace ConversionExplicit
            {
                class Program
                {
                    static void Main(string[] args)
                    {
                        sbyte a = 10;
                        short b = (short)a;
                        int c = (int)b;
                        long d = (long)c;
                        float e = (long)d;
                        double f = (float)e;
                        Console.Write(f);
                        Console.Read();
                    }
                }
            }

        Exemplo 2

        namespace ConversionExplicitRefenceType
        {
            class Humano
            {
                //Propriedades e Métodos
            }
            class Feminino : Humano
            {
                //Propriedades e Métodos
            }
            class Masculino : Humano
            {
                //Propriedades e Métodos
            }
            class Program
            {
                static void Main(string[] args)
                {
                    Feminino Mulher = new Feminino();
                    Humano SerHumano = Mulher;
                    Feminino OutraMulher = (Feminino)SerHumano;

                    // Feminino OutraMulher = SerHumano as Feminino;        // Outra forma "as"
                }
            }
        }

Parse
-----

    . int.Parse() - lança uma exceção se a conversão falhar;

    . As exceções possíveis usando ambos os métodos são:

        Exceção 	            Condição
        -------                 --------
        ArgumentNullException 	s é  null.
        FormatException 	    s não esta em um formato válido
        OverflowException 	    s esta fora da faixa dos números inteiros

        Conversão para int usando Int.Parse() 	            resultado
        -------------------------------------               ---------
        string valor1 = "100"                               O valor é convertido sem erros
        int valor2 = int.Parse(valor1); 	                valor2 = 100

        string valor1 =null;                                
        int valor2 = int.Parse(valor1); 	                Lança a exceção ArgumentNullException
        
        string valor1 = "100.99";               
        int valor2 = int.Parse(valor1); 	                Lança a exceção FormatException

        string valor1 = "999999999999999999999999999999";
        int valor2 = int.Parse(valor1); 	                Lança a exceção OverflowException

    . Demo

        . Adapte a classe "Program.cs" com as linhas abaixo:

            // Exemplo de conversão usando Parse, TryParse e Convert para tipos nativos em C#
            using System;

            class Program
            {
                static void Main()
                {
                    // int
                    string intStr = "123";
                    int intVal = int.Parse(intStr);

                    // long
                    string longStr = "123456789";
                    long longVal = long.Parse(longStr);

                    // short
                    string shortStr = "32000";
                    short shortVal = short.Parse(shortStr);

                    // byte
                    string byteStr = "255";
                    byte byteVal = byte.Parse(byteStr);

                    // sbyte
                    string sbyteStr = "127";
                    sbyte sbyteVal = sbyte.Parse(sbyteStr);

                    // uint
                    string uintStr = "4294967295";
                    uint uintVal = uint.Parse(uintStr);

                    // ulong
                    string ulongStr = "18446744073709551615";
                    ulong ulongVal = ulong.Parse(ulongStr);

                    // ushort
                    string ushortStr = "65535";
                    ushort ushortVal = ushort.Parse(ushortStr);

                    // float
                    string floatStr = "3.14";
                    float floatVal = float.Parse(floatStr);

                    // double
                    string doubleStr = "3.14159265359";
                    double doubleVal = double.Parse(doubleStr);

                    // decimal
                    string decimalStr = "12345.6789";
                    decimal decimalVal = decimal.Parse(decimalStr);

                    // bool
                    string boolStr = "true";
                    bool boolVal = bool.Parse(boolStr);

                    // char
                    string charStr = "A";
                    char charVal = char.Parse(charStr);

                    // Exibindo resultados
                    Console.WriteLine($"int: {intVal}");
                    Console.WriteLine($"long: {longVal}");
                    Console.WriteLine($"short: {shortVal}");
                    Console.WriteLine($"byte: {byteVal}");
                    Console.WriteLine($"sbyte: {sbyteVal}");
                    Console.WriteLine($"uint: {uintVal}");
                    Console.WriteLine($"ulong: {ulongVal}");
                    Console.WriteLine($"ushort: {ushortVal}");
                    Console.WriteLine($"float: {floatVal}");
                    Console.WriteLine($"double: {doubleVal}");
                    Console.WriteLine($"decimal: {decimalVal}");
                    Console.WriteLine($"bool: {boolVal}");
                    Console.WriteLine($"char: {charVal}");
                }
            }

        . Execute o projeto e veja o resultado:

            dotnet run --project ./src/investimentControl

            # Saída:    
            int: 123
            long: 123456789
            short: 32000
            byte: 255
            sbyte: 127
            uint: 4294967295
            ulong: 18446744073709551615
            ushort: 65535
            float: 314
            double: 314159265359
            decimal: 123456789
            bool: True
            char: A

TryParse
--------

    int.TryParse() - Se a conversão falhar retorna zero;


    Conversão para int usando Int.TryParse() 	            resultado
    ----------------------------------------                ---------
    string valor1 = "1000"
    int resultado;                                          O valor é convertido sem erros.
    bool sucesso = int.TryParse(valor1, out resultado); 	resultado = 1000  e sucesso = true

    string valor1 = null;
    int resultado;                                          Conversão falhou
    bool sucesso = int.TryParse(valor1, out resultado); 	resultado = 0  e sucesso = false

    string valor1 = "100.99"
    int resultado;                                          Conversão falhou
    bool sucesso = int.Parse(valor1, out resultado); 	    resultado = 0  e sucesso = false

    string valor1 = "999999999999999999999"
    int resultado;                                          Conversão falhou
    bool sucesso = int.Parse(valor1, out resultado); 	    resultado = 0  e sucesso = false


    . Demo

        . Adapte a classe "Program.cs" com as linhas abaixo:

            // Exemplo de conversão usando Parse, TryParse e Convert para tipos nativos em C#
            using System;

            class Program
            {
                static void Main()
                {
                    // int
                    string intStr = "123";
                    int.TryParse(intStr, out int intTryVal);

                    // long
                    string longStr = "123456789";
                    long.TryParse(longStr, out long longTryVal);

                    // short
                    string shortStr = "32000";
                    short.TryParse(shortStr, out short shortTryVal);

                    // byte
                    string byteStr = "255";
                    byte.TryParse(byteStr, out byte byteTryVal);

                    // sbyte
                    string sbyteStr = "127";
                    sbyte.TryParse(sbyteStr, out sbyte sbyteTryVal);

                    // uint
                    string uintStr = "4294967295";
                    uint.TryParse(uintStr, out uint uintTryVal);

                    // ulong
                    string ulongStr = "18446744073709551615";
                    ulong.TryParse(ulongStr, out ulong ulongTryVal);

                    // ushort
                    string ushortStr = "65535";
                    ushort.TryParse(ushortStr, out ushort ushortTryVal);

                    // float
                    string floatStr = "3.14";
                    float.TryParse(floatStr, out float floatTryVal);

                    // double
                    string doubleStr = "3.14159265359";
                    double.TryParse(doubleStr, out double doubleTryVal);

                    // decimal
                    string decimalStr = "12345.6789";
                    decimal decimalVal = decimal.Parse(decimalStr);
                    decimal.TryParse(decimalStr, out decimal decimalTryVal);

                    // bool
                    string boolStr = "true";
                    bool.TryParse(boolStr, out bool boolTryVal);

                    // char
                    string charStr = "A";
                    char.TryParse(charStr, out char charTryVal);

                    // Exibindo resultados
                    Console.WriteLine($"int:  {intTryVal}");
                    Console.WriteLine($"long:  {longTryVal}");
                    Console.WriteLine($"short:  {shortTryVal}");
                    Console.WriteLine($"byte:  {byteTryVal}");
                    Console.WriteLine($"sbyte:  {sbyteTryVal}");
                    Console.WriteLine($"uint:  {uintTryVal}");
                    Console.WriteLine($"ulong:  {ulongTryVal}");
                    Console.WriteLine($"ushort:  {ushortTryVal}");
                    Console.WriteLine($"float:  {floatTryVal}");
                    Console.WriteLine($"double:  {doubleTryVal}");
                    Console.WriteLine($"decimal:  {decimalTryVal}");
                    Console.WriteLine($"bool:  {boolTryVal}");
                    Console.WriteLine($"char:  {charTryVal}");
                }
            }

        . Execute o projeto e veja o resultado:

            dotnet run --project ./src/investimentControl

            # Saída:    
            int:  123
            long:  123456789
            short:  32000
            byte:  255
            sbyte:  127
            uint:  4294967295
            ulong:  18446744073709551615
            ushort:  65535
            float:  314
            double:  314159265359
            decimal:  123456789
            bool:  True
            char:  A

Convert
-------

    . Convert.ToInt32 é utilizado para converter outros tipos de objeto (object, bool, string, etc) em um int, 
        internamente ele utiliza int.Parse, porem adicionando a feature de retornar zero se o valor convertido 
        for null, no mais é igual ao int.Parse.

        int x = Convert.ToInt32("123");// 123
        int x = Convert.ToInt32("");//System.FormatException
        int x = Convert.ToInt32("123@");//System.FormatException
        int x = Convert.ToInt32(null);// 0

    . Sugestão: 
        
        Se você tem uma string e espera que sempre lhe retorne um inteiro (por exemplo, o retorno de uma chamada a um web service) 
        você deve utilizar int.Parse. 
        
        Se você esta fazendo leitura de dados inseridos pelo usuário, você deve usar int.TryParse que possui um melhor controle na 
        situação do usuário inserir entradas inválidas.

        Você deve utilizar Convert.ToInt32 nos mesmos casos citados acima para int.Parse porem quando o argumento não for do tipo string.

    . Demo

        . Adapte a classe "Program.cs" com as linhas abaixo:

            // Exemplo de conversão usando Parse, TryParse e Convert para tipos nativos em C#
            using System;

            class Program
            {
                static void Main()
                {
                    // int
                    string intStr = "123";
                    int intConv = Convert.ToInt32(intStr);

                    // long
                    string longStr = "123456789";
                    long longConv = Convert.ToInt64(longStr);

                    // short
                    string shortStr = "32000";
                    short shortConv = Convert.ToInt16(shortStr);

                    // byte
                    string byteStr = "255";
                    byte byteConv = Convert.ToByte(byteStr);

                    // sbyte
                    string sbyteStr = "127";
                    sbyte sbyteConv = Convert.ToSByte(sbyteStr);

                    // uint
                    string uintStr = "4294967295";
                    uint uintConv = Convert.ToUInt32(uintStr);

                    // ulong
                    string ulongStr = "18446744073709551615";
                    ulong ulongConv = Convert.ToUInt64(ulongStr);

                    // ushort
                    string ushortStr = "65535";
                    ushort ushortConv = Convert.ToUInt16(ushortStr);

                    // float
                    string floatStr = "3.14";
                    float floatConv = Convert.ToSingle(floatStr);

                    // double
                    string doubleStr = "3.14159265359";
                    double doubleConv = Convert.ToDouble(doubleStr);

                    // decimal
                    string decimalStr = "12345.6789";
                    decimal decimalConv = Convert.ToDecimal(decimalStr);

                    // bool
                    string boolStr = "true";
                    bool boolConv = Convert.ToBoolean(boolStr);

                    // char
                    string charStr = "A";
                    char charConv = Convert.ToChar(charStr);

                    // Exibindo resultados
                    Console.WriteLine($"int:  {intConv}");
                    Console.WriteLine($"long:  {longConv}");
                    Console.WriteLine($"short:  {shortConv}");
                    Console.WriteLine($"byte:  {byteConv}");
                    Console.WriteLine($"sbyte:  {sbyteConv}");
                    Console.WriteLine($"uint:  {uintConv}");
                    Console.WriteLine($"ulong:  {ulongConv}");
                    Console.WriteLine($"ushort:  {ushortConv}");
                    Console.WriteLine($"float:  {floatConv}");
                    Console.WriteLine($"double:  {doubleConv}");
                    Console.WriteLine($"decimal:  {decimalConv}");
                    Console.WriteLine($"bool:  {boolConv}");
                    Console.WriteLine($"char:  {charConv}");
                }
            }

        . Execute o projeto e veja o resultado:

            dotnet run --project ./src/investimentControl

            # Saída:    
            int:  123
            long:  123456789
            short:  32000
            byte:  255
            sbyte:  127
            uint:  4294967295
            ulong:  18446744073709551615
            ushort:  65535
            float:  314
            double:  314159265359
            decimal:  123456789
            bool:  True
            char:  A

Operadores de comparação
------------------------
   
    ==      igual
    !=      diferente
    >       Maior que
    <       Menor que
    >=
    <=

    Exemplo:

        int x = 25;

        x == 0;     // False
        x != 0;     // True
        x > 0;      // True
        x < 0;      // False

Operadores Lógicos
------------------

    &&      And
    ||      Or
    !       Not

    Exemplo:

        int x= 12;

        bool entre = ( x > 25 ) && ( x < 40 );      // False
        bool ou = ( x < 25 ) || ( x < 40 );         // True
        bool negacao = !( x < 25 );                 // False

Operadores Condicionais - IF
---------------------------    

    Exemplo 1:

        if(condition)
        {
            // code block to be executed when if condition evaluates to true
        }

    Exemplo 2:

        int x = 8;

        if ( x > 9 ) {
            Console.WriteLine("x is greater than 9!");
        } else {
            Console.WriteLine("x is less than 9!");
        }

    Exemplo 3:

        if (condicao)
            Console.log("Fim");

    Exemplo 4:

        if(condition1)
        {
            // code block to be executed when if condition1 evaluates to true
        }
        else if(condition2)
        {
            // code block to be executed when 
            //      condition1 evaluates to flase
            //      condition2 evaluates to true
        }
        else if(condition3)
        {
            // code block to be executed when 
            //      condition1 evaluates to flase
            //      condition2 evaluates to false
            //      condition3 evaluates to true
        }

    . Podemos substituir IFs por Operadores Ternários:

        int x = 10;
        int y = 20;
        int max = (x > y) ? x : y;

    . Ifnull - Operador "coalescing" 

        int y = x ?? -1;

        é o mesmo que fazer:

        int y = (x == null) ? -1 : x;

    . Demo

        . Adapte a classe "Program.cs" com as linhas abaixo:

            // Exemplo de uso de operadores de comparação em C#
            using System;

            class Program
            {
                static void Main()
                {
                    int a = 10;
                    int b = 20;

                    Console.WriteLine($"a == b: {a == b}");   // False
                    Console.WriteLine($"a != b: {a != b}");   // True
                    Console.WriteLine($"a > b: {a > b}");     // False
                    Console.WriteLine($"a < b: {a < b}");     // True
                    Console.WriteLine($"a >= b: {a >= b}");   // False
                    Console.WriteLine($"a <= b: {a <= b}");   // True

                    // Exemplo prático
                    if (a < b)
                    {
                        Console.WriteLine("a é menor que b");
                    }
                    else
                    {
                        Console.WriteLine("a não é menor que b");
                    }
                }
            }

        . Execute o projeto e veja o resultado:

            dotnet run --project ./src/investimentControl

            # Saída:    
            a  == b: False
            a != b: True
            a > b: False
            a < b: True
            a >= b: False
            a <= b: True

        . Insira as linhas abaixo na classe "Program.cs":

            using System;

            class Program
            {
                static void Main()
                {
                    var a = 10;
                    var b = 20;

                    System.Console.WriteLine($"a == b: {a == b}");
                    System.Console.WriteLine($"a != b: {a != b}");
                    System.Console.WriteLine($"a > b: {a > b}");
                    System.Console.WriteLine($"a < b: {a < b}");
                    System.Console.WriteLine($"a >= b: {a >= b}");
                    System.Console.WriteLine($"a <= b: {a <= b}");

                    // IF inserido
                    if (a < b)
                    {
                        System.Console.WriteLine("a é menor que b");
                    }
                    else if (a > b)
                    {
                        System.Console.WriteLine("a é maior que b");
                    }
                    else
                    {
                        System.Console.WriteLine("a é igual a b");
                    }
                }
            }

        . Execute o projeto e veja o resultado:

            dotnet run --project ./src/investimentControl

            # Saída:    
            a == b: False
            a != b: True
            a > b: False
            a < b: True
            a >= b: False
            a <= b: True
            a é menor que b

        . Insira as linhas abaixo na classe "Program.cs":

            // Exemplo de conversão usando Parse, TryParse e Convert para tipos nativos em C#
            using System;

            class Program
            {
                static void Main()
                {
                    var a = 10;
                    var b = 20;

                    System.Console.WriteLine($"a == b: {a == b}");
                    System.Console.WriteLine($"a != b: {a != b}");
                    System.Console.WriteLine($"a > b: {a > b}");
                    System.Console.WriteLine($"a < b: {a < b}");
                    System.Console.WriteLine($"a >= b: {a >= b}");
                    System.Console.WriteLine($"a <= b: {a <= b}");

                    // linhas inseridas
                    // Operadores lógicos
                    bool resultadoAnd = (a > 5) && (b > 15);      // True && True => True
                    bool resultadoOr = (a > 15) || (b > 15);      // False || True => True
                    bool resultadoNot = !(a == b);                // !False => True

                    Console.WriteLine($"(a > 5) && (b > 15): {resultadoAnd}");
                    Console.WriteLine($"(a > 15) || (b > 15): {resultadoOr}");
                    Console.WriteLine($"!(a == b): {resultadoNot}");
                    // Fim das linhas inseridas


                    // If alterado
                    // Exemplo prático
                    if ((a < b) && (a > 0))
                    {
                        Console.WriteLine("a é menor que b E maior que zero");
                    }
                    else
                    {
                        Console.WriteLine("a não atende à condição composta");
                    }
                    // Fim do exemplo prático


                }
            }

        . Execute o projeto e veja o resultado:

            dotnet run --project ./src/investimentControl

            # Saída:    
            a == b: False
            a != b: True
            a > b: False
            a < b: True
            a >= b: False
            a <= b: True
            (a > 5) && (b > 15): True
            (a > 15) || (b > 15): True
            !(a == b): True
            a é menor que b E maior que zero

Switch
------

    int x = 10;

    switch (x)
    { 
        case 5:
            Console.WriteLine("Value of x is 5");
            break;
        case 10:
            Console.WriteLine("Value of x is 10");
            break;
        case 15:
            Console.WriteLine("Value of x is 15");
            break;
        default:
            Console.WriteLine("Unknown value");
            break;
    }

    . The switch cases without break, return, or goto statement or with the same constant values would give a compile-time error.

For
---
// PAREI AQUI
    Exemplo 1

        for(int i = 0; i < 10; i++)
        {
            Console.WriteLine("Value of i: {0}", i);
        }

    Exemplo 2

        for(int i = 0; i < 10; i++)
            Console.WriteLine("Value of i: {0}", i);

    Exemplo 3

        int i = 0;

        for(;;)
        {
            if (i < 10)
            {
                Console.WriteLine("Value of i: {0}", i);
                i++;
            }
            else
                break;                      // Interrompe o loop imediatamente
        }

    Exemplo 4

        for(int i = 10; i > 0; i--)
        {
            Console.WriteLine("Value of i: {0}", i);
        }

    Exemplo 5

        for (int i = 0; i < 5; i++)
        {
            if (i == 2)
                continue;                   // Pula o restante do bloco e passa para a próxima volta

            Console.WriteLine($"i: {i}");
        }

        // Saída
        i: 0
        i: 1
        i: 3
        i: 4

    . Existe outros tipos de loop que veremos mais a frente, como:

        foreach - Veremos em "Arrays - Acessando os elementos através de um foreach"

While
-----

    Exemplo 1

        int i = 0; // initialization

        while (i < 10) // condition
        {
            Console.WriteLine("i = {0}", i);

            i++; // increment
        }

    Exemplo 2

        int i = 0;

        while (true)
        {
            Console.WriteLine("i = {0}", i);

            i++;

            if (i > 10)
                break;              // Podemos utilizar break para sair do "while"
        }

    Exemplo 3

        int i = 1;

        while (i < 20) {
            i++;

            if ((i % 2) != 0)
                continue;           // Podemos utilizar continue para pular para a linha logo abaixo do "while..."

            Console.WriteLine("i = " + i);
        }

C# Class
--------

    . Escopo de Programa

        using System;               // Importações

        namespace HelloWorld;        // Equivalente aos pacotes/divisões lógica

        [public/private/protected/internal/file] class Program           // Definição da classe
        {
            public static void Main(string args)     // Método
            {
                Console.WriteLine(args);
            }
        }


    . Demo

        . Crie a classe "HelloWorld.cs" com o código abaixo na pasta raiz do projeto "helloWorld"

            namespace helloWorld;

            public class HelloWorld
            {
                public static void Hello(string args)
                {
                    Console.WriteLine(args);
                }
            }

        . Altere o Program.cs da solution pelo conteúdo abaixo:

            using helloWorld;       // Linha inserida

            HelloWorld.Hello("Hello, World!" );      // Linha inserida

        . Execute o projeto:

            # Da pasta da solution
            dotnet run --project ./helloWorld

    . "internal class"
    
        . A classe só pode ser acessada dentro do mesmo assembly (projeto/compilação).

        . É o modificador de acesso padrão se nenhum for especificado em arquivos de nível de 
            namespace (ou seja, fora de classes aninhadas).

        . Exemplo:

            // Arquivo: MinhaClasse.cs
            internal class MinhaClasse
            {
                public void Metodo() => Console.WriteLine("Método chamado");
            }

            // Dentro do mesmo projeto
            var obj = new MinhaClasse(); // OK

            // Em outro projeto que referencia este (ex: biblioteca DLL)
            var obj = new MinhaClasse(); // ERRO: 'MinhaClasse' é inacessível devido ao seu nível de proteção

    . class (sem modificador explícito)

        . Por padrão, classes de nível superior (não aninhadas) sem modificador são internal.

        . Então, "class MinhaClasse" é o mesmo que "internal class MinhaClasse", se estiver fora de outra classe

        . Exemplo:

            // Isso é equivalente a "internal class MinhaClasse"
            class MinhaClasse
            {
                public void Metodo() => Console.WriteLine("Sem modificador: ainda é internal");
            }

    . Resumo

        Declaração         Visibilidade padrão     Acessível em outros projetos?
        ----------         -------------------     ----------------------------
        `internal class`   Interna                     ❌ Não                       
        `class`            Interna                     ❌ Não                       
        `public class`     Pública                     ✅ Sim                       

    . Sugestão:

        . Quando usar internal explicitamente?

            . Quando você quer deixar claro que a classe é apenas para uso interno, mesmo que isso já seja o comportamento padrão.

            . Para maior clareza e manutenção do código, especialmente em bibliotecas.

            . Exemplo:

                // Projeto A - Biblioteca
                public class ClassePublica
                {
                    public void Metodo() => Console.WriteLine("Sou pública!");
                }

                internal class ClasseInterna
                {
                    public void Metodo() => Console.WriteLine("Sou interna!");
                }

                // Projeto B - App consumidor
                var obj1 = new ClassePublica(); // OK
                var obj2 = new ClasseInterna(); // ERRO: ClasseInterna é inacessível

        . Crie o nome das namespace levemente parecido com a pasta do projeto, por exemplo:

            namespace Tutorial.Calculo
            {
                ...
            }

            . Coloque a classe na pasta [Nome do projeto].Tutorial.Calculo. Se ambos forem iguais dará erro durante a compilação, 
                pois não encontrará as referências das classes nas packages/namespace.


    // Insirar detalhes sobre "partial class"

    . No vSCode algumas atalhos (Snippet) estão disponíveis para facilitar na implementação do código:

        prop + [Ctrl + Space]

            public int MyProperty { get; set; }

        propfull + [Ctrl + Space]

            private int _myVar;
            public int MyProperty
            {
                get { return _myVar; }
                set { _myVar = value; }
            }

        ctor  + [Ctrl + Space]  - Implementa o construtor

            public Calculadora(Parameters)
            {
                
            }

        for  + [Ctrl + Space]  -  monta um laço for padrão;

        if + [Ctrl + Space]  -  monta uma estrutura if padrão;

        cw + [Ctrl + Space]  -  chama um Console.WriteLine();

        do + [Ctrl + Space]  -  cria um bloco do/while;

        equals + [Ctrl + Space]  -  sobrescreve o método equals de Object;

        foreach + [Ctrl + Space]  -  monta um laço foreach padrão;

        try + [Ctrl + Space]  -  cria um bloco try/catch padrão;

        while + [Ctrl + Space]  -  cria um bloco while padrão;

        Shortcut	Description
        --------    -----------
        class	    Creates a class
        ctor	    constructor
        cw	        Console.WriteLine
        do	        do...while loop
        else	    else statement
        enum	    Creates an enum
        fact	    Creates a xunit test method
        for	        for loop
        foreach	    foreach statement
        guid	    Creates a new instance of the Guid structure
        if	        if statement
        ifd	        #if
        interface	Creates an interface
        mbox	    MessageBox.Show
        namespace	Creates a namespace
        prop	    An automatically implemented property
        propfull	Property with backing field
        region	    #region
        svm	void    Main()
        switch	    switch statement
        try	        try...catch
        tryf	    try...finally
        using	    using statement
        while	    while loop

    . Template de Exemplo

        using System;                       // 1. Importação das bibliotecas. Equivalente aos imports do java

        namespace SysUtil.Tutorial          // 2. Área de configuração para divisão lógica das classes, equivalente as packages do java
        {
            // 3. Modificador de acesso
            public class MyClass    // 4. Nome da classe
            {
                public string  _myField = string.Empty;  // 5. Campo da classe
                private string _firstname = "";

                public MyClass()                        // 6. Construtor
                {
                }

                public void MyMethod(int parameter1, string parameter2)     // 7. Método/Função
                {
                    Console.WriteLine("First Parameter {0}, second parameter {1}", 
                                                                parameter1, parameter2);
                }

                public int MyAutoImplementedProperty { get; set; }      // 8. Auto-implemented property

                private int _myPropertyVar;                             // 9. Campo
                
                public int MyProperty                                   // 10. Propriedade
                {
                    get { return _myPropertyVar; }
                    set { _myPropertyVar = value; }
                } 
            }
        }

    . Padronizações
            
        . Nomes campo das classes utilizam "_" como padrão para definir o nome

            Exemplo:

                namespace demo.myclass;

                public class MyClass    
                {
                    private string  _myField = string.Empty;  
                                    ^
                                    +-------------------+
                    public MyClass( string myField )    |                    
                    {   +-------------------------------+
                        |
                        _myField = myField;
                    }
                }

        . Campos são criados como "private"

            private string  _myField = string.Empty;  

    . Delegate

        . O delegate é um tipo que representa uma referência para métodos com uma determinada assinatura. Ele funciona como um 
            "ponteiro de função seguro", permitindo armazenar e chamar métodos dinamicamente, inclusive métodos estáticos ou de 
            instância.

        . Exemplo:

            namespace bankAccount;

            public class BankAccount
            {
                // 1. declaração do delegate especificando o tipo de retorno e os parâmetros
                public delegate string StringConverter(string input);

                public BankAccount()
                {

                }

                // 2.1. Declara os métodos com a mesma assinatura do delegate
                public string LowerCaseAccountName(string input)
                {
                    if (string.IsNullOrEmpty(input))
                    {
                        return string.Empty;
                    }

                    return input.ToLower();
                }

                // 2.2. Declara os métodos com a mesma assinatura do delegate
                public string UpperCaseAccountName(string input)
                {
                    if (string.IsNullOrEmpty(input))
                    {
                        return string.Empty;
                    }

                    return input.ToUpper();
                }

                // 2.3. Declara os métodos com a mesma assinatura do delegate, detalhe método "static"
                public static string TitleCaseAccountName( string input)
                {
                    if (string.IsNullOrEmpty(input))
                    {
                        return string.Empty;
                    }

                    return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(input.ToLower());
                }

                public void DoExampleDelegate(string input)
                {
                    //  3.1. Associa os métodos compatíveis ao delegate.
                    StringConverter converter1 = new(LowerCaseAccountName);
                    StringConverter converter2 = new(UpperCaseAccountName);
                                            //    |
                                            //    +----> o "new" é opcional, poderiamos declarar referenciando diretamente ao método
                                            //                  StringConverter converter1 = LowerCaseAccountName;

                    //  3.2. Associa os métodos compatíveis ao delegate. Sem o "new()"
                    StringConverter converter3 = TitleCaseAccountName;


                    // 4. Faz a chamada do delegate, que executa o método da classe associada.
                    var lower = converter1(input);
                    var upper = converter2(input);
                    var title = converter3(input);

                    Console.WriteLine($"Lowercase: {lower}");
                    Console.WriteLine($"Uppercase: {upper}");
                    Console.WriteLine($"Title: {title}");
                }

            }


            // Chamada
            BankAccount account = new();

            account.DoExampleDelegate("wiLLiam chArLie aNTONY");

        . Podemos passar um delegate como parâmetro para um método em C#. Basta declarar o parâmetro do tipo do delegate desejado

        . Exemplo

            // 1. declaração do delegate especificando o tipo de retorno e os parâmetros
            public delegate string StringConverter(string input);

            // 2.1. Declara os métodos com a mesma assinatura do delegate
            public string LowerCaseAccountName(string input)
            {
                if (string.IsNullOrEmpty(input))
                {
                    return string.Empty;
                }

                return input.ToLower();
            }

            ...

            // 3. Declaração do método com o delegate na sua assinatura
            public void DoDelegate( StringConverter converter, string input)
            {
                if (converter == null)
                {
                    throw new ArgumentNullException(nameof(converter), "Converter cannot be null");
                }

                string result = converter(input);
                Console.WriteLine($"Converted Result: {result}");
            }


            // 4. Chamada do método
            DoDelegate(LowerCaseAccountName, input);

        . Podemos trabalhar com delegate usando métodos anônimos em C# de duas formas: utilizando a palavra-chave 
            delegate ou expressões lambda.

            . Exemplo Métodos Anônimos

                // 1.1 Declaração do objeto função delegate
                StringConverter LowerCaseConverter = delegate (string input)
                {
                    if (string.IsNullOrEmpty(input))
                    {
                        return string.Empty;
                    }
                    return input.ToLower();
                };

                // 1.2 Declaração do objeto função delegate
                StringConverter UpperCaseConverter = delegate (string input)
                {
                    if (string.IsNullOrEmpty(input))
                    {
                        return string.Empty;
                    }
                    return input.ToUpper();
                };

                // 2. Chamada do objeto delegate
                Console.WriteLine(LowerCaseConverter(input));
                Console.WriteLine(UpperCaseConverter(input));

            . Exemplo Expressões Lambda

                // 1. Declaração dos objetos função delegate
                StringConverter LowerCaseConverter = (string input) => input.ToLower();
                StringConverter UpperCaseConverter = (string input) => input.ToUpper();

                // 2. Chamada dos objetos delegate
                Console.WriteLine(LowerCaseConverter(input));
                Console.WriteLine(UpperCaseConverter(input));

    . Lambda

        . Funções lambda em C# são funções anônimas, ou seja, funções sem nome, que podem ser usadas para criar 
            pequenos trechos de código de forma concisa. Elas são muito utilizadas com delegates, eventos, LINQ e 
            métodos que recebem funções como parâmetro.

        . Sintaxe

            (parâmetros) => expressão_ou_bloco

        . Se esquecer de usar {} após o =>, só é permitido uma única expressão (sem ponto e vírgula). Para múltiplas 
            instruções, sempre use o bloco { ... }.

        . Exemplo Simples - Utiliza "=>" para indicar o código que será executado

            Func<int, int, int> soma = (a, b) => a + b;
            int resultado = soma(2, 3); // resultado = 5

        . Exemplo em bloco - Utiliza "=" caracterizar o nome da função e "{}" para cercar o corpo da função

            Action<string> imprimir = (texto) => 
            {
                Console.WriteLine(texto.ToUpper());
            };
            imprimir("lambda em C#");

        . Parâmetros das funções lambda

            . Observe a passagem de parâmetros para a função lambda

                Func<int, int, int> soma = (a,  b) => a + b
                                            -----
                                              |
                                              V
                                            Params

                Action<string> imprimir = (texto) => {...}
                                         -------
                                            |
                                            V
                                          Param 

        . Funções lambda podem ser declaradas de diferentes maneiras, dependendo do contexto e do tipo de 
            delegate utilizado. Os tipos mais comuns são:

            . Funções explicitas:

                double USDToEuro(double dollars) => exchangeRate * dollars;

            . Propriedades de classes:

                public string FirstName {
                    get => _firstname;              // é equivalente a get { return _firstname; }
                    set => _firstname = value;      // é equivalente a set { _firstname = value; }
                }

            . No construtor da classe - Se o construtor possuir mais de uma linha de código ou expressão não podemos usar o "=>"

                class Calculadora
                {
                    public int Numero1 = 100;
                    public int Numero2 = 33;

                    public Calculadora() => Numero1 = Numero1 + Numero2;
                }

            . Em métodos de classes

                class Calculadora
                {
                    // Exibe um texto no console
                    public void Exibir() => WriteLine("Olá, Macoratti");

                    // Invoca outro método
                    public void Invocar() => Exibir();

                    // Possui dois parâmetros e retorna a soma mais 100
                    // Não precisa usar Return com EBM
                    public int Somar(int a, int b) => a + b + 100;
                    
                    // Método tem dois parâmetros e retorna um valor de acordo
                    // com a condição do operador ternário
                    public int Comparar(int a, int b) => a == b ? 100 : 200;
                }

            . Usando delegates genéricos (Func, Action, Predicate)

                . Func: Representa um método que retorna um valor

                             Tipos dos parâmetros
                            +-------------------+
                            |                   |
                            |                   V
                        ---------               ----
                    Func<int, int, int> soma = (a, b) => a + b;
                                   ---                   -----
                                    |                       ^
                                    |                       |
                                    +-----------------------+
                                        Tipo do retorno

                    int resultado = soma(2, 3); // resultado = 5

                . Action: Representa um método que não retorna valor (void)

                    Action<string> imprimir = texto => Console.WriteLine(texto);
                    imprimir("Olá, mundo!");

                . Predicate: Representa um método que retorna bool e recebe um parâmetro.

                    Predicate<int> ehPar = n => n % 2 == 0;
                    bool resultado = ehPar(4); // true

            . Usando delegates personalizados - Podemos criar seu próprio tipo delegate e atribuir uma função lambda a ele:

                public delegate double Operacao(double x, double y);

                Operacao multiplicar = (a, b) => a * b;
                double resultado = multiplicar(2, 3); // resultado = 6

            . Como parâmetro de métodos - Podemos passar uma função lambda diretamente como argumento para métodos que 
                                            aceitam delegates:

                List<int> numeros = new List<int> { 1, 2, 3, 4, 5 };
                var pares = numeros.FindAll(n => n % 2 == 0); // Lambda como Predicate<int>
                                            |
                                            V
                    Representa cada elemento da lista numeros que o método FindAll percorrerá

    . Propriedades podem ser declaradas de duas formas:

        . Simplificada - Quando não existe necessidade de nenhuma lógica/regra ( vide item 8. Auto-implemented property )

            public int MyAutoImplementedProperty { get; set; }

        . Completa - Quando a necessidade de alguma lógica extra, por exemplo:

            private int _myPropertyVar;

            public int MyProperty
            {
                get {
                    return _myPropertyVar / 2;
                }

                set {
                    if (value > 100)
                        _myPropertyVar = 100;
                    else
                        _myPropertyVar = value; ;
                }
            }

            // ou utilizando Lambda

            public class MyClass
            {
                private string _firstname = "";

                public string FirstName {
                    get => _firstname;              // é equivalente a get { return _firstname; }
                    set => _firstname = value;      // é equivalente a set { _firstname = value; }
                }
            }

    . Modificador de acesso "static"

        . Podemos acessar membros estáticos diretamente pela classe, sem precisar criar um objeto.

        . Eles compartilham o mesmo valor para todas as instâncias da classe (no caso de campos/propriedades).

        . São úteis para funcionalidades que não dependem de dados específicos de um objeto.    

        . Exemplo

            public class Calculadora
            {
                private int a;
                private int b;

                public Calculadora( int a, int b)
                {
                    a = a;
                    b = b;
                }
                public static int Contador { get; set; } // Propriedade estática

                public static int Somar()
                {
                    this.Somar(a,b);
                }

                public static int Somar(int a, int b)    // Método estático
                {
                    return a + b;
                }
            }

            // Uso:
            int resultado = Calculadora.Somar(2, 3);
            Calculadora.Contador = 10;

    . Podemos instânciar das seguintes formas:

        . Exemplos

            Calculadora calc = new Calculadora(10, 10);

            int m = calc.somar();

            ou

            Calculadora calc = new();

            calc.somar(10,20);

            ou

            // IMPORTANTE: Para se criar os objetos como abaixo, a classe é obrigada ter um construtor sem parâmetros. 
            //              Pois na parte "new BankAccount(){...}" o construtor que está
            //              sendo chamado é o construtor sem parâmetros. Podemos criar construtores com parâmetros, mas é obrigatório sem parâmetros.
            // IMPORTANTE: Para realizar a criação do objeto como abaixo também é necessário existir os respectivos métodos Getter e Setter para
            //              cada item informado dentro das "{}"

            using System;

            namespace bankAccount;

            public class BankAccount
            {
                // métodos Getter e Setter para cada item informado dentro dos parenteses "new BankAccount() { AccountName = "John Doe", AccountNumber = 123456 };"
                public string? AccountName { get; set; }

                public int AccountNumber { get; set; }

                public BankAccount()    // 1. Obrigatório se formos criar o objeto "new BankAccount(){...}"
                {

                }

                public BankAccount(string accountName, int accountNumber)
                {
                    AccountName = accountName;
                    AccountNumber = accountNumber;
                }
                public void ShowAccountDetails()
                {
                    Console.WriteLine($"Account Name: {AccountName}");
                    Console.WriteLine($"Account Number: {AccountNumber}");
                }

            }


            // Uso
            BankAccount account = new BankAccount() { AccountName = "John Doe", AccountNumber = 123456 };
            account.ShowAccountDetails();

            ou

            . Usando o tipo do objeto de forma anônima. Nesse caso não se trata de classe e não 
                fazemos mensão nenhuma a qq classe, usando o tipo "var"

                var student = new { Id = 1, Name = "MARCO ANTONIO", LastName = "SILVA", address = new { Id = 1, StreetName = "RUA CARIOBA 360", City = "SÃO PAULO", State = "SP", ZipCode = "02423-100" }  };

                System.Console.WriteLine( student.Id );
                System.Console.WriteLine( student.Name );
                System.Console.WriteLine( student.Address.ToString());

    . Podemos deixar os parâmetros dos métodos opcionais. Basta na assinatura do método dar um valor para o parâmetro:

        . Sintaxe:

            public int soma( int a, int b, bool formata = false );

        . Dessa forma se houver o uso deste método somente com dois parâmetros não dará erro.

        . Exemplo

            public void ExibirMensagem(string mensagem, int vezes = 1)
            {
                for (int i = 0; i < vezes; i++)
                {
                    Console.WriteLine(mensagem);
                }
            }

            // Uso:
            ExibirMensagem("Olá!");         // Exibe uma vez
            ExibirMensagem("Oi!", 3);       // Exibe três vezes

    . Chamada de método com argumentos nomeados 

        // Chamada usando argumentos nomeados:
        ExibirMensagem(vezes: 3, mensagem: "Olá, mundo!");

    . Usando in, out e ref nos parâmetros dos métodos:

        . "ref"     - O parâmetro é passado por referência e pode ser lido e modificado dentro do método

            . Pré-requisito:    A variável deve ser inicializada antes da chamada.

            . Uso comum:        Quando você quer que o método modifique o valor original da variável.

            . Exemplo

                void Dobrar(ref int valor) {
                    valor *= 2;
                }

                int numero = 5;
                Dobrar(ref numero);  // numero agora é 10

        . "in"      - é usado para indicar que o parâmetro passado NÃO PODE SER modificado pelo método.

            . Pré-requisito: A variável deve estar inicializada.

            . Uso comum: Para evitar cópias caras de estruturas grandes (como structs), mas garantindo imutabilidade.

            Exemplo

                void Mostrar(in int valor) {
                    Console.WriteLine(valor);
                    // valor = 10; // Erro: não pode ser modificado
                }

                int numero = 42;
                Mostrar(in numero);

        . "out"     - O parâmetro é passado por referência, mas serve apenas para saída de dados.

            . Pré-requisito:    A variável não precisa estar inicializada antes da chamada, mas o método deve atribuir um valor a ela.

            . Uso comum:        Para retornar múltiplos valores de um método.

            . Exemplo

                void CriarUsuario(out string nome, out int idade) {
                    nome = "Maria";
                    idade = 30;
                }

                string nomeUsuario;
                int idadeUsuario;
                CriarUsuario(out nomeUsuario, out idadeUsuario);

            . Resumo

                Palavra-chave   Precisa inicializar antes?  Pode ser lido no método?	Pode ser modificado no método?	Obrigatório atribuir valor no método?
                -------------   --------------------------  ------------------------    ------------------------------  -------------------------------------

                ref	            Sim	                        Sim	                        Sim	                            Não
                out	            Não	                        Não*	                    Sim	                            Sim
                in	            Sim	                        Sim	                        Não	                            Não

                *Com out, o valor só pode ser lido após ser atribuído dentro do método.

    . Quantidade indefinida de parâmetros:

        . É possível criar métodos que aceitam um número indefinido de parâmetros usando a palavra-chave "params". O 
            parâmetro marcado com params deve ser o último da lista e permite passar zero ou mais argumentos do tipo 
            especificado (ou um array desse tipo).

            public int Somar(params int[] numeros)
            {
                int total = 0;
                foreach (int n in numeros)
                    total += n;
                return total;
            }

            // Uso:
            int resultado1 = Somar(1, 2, 3);        // resultado1 = 6
            int resultado2 = Somar(10, 20);         // resultado2 = 30
            int resultado3 = Somar();               // resultado3 = 0

        . Conseguimos passar parâmetros de tipos diferentes para métodos com número indefinido de parâmetros se o 
            tipo do parâmetro for object (ou outro tipo base comum).

            public void ExibirValores(params object[] valores)
            {
                foreach (var valor in valores)
                    Console.WriteLine(valor);
            }

            // Uso:
            ExibirValores(1, "texto", 3.14, true);

    . Inheritance/Herença

        . Na programação orientada a objetos, herança é um conceito que permite que uma classe (chamada de classe 
            derivada ou filha) herde atributos e métodos de outra classe (chamada de classe base ou pai).

        . Com herança, a classe derivada pode:

            . Utilizar membros (métodos, propriedades, campos) da classe base.
            
            . Adicionar novos membros.
            
            . Sobrescrever métodos da classe base para alterar ou especializar comportamentos.

        . Exemplo

            // Classe Base - Classe pai
            using System;
            using System.Globalization;

            namespace bankAccount;

            public class BankAccount
            {
                private string _customerName;
                private int _accountNumber;
                private double _accountBalance;

                public BankAccount(string customerName, int accountNumber,
                double accountBalance)
                {
                    _customerName = customerName;
                    _accountNumber = accountNumber;
                    _accountBalance = accountBalance;
                }

                public double AccountBalance
                {
                    get => _accountBalance;
                    set => _accountBalance = value;
                }

                public string CustomerName
                {
                    get => _customerName;
                    set => _customerName = value;
                }

                public int AccountNumber
                {
                    get => _accountNumber;
                    set => _accountNumber = value;
                }

                public void DisplayName()
                {
                    Console.WriteLine($"Customer name is {CustomerName}");
                }
            }



            // Classe Derivada - Classe filha
            namespace bankAccount;
                                            //  +------------> A classe ClasseDerivada herda de ClasseBase.
                                            //  |
            internal class SavingsAccount : BankAccount
            {
                private double _interestRate;
                public double InterestRate
                {
                    get => _interestRate;
                    set => _interestRate = value;
                }
                public SavingsAccount(string accountName, int accountNumber, double accountBalance, double interestRate)
                    : base(accountName, accountNumber, accountBalance)  
                    //  |
                    //  +------> O construtor da ClasseDerivada recebe os parâmetro nome e usa : base(accountName, accountNumber, accountBalance) para 
                    //              passar esse parâmetro para o construtor da classe base.    
                {
                    _interestRate = interestRate;
                }

                public double MonthlyInterest => _interestRate * AccountBalance / 12;


            }



            // Chamada da classe
            SavingsAccount savingsAccount = new SavingsAccount("Jane Smith", 654321, 1000.0,  0.05 );

            savingsAccount.DisplayName();

            Console.WriteLine($"Account Name is {savingsAccount.CustomerName}");

        . Pontos de atenção - Use ": base(...)" quando:

            . A classe base não tem um construtor sem parâmetros.

            . Você precisa passar argumentos específicos para o construtor da classe base.

            . Quer tornar explícito qual construtor está sendo chamado na herança.

        . Para que possamos criar os objetos fornecendo o nome de cada parâmetro precisamos adicionar os construtores sem parâmetros, 
            tanto na classe base, quanto na classe derivada.

            //                                          +------------>  Para realizar a declaração do obj dessa forma precisamos
            //                                          |               ter o construtor sem parâmetros, tanto na SuperClass, quanto 
            // Chamada da classe            |--------------------|      na SubClass
            SavingsAccount savingsAccount = new SavingsAccount(){
                CustomerName = "Joseph Murdock",
                AccountNumber = 579796,
                AccountBalance = 100.0,
                InterestRate = 0.03
            };


            . Exemplo:

                // Adicione o construtor abaixo na classe base
                ...
                public class BankAccount
                {
                    private string _customerName;
                    private int _accountNumber;
                    private double _accountBalance;

                    // Construtor inserido
                    public BankAccount()
                    {
                        _customerName = "";
                        _accountNumber = 0;
                        _accountBalance = 0.0;
                    }

                    ...
                }


                // Adicone o construtor abaixo na classe derivada
                namespace bankAccount;

                internal class SavingsAccount : BankAccount
                {
                    ...

                    public SavingsAccount(string accountName, int accountNumber, double accountBalance, double interestRate)
                        : base(accountName, accountNumber, accountBalance)
                    {
                        _interestRate = interestRate;
                    }
                  
                    // Construtor inserido
                    public SavingsAccount() : base()
                    {

                    }
                  
                    public double MonthlyInterest => _interestRate * AccountBalance / 12;
                }




                // Altere a chamada, substituindo a criação do objeto por parâmetros, pelo abaixo:

                // Criação inserida
                SavingsAccount savingsAccount = new SavingsAccount(){
                    CustomerName = "Joseph Murdock",
                    AccountNumber = 579796,
                    AccountBalance = 100.0,
                    InterestRate = 0.03
                };

                // Criação eliminada
                // SavingsAccount savingsAccount = new SavingsAccount("Jane Smith", 654321, 1000.0,  0.05 );

                savingsAccount.DisplayName();

                Console.WriteLine($"Account Name is {savingsAccount.CustomerName}");

        . Sobrescrição de métodos

            . Regras

                . Marque o método na classe base com o modificador virtual para permitir sobrescrita.

                . Use o modificador override na classe derivada para indicar que está sobrescrevendo o método.

                . O método sobrescrito deve ter a mesma assinatura (tipo de retorno, nome e parâmetros) do método na classe base.

                . O nível de acesso do método sobrescrito deve ser igual ou mais permissivo que o da classe base.

                . Métodos estáticos não podem ser sobrescritos.

                . Não é possível sobrescrever métodos marcados como static, private ou sealed.

                . Se quiser impedir que uma classe derivada sobrescreva novamente o método, use sealed override.

                . Para chamar a implementação da classe base dentro do método sobrescrito, utilize base.NomeDoMetodo().

                . Métodos abstratos (abstract) obrigam a sobrescrita em classes derivadas não abstratas.

            . Exemplo:


                // Classe base
                public class BankAccount
                {
                    ...

                    // 1. Inclusão do modificador "virtual" no método da classe base
                    public virtual void DisplayName()
                    {
                        Console.WriteLine($"Base -> Customer name is {CustomerName}");
                    }
                }


                // Classe derivada
                public class SavingsAccount : BankAccount
                {

                    ...

                    // 2. Inserção do modificador "override" no métod da classe derivada
                    public override void DisplayName()
                    {
                        Console.WriteLine($"Derivada -> Customer name is {CustomerName}");

                        // Chamando o método da classe base
                        base.DisplayName();
                    }
                }


                // Chamada da classe
                SavingsAccount savingsAccount = new SavingsAccount("Jane Smith", 654321, 1000.0,  0.05 );

                BankAccount bankAccount = new BankAccount(){ AccountName: "John Dexter", AccountNumber: 171066, AccountBalance: 10, InterestRate: 3.5 };

                bankAccount.DisplayName();
                savingsAccount.DisplayName();

    . Classes Abstratas

        . São classes que não podem ser instanciadas diretamente e servem como base para outras classes. Elas podem conter 
            métodos abstratos (sem implementação) e métodos concretos (com implementação). Classes derivadas devem implementar 
            os métodos abstratos.

            . Classes abstratas servem como modelo para outras classes.

            . Não podem ser instanciadas diretamente.

            . Podem ter métodos abstratos e concretos.

            . Classes derivadas devem implementar os métodos abstratos.

        . Exemplo:

            // Classe abstrata
            public abstract class BankAccount
            {
                public string CustomerName { get; set; }
                public int AccountNumber { get; set; }
                public double AccountBalance { get; set; }

                // Método abstrato: deve ser implementado pelas classes derivadas
                public abstract void DisplayName();

                // Método concreto: pode ser usado ou sobrescrito pelas derivadas
                public void ShowBalance()
                {
                    Console.WriteLine($"Saldo: {AccountBalance:C}");
                }
            }

            // Classe derivada
            public class SavingsAccount : BankAccount
            {
                public double InterestRate { get; set; }

                // Implementação obrigatória do método abstrato
                public override void DisplayName()
                {
                    Console.WriteLine($"Conta Poupança de {CustomerName}");
                }
            }

            // Uso
            SavingsAccount conta = new SavingsAccount
            {
                CustomerName = "Maria",
                AccountNumber = 123,
                AccountBalance = 1000.0,
                InterestRate = 0.05
            };

            conta.DisplayName();   // Saída: Conta Poupança de Maria
            conta.ShowBalance();   // Saída: Saldo: R$ 1.000,00

        . Métodos virtuais em classes abstratadas

            .  Métodos virtuais em classes abstratas funcionam como em classes comuns: eles têm uma implementação padrão, 
                mas podem ser sobrescritos (override) em classes derivadas para alterar ou especializar o comportamento. 
                Diferente de métodos abstratos (que não têm corpo), métodos virtuais podem ser usados diretamente ou 
                sobrescritos.

                . Métodos virtuais em classes abstratas têm implementação padrão e podem ser sobrescritos.

                . Métodos abstratos obrigam a sobrescrita e não têm implementação na classe base.

                . Você pode misturar membros abstratos e virtuais em uma mesma classe abstrata.


            . Exemplo:

                // Classe abstrata com método virtual
                public abstract class BankAccount
                {
                    public string CustomerName { get; set; }
                    public int AccountNumber { get; set; }
                    public double AccountBalance { get; set; }

                    // Método abstrato: deve ser implementado pelas derivadas
                    public abstract void DisplayName();

                    // Método virtual: pode ser sobrescrito, mas já tem implementação padrão
                    public virtual void ShowAccountType()
                    {
                        Console.WriteLine("Tipo de conta: Conta Bancária");
                    }
                }

                // Classe derivada sobrescrevendo o método virtual
                public class SavingsAccount : BankAccount
                {
                    public double InterestRate { get; set; }

                    public override void DisplayName()
                    {
                        Console.WriteLine($"Conta Poupança de {CustomerName}");
                    }

                    // Sobrescrevendo o método virtual
                    public override void ShowAccountType()
                    {
                        Console.WriteLine("Tipo de conta: Conta Poupança");
                    }
                }

                // Uso
                SavingsAccount conta = new SavingsAccount
                {
                    CustomerName = "Maria",
                    AccountNumber = 123,
                    AccountBalance = 1000.0,
                    InterestRate = 0.05
                };

                conta.DisplayName();      // Saída: Conta Poupança de Maria
                conta.ShowAccountType();  // Saída: Tipo de conta: Conta Poupança

    . Interface

        . Em C#, interfaces definem um contrato que especifica quais métodos, propriedades, eventos ou indexadores uma 
            classe deve implementar, mas não fornecem implementação. Uma classe pode implementar várias interfaces, e 
            ao implementar uma interface, a classe é obrigada a fornecer a implementação de todos os membros definidos 
            nela.

        . Funcionamento:

            . Uma interface é declarada com a palavra-chave interface.

            . Não possui implementação, apenas a assinatura dos membros.

            . Uma classe implementa uma interface usando o símbolo :.

            . Uma classe pode implementar múltiplas interfaces.

            . Interfaces não podem declarar campos, ao invés disso podemos declarar propriedades

                public interface IAccount
                {
                    
                    // string _customerName;    |   Ao invés de declarar campos, 
                    // int _accountNumber;      |---------------+  declare propriedades
                    // int _accountBalance;     |               |
                                                                |
                    string CustomerName { get; set; }           |
                    int AccountNumber { get; set; }     <-------+
                    double AccountBalance { get; set; }

                    void DisplayName();
                }


            . Interfaces são usadas para garantir que diferentes classes tenham um conjunto comum de métodos/propriedades.    

        . Exemplo:

            // Definição da interface
            public interface IAccount
            {
                string CustomerName { get; set; }
                int AccountNumber { get; set; }
                double AccountBalance { get; set; }

                void DisplayName();
            }

            // Implementação da interface na classe BankAccount
            public class BankAccount : IAccount
            {
                public string CustomerName { get; set; }
                public int AccountNumber { get; set; }
                public double AccountBalance { get; set; }

                public virtual void DisplayName()
                {
                    Console.WriteLine($"Conta bancária de {CustomerName}");
                }
            }

            // Classe derivada que herda de BankAccount e pode sobrescrever métodos
            public class SavingsAccount : BankAccount
            {
                public double InterestRate { get; set; }

                public override void DisplayName()
                {
                    Console.WriteLine($"Conta poupança de {CustomerName}");
                }
            }

            // Uso
            IAccount conta = new SavingsAccount
            {
                CustomerName = "Maria",
                AccountNumber = 123,
                AccountBalance = 1000.0,
                InterestRate = 0.05
            };

            conta.DisplayName(); // Saída: Conta poupança de Maria

String
------

    . Guid - O struct Guid representa um identificador único global: um valor de 16 bytes que, se gerado randomicamente, irá gerar um identificador (quase) único

            var id = Guid.NewGuid();

            var idString = id.ToString();

            System.Console.WriteLine( id );     // 2c04a03a-f15d-44b0-a85e-f90fce3e2141

    . Interpolação "$"

            var price = 10.2;

            string texto = string.Format("O preço do produto é {0}", price );

            System.Console.WriteLine( texto );  // O preço do produto é 10,2

    
            ou

            var price = 10.2;

            string texto1 = $"O preço do produto é {price:F2}";

            System.Console.WriteLine( texto1 );  // O preço do produto é 10,20

            /*
                Resumo dos formatos:

                {0:C}: moeda -> Se não sair o símbolo R$, verifique a configuração do SO em "Setup Linux - 1. Configuração da localidade"
                {0:F2}: duas casas decimais
                {0:D4}: inteiro com zeros à esquerda
                {0:P2}: porcentagem com duas casas
                {0:N0}: separador de milhar sem casas decimais
            */

    . Verbatim "@"

        // string verbatim 
        string mensagem = @"Olá,
                            meu nome é João
                            e tenho 30 anos.";

        Console.WriteLine(mensagem)

    . Interpolação e Verbatim juntos "@$" ou "$@"

        string userName = "John";

        int inboxCount = 25;

        int maxCount = 100;

        var message = $@"{userName} has {inboxCount} messages.
                            Message capacity remaining is {maxCount - inboxCount}.";

        Console.WriteLine(message);

    . Comparação de strings

        . "compareTo" Compara duas strings e retorna um inteiro:

            . 0 se forem iguais,
            . < 0 se a string for menor,
            . > 0 se for maior (ordem alfabética).
        
                string texto = "Testando";
                texto.CompareTo("Testando"); // 0
                texto.CompareTo("testando"); // 1 (case sensitive)

        . Use "Contains" quando quiser saber se uma substring está presente dentro da string.

        . Use "Equals" quando quiser garantir que as strings são idênticas.

            string texto = "Testando";

            System.Console.WriteLine( texto.CompareTo("Testando") );        // Exibirá "0"
            System.Console.WriteLine( texto.CompareTo("testando") );        // Exibirá "1"
            
                    
            System.Console.WriteLine( texto.Contains("Test" ) );        // Exibirá True
            System.Console.WriteLine( texto.Contains("test" ) );        // Exibirá False
            System.Console.WriteLine( texto.Contains("testando", StringComparison.OrdinalIgnoreCase ) );        // Exibirá True

            System.Console.WriteLine( texto.Equals("Testando") );        // Exibirá true
            System.Console.WriteLine( texto.Equals("testando") );        // Exibirá false
            System.Console.WriteLine( texto.Equals("testando", StringComparison.OrdinalIgnoreCase) );        // Exibirá true

        . CompareTo retorna um inteiro 0 - ok e 1 - Não Ok

        . StringComparison.OrdinalIgnoreCase - Ignora o case sensitive.

    . StartsWith e EntsWith

        string texto = "Testando";

        System.Console.WriteLine( texto.StartsWith("Test") );        // Exibirá true
        System.Console.WriteLine( texto.EndsWith("test") );        // Exibirá false

    . IndexOf   - Retorna a posição da string dentro de outra string    texto.IndexOf("esta") // exibirá 1

    . ToUpper e ToLower para deixar em caixa alta e baixa

    . Replace para trocar um texto por outro

    . Split para quebrar em um array

    . Substring( inicio, tamanho )

    . Format( string, arg1, arg2 ) - substitui marcadores {0}, {1}, etc., pelos valores fornecidos.

        . Exemplos:

            double preco = 10.2;
            string texto = string.Format("O preço do produto é {0}", preco);
            Console.WriteLine(texto); // Saída: O preço do produto é 10,2

            double preco = 10.2;
            string texto = string.Format("O preço do produto é {0:C}", preco);
            Console.WriteLine(texto); // Saída: O preço do produto é R$ 10,20 (dependendo da cultura)

        . Os principais tipos de formatação suportados pelo string.Format em C# são:

            {0:C} — Moeda (Currency):
            Exibe o valor como moeda, de acordo com a cultura local.
            Exemplo: R$ 10,20

            {0:F2} — Número com casas decimais fixas (Fixed-point):
            Exibe o número com 2 casas decimais.
            Exemplo: 10,20

            {0:D4} — Inteiro com zeros à esquerda (Decimal):
            Exibe o número inteiro com pelo menos 4 dígitos, preenchendo com zeros à esquerda.
            Exemplo: 0025

            {0:P2} — Porcentagem (Percent):
            Exibe o valor como porcentagem com 2 casas decimais.
            Exemplo: 25,00%

            {0:N0} — Separador de milhar (Number):
            Exibe o número com separador de milhar e sem casas decimais.
            Exemplo: 10.000

            {0:E} — Notação científica (Exponential):
            Exibe o número em notação científica.
            Exemplo: 1.23E+004

            {0:X} — Hexadecimal:
            Exibe o número em formato hexadecimal.
            Exemplo: FF

            {0:G} — Geral (General):
            Usa o formato mais compacto entre fixo e científico.

            {0:yyyy-MM-dd HH:mm:ss} — Datas personalizadas:
            Permite formatar datas conforme padrões definidos.
            Exemplo: 2025-07-04 18:45:00

DateTime
--------

    //assigns default value 01/01/0001 00:00:00
    DateTime dt1 = new DateTime(); 

    int ano = dt3.Year;
    int mes = dt3.Month;
    int day = dt3.Day;
    int hr = dt3.Hour;
    int minuto = dt3.Minute;
    int diaSemana = (int) dt3.DayOfWeek;

    DateTime hoje = DateTime.Now.Date;      // dd/mm/yyyy 00:00:00  - Somente a data do dia, sem hr, min, segundos




    //  I M P O R T A N T E   assigns year, month, day
    DateTime dt2 = new DateTime(2015, 12, 31); 

    //  I M P O R T A N T E     year, month, day, hour, min, seconds
    DateTime dt3 = new DateTime(2015, 12, 31, 5, 10, 20);

    DateTime currentDateTime = DateTime.Now;  //returns current date and time
    DateTime todaysDate = DateTime.Today; // returns today's date


    . Subtração de datas

        Console.WriteLine(dt2 - dt1); //377.05:10:20
        Console.WriteLine( (dt2 - dt1).Days ); // 377
        Console.WriteLine( (dt2 - dt1).TotalDays ); // 377
        Console.WriteLine("Horas: " + (date_2 - date_1).TotalHours );     // Horas: 10152


        DateTime dt1 = new DateTime(2015, 12, 31); 
        DateTime dt2 = new DateTime(2016, 2, 2);

        TimeSpan result = dt2.Subtract(dt1);//33.00:00:00

    . Adição de Datas

        DateTime dataAtual = DateTime.Now;

        System.Console.WriteLine( dataAtual.AddDays(7) );
        System.Console.WriteLine( dataAtual.AddMonths(7) );
        System.Console.WriteLine( dataAtual.AddYears(7) );


        Method              Description
        ------              -----------
        Add                 Adds/Subtracts the value of the specified TimeSpan object instance.
        AddDays             Adds/Subtracts the specified number of days.
        AddHours            Adds/Subtracts the specified number of hours.
        AddMilliseconds     Adds/Subtracts the specified number of Milliseconds.
        AddMinutes          Adds/Subtracts the specified number of minutes.
        AddMonths           Adds/Subtracts the specified number of months.
        AddSeconds          Adds/Subtracts the specified number of seconds.
        AddYears            Adds/Subtracts the specified number of years.

    . Operadores 

        DateTime dt1 = new DateTime(2015, 12, 20);  
        DateTime dt2 = new DateTime(2016, 12, 31, 5, 10, 20); 

        TimeSpan time = new TimeSpan(10, 5, 25, 50);

        Console.WriteLine(dt2 + time); // 1/10/2017 10:36:10 AM


        Console.WriteLine(dt1 == dt2); //False
        Console.WriteLine(dt1 != dt2); //True
        Console.WriteLine(dt1 > dt2); //False
        Console.WriteLine(dt1 < dt2); //True
        Console.WriteLine(dt1 >= dt2); //False
        Console.WriteLine(dt1 <= dt2);//True

    . Convertendo String em DateTime

        var str = "5/12/2020";
        DateTime dataResult;

        var isValidDate = DateTime.TryParse(str, out dataResult);

        if (isValidDate)
            Console.WriteLine(dataResult);
        else
            Console.WriteLine($"{str} is not a valid date string");

    . Formatação

        y (year) 
        M (month)
        d (day) 
        h (hour 12)
        H (hour 24)
        m (minute)
        s (second)
        f (second fraction)
        F (second fraction, trailing zeroes are trimmed)t (P.M or A.M) and z (time zone).

        Exemplo:

            DateTime dataAtual = DateTime.Now;

            System.Console.WriteLine( String.Format("{0:dd/MM/yyy HH:mm:ss}", dataAtual ) );

    . Datas Nulas

        DateTime? dataPagamento = null;     // Para termos uma data nula é necessário declará-la como "DateTime?"
                                            // obrigatório o uso da interrogação.

    . Comparação de datas

        DateTime hoje = DateTime.Now.Date;

        if ( hoje == DateTime.Now.Date ){
            Console.WriteLine( "São iguais");
        }  

Moeda
-----

    // Faça as adaptações conforme o link https://chatgpt.com/share/68770275-5cec-800f-b5ae-19145c1cc9b2

    decimal valor = 10536.25m;

    Console.WriteLine(valor.ToString(CultureInfo.CreateSpecificCulture("pt-BR")));          // 10536,25

    Console.WriteLine(valor.ToString("G",   // Formatador númerico                                          
                                        CultureInfo.CreateSpecificCulture("pt-BR")));       // 10536,25

    Console.WriteLine(valor.ToString("C", // Formatador de Moeda/Currency
                                        CultureInfo.CreateSpecificCulture("pt-BR")));       // R$ 10.536,25

    Console.WriteLine(valor.ToString("F",  // Fração, com uma casa decimal a mais
                                        CultureInfo.CreateSpecificCulture("pt-BR")));       // 10536,250

    Console.WriteLine(valor.ToString("N", // Númerico
                                        CultureInfo.CreateSpecificCulture("pt-BR")));       // 10.536,25

Arrays
------

    . Declaração

        int[] evenNums;

        string[] cities;

        int[] evenNums = int[5]{1,2,3,4,5};

        string[] cities = strint[5]{"Ana", "Jose", "Antonio", "Tobias", "Carlos"};

        . Todas as formas acima podem utilizar var no lugar do tipo "var evenNums..."

        int[] evenNums = {1,2,3,4,5};

        string[] cities = {"Ana", "Jose", "Antonio", "Tobias", "Carlos"};

    . Declarações inválidas

        //must specify the size 
        int[] evenNums = new int[]; 

        //number of elements must be equal to the specified size 
        int[] evenNums = new int[5] { 2, 4 };

        //cannot use var with array initializer
        var evenNums = { 2, 4, 6, 8, 10}; 


    . Declaração com inicialização tardia.

        int[] evenNums;

        evenNums = new int[5];
        // or
        evenNums = new int[]{ 2, 4, 6, 8, 10 };

    . Acesso aos elementos utilizando o índice:

        int[] evenNums = new int[5];
        evenNums[0] = 2;
        evenNums[1] = 4;
        //evenNums[6] = 12;  //Throws run-time exception IndexOutOfRange

        Console.WriteLine(evenNums[0]);  //prints 2
        Console.WriteLine(evenNums[1]);  //prints 4

    . Acessando os elementos através de um loop

        int[] evenNums = { 2, 4, 6, 8, 10 };

        for(int i = 0; i < evenNums.Length; i++)
            Console.WriteLine(evenNums[i]);  

        for(int i = 0; i < evenNums.Length; i++)
            evenNums[i] = evenNums[i] + 10;  // update the value of each element by 10

    . Acessando os elementos através de um foreach

        int[] evenNums = { 2, 4, 6, 8, 10}; 
        string[] cities = { "Mumbai", "London", "New York" }; 

        foreach(var item in evenNums)
            Console.WriteLine(item);   

        foreach(var city in cities)
            Console.WriteLine(city);  

    . Métodos do array

        int[] nums = new int[5]{ 10, 15, 16, 8, 6 };

        Array.Sort(nums);                               // sorts array 
        Array.Reverse(nums);                            // sorts array in descending order
        Array.ForEach(nums, n => Console.WriteLine(n)); // iterates array
        Array.BinarySearch(nums, 5);                    // binary search 
        Array.Clear(nums, 0, 3 );                       // Limpando arrays

    . Passando array como argumento

        public static void Main(){
            int[] nums = { 1, 2, 3, 4, 5 };

            UpdateArray(nums); 

            foreach(var item in nums)
                Console.WriteLine(item);   
        }
                            
        public static void UpdateArray(int[] arr)
        {
            for(int i = 0; i < arr.Length; i++)
                arr[i] = arr[i] + 10;   
        }

    . Exemplo de Sort de Array

        private static void sortedByArray()
        {
            int[] numeros = {2,20,6,15,11,1};
            int[] novosNumero = new int[6];
            int idNovosNumero;

            foreach( int numero in numeros ){
                for ( idNovosNumero = novosNumero.Length - 1; idNovosNumero > 0 ; idNovosNumero-- ){
                    if (novosNumero[ idNovosNumero ] < numero)
                        break;
                }

                for( int i = 0; i < idNovosNumero; i++){
                    novosNumero[i] = novosNumero[ i + 1];
                }

                novosNumero[ idNovosNumero ] = numero;
                
            }

            foreach( int numero in novosNumero ){
                System.Console.WriteLine( numero );
            }



        }

Exception
---------

    . Lista de exceções:

        Exception Class 	            Description
        ---------------                 -----------
        ArgumentException 	            Raised when a non-null argument that is passed to a method is invalid.
        ArgumentNullException 	        Raised when null argument is passed to a method.
        ArgumentOutOfRangeException 	Raised when the value of an argument is outside the range of valid values.
        DivideByZeroException 	        Raised when an integer value is divide by zero.
        FileNotFoundException 	        Raised when a physical file does not exist at the specified location.
        FormatException 	            Raised when a value is not in an appropriate format to be converted from a string by a conversion method such as Parse.
        IndexOutOfRangeException 	    Raised when an array index is outside the lower or upper bounds of an array or collection.
        InvalidOperationException 	    Raised when a method call is invalid in an object's current state.
        KeyNotFoundException 	        Raised when the specified key for accessing a member in a collection is not exists.
        NotSupportedException 	        Raised when a method or operation is not supported.
        NullReferenceException 	        Raised when program access members of null object.
        OverflowException 	            Raised when an arithmetic, casting, or conversion operation results in an overflow.
        OutOfMemoryException 	        Raised when a program does not get enough memory to execute the code.
        StackOverflowException 	        Raised when a stack in memory overflows.
        TimeoutException 	            The time interval allotted to an operation has expired.

    . Sintaxe

        try
        {
            Console.WriteLine("Enter a number: ");

            var num = int.parse(Console.ReadLine());

            Console.WriteLine($"Squre of {num} is {num * num}");
        }
        catch
        {
            Console.Write("Error occurred.");
        }
        finally
        {
            Console.Write("Re-try with a different number.");
        }        

        ou 

        try
        {
            Console.WriteLine("Enter a number: ");

            var num = int.parse(Console.ReadLine());

            Console.WriteLine($"Squre of {num} is {num * num}");
        }
        catch(Exception ex)
        {
            Console.Write("Error info:" + ex.Message);
        }
        finally
        {
            Console.Write("Re-try with a different number.");
        }


        . Levantando uma exceção:

            static void Salvar( string texto ){

                if ( string.IsNullOrEmpty( texto ) ){
                    // throw new Exception( "Texto não pode ser nulo" );
                    throw new ArgumentNullException("Texto não pode ser nulo.");        
                }
            }

    . Custom Exception

        . Excessões customizadas são derivados da classe Exception e devem
            incluir três construtores e parâmetros, se necessário.

            // Classe model
            namespace helloWorld;

            class Student
            {
                public int StudentID { get; set; }
                public string StudentName { get; set; }
            }



            // Excessão customizada
            namespace helloWorld;

            [Serializable]
            class InvalidStudentNameException : Exception   // Derivada de Exception
            {
                public InvalidStudentNameException() { }   // 1. Construtor sem parâmetro

                public InvalidStudentNameException(string name) // 2. Construtor com parâmetro, indicando a msg
                    : base(String.Format("Invalid Student Name: {0}", name))
                {

                }

                public InvalidStudentNameException(string name, Exception inner) // 3. Construtor com parâmetro, indicando a msg e uma exception personalizada
                    : base(String.Format("Invalid Student Name: {0}", name), inner)
                {

                }
            }


            // Chamador
            using System.Text.RegularExpressions;
            using helloWorld;

            class Program
            {
                public static void Main(string[] args)
                {
                    Student? newStudent = null;

                    try
                    {
                        newStudent = new Student();
                        newStudent.StudentName = "James";

                        ValidateStudent(newStudent);
                    }
                    catch (InvalidStudentNameException ex)
                    {
                        Console.WriteLine(ex.Message);
                    }


                    // Console.ReadKey();
                }

                private static void ValidateStudent(Student std)
                {
                    Regex regex = new Regex("^[a-zA-Z]+$");

                    if (!regex.IsMatch(std.StudentName))
                        throw new InvalidStudentNameException(std.StudentName);

                    try
                    {
                        // Algum código que pode lançar uma exceção
                        throw new FormatException("Operação inválida!");
                    }
                    catch (Exception ex)
                    {
                        // Lança uma exceção personalizada, incluindo a original como inner exception
                        throw new InvalidStudentNameException("Erro de operação inválida!!!", ex);
                    }
                }
            }

Classes Genérica
----------------

    Na abordagem de classes genéricas em C#, os principais pontos que devem ser abordados são:

        . Definição de classe genérica

            Sintaxe: class NomeClasse<T> { ... }
            O que é o parâmetro de tipo (T).

                class DataStore<T>
                {
                    public T Data { get; set; }
                }


                class KeyValuePair<TKey, TValue>
                {
                    public TKey Key { get; set; }
                    public TValue Value { get; set; }
                }

        . Instanciação de classes genéricas

            Como criar objetos de uma classe genérica com tipos diferentes.

                DataStore<string> store = new DataStore<string>();

        . Campos e propriedades genéricas

            Como declarar campos e propriedades usando o tipo genérico.

                class DataStore<T>
                {
                    public T data;
                }

                ou

                class DataStore<T>
                {
                    public T[] data = new T[10];
                }

        . Métodos genéricos em classes genéricas

            Métodos que usam o tipo genérico da classe.
            Sobrecarga de métodos genéricos.
            Métodos genéricos independentes do tipo da classe.

            class DataStore<T>
            {
                private T[] _data = new T[10];
                
                public void AddOrUpdate(int index, T item)
                {
                    if(index >= 0 && index < 10)
                        _data[index] = item;
                }

                public T GetData(int index)
                {
                    if(index >= 0 && index < 10)
                        return _data[index];
                    else 
                        return default(T);
                }
            }

        
            DataStore<string> cities = new DataStore<string>();
            cities.AddOrUpdate(0, "Mumbai");
            cities.AddOrUpdate(1, "Chicago");
            cities.AddOrUpdate(2, "London");

            DataStore<int> empIds = new DataStore<int>();
            empIds.AddOrUpdate(0, 50);
            empIds.AddOrUpdate(1, 65);
            empIds.AddOrUpdate(2, 89);

        . Métodos genéricos em classes não genéricas

            Como declarar métodos genéricos em classes comuns.

                class Printer
                {
                    public void Print<T>(T data)
                    {
                        Console.WriteLine(data);
                    }
                }

                Printer printer = new Printer();
                printer.Print<int>(100);
                printer.Print(200); // type infer from the specified value
                printer.Print<string>("Hello");
                printer.Print("World!"); // type infer from the specified value

        . Utilização de classes genérica

            DataStore<string> strStore = new DataStore<string>();
            strStore.Data = "Hello World!";
            //strStore.Data = 123; // compile-time error

            DataStore<int> intStore = new DataStore<int>();
            intStore.Data = 100;
            //intStore.Data = "Hello World!"; // compile-time error

            KeyValuePair<int, string> kvp1 = new KeyValuePair<int, string>();
            kvp1.Key = 100;
            kvp1.Value = "Hundred";

            KeyValuePair<string, string> kvp2 = new KeyValuePair<string, string>();
            kvp2.Key = "IT";
            kvp2.Value = "Information Technology";

        . Vantagens do uso de generics

            Reutilização de código.
            Segurança de tipo em tempo de compilação.
            Evita casts desnecessários.

        . Limitações e restrições de tipos genéricos

            Restrições com where (ex: where T : class, where T : new(), etc).

        . Métodos genéricos sobrecarregados

            public void AddOrUpdate(int index, T data) { }
            public void AddOrUpdate(T data1, T data2) { }
            public void AddOrUpdate<U>(T data1, U data2) { }
            public void AddOrUpdate(T data) { }

        . Exemplos práticos

            Uso com listas, dicionários, pares chave-valor, etc.

Coleções
--------

    . ArrayList

        . ArrayList não aceita Generic e tem menos recursos que o List

        . Criando um arraylist

            using System.Collections;

            ArrayList arlist = new ArrayList(); 
            // or 
            var arlist = new ArrayList();         

        . Adicionando elementos

            // adding elements using ArrayList.Add() method
            var arlist1 = new ArrayList();
            arlist1.Add(1);
            arlist1.Add("Bill");
            arlist1.Add(" ");
            arlist1.Add(true);
            arlist1.Add(4.5);
            arlist1.Add(null);

            // adding elements using object initializer syntax
            var arlist2 = new ArrayList()
                            {
                                2, "Steve", " ", true, 4.5, null
                            };
        
        . Acessando um elemento de um ArrayList



            var arlist = new ArrayList()
                            {
                                1,
                                "Bill",
                                300,
                                4.5f
                            };

            //Access individual item using indexer
            int firstElement = (int) arlist[0]; //returns 1
            string secondElement = (string) arlist[1]; //returns "Bill"
            //int secondElement = (int) arlist[1]; //Error: cannot cover string to int

            //using var keyword without explicit casting
            var firstElement = arlist[0]; //returns 1
            var secondElement = arlist[1]; //returns "Bill"
            //var fifthElement = arlist[5]; //Error: Index out of range

            //update elements
            arlist[0] = "Steve"; 
            arlist[1] = 100;
            //arlist[5] = 500; //Error: Index out of range

        . Iterando um ArrayList

            ArrayList arlist = new ArrayList()
                                    {
                                        1,
                                        "Bill",
                                        300,
                                        4.5F
                                    };

            foreach (var item in arlist)
                Console.Write(item + ", "); //output: 1, Bill, 300, 4.5, 
                        
            for(int i = 0 ; i < arlist.Count; i++)
                Console.Write(arlist[i] + ", "); //output: 1, Bill, 300, 4.5, 


            pessoas.ForEach( item => { 
                System.Console.WriteLine( item );
            } );

        . Checando a existência de um item

            ArrayList arList = new ArrayList()
                            {
                                1,
                                "Bill",
                                300,
                                4.5f,
                                300
                            };

            Console.WriteLine(arList.Contains(300)); // true
            Console.WriteLine(arList.Contains("Bill")); // true
            Console.WriteLine(arList.Contains(10)); // false
            Console.WriteLine(arList.Contains("Steve")); // false

        . Métodos e propriedades

            ArrayList  Properties

            Properties 	        Description
            ----------          -----------
            Capacity 	        Gets or sets the number of elements that the ArrayList can contain.
            Count 	            Gets the number of elements actually contained in the ArrayList.
            IsFixedSize 	    Gets a value indicating whether the ArrayList has a fixed size.
            IsReadOnly 	        Gets a value indicating whether the ArrayList is read-only.
            Item 	            Gets or sets the element at the specified index.

            ArrayList Methods

            Methods 	            Description
            -------                 -----------
            Add()/AddRange() 	    Add() method adds single elements at the end of ArrayList.
            AddRange()              method adds all the elements from the specified collection into ArrayList.
            Insert()/InsertRange() 	Insert() method insert a single elements at the specified index in ArrayList.
            InsertRange()           method insert all the elements of the specified collection starting from specified index in ArrayList.
            Remove()/RemoveRange() 	Remove() method removes the specified element from the ArrayList.
            RemoveRange()           method removes a range of elements from the ArrayList.
            RemoveAt() 	            Removes the element at the specified index from the ArrayList.
            Sort() 	                Sorts entire elements of the ArrayList.
            Reverse() 	            Reverses the order of the elements in the entire ArrayList.
            Contains 	            Checks whether specified element exists in the ArrayList or not. Returns true if exists otherwise false.
            Clear 	                Removes all the elements in ArrayList.
            CopyTo 	                Copies all the elements or range of elements to compitible Array.
            GetRange 	            Returns specified number of elements from specified index from ArrayList.
            IndexOf 	            Search specified element and returns zero based index if found. Returns -1 if element not found.
            ToArray 	            Returns compitible array from an ArrayList. 

    . List

        . Aceita o uso de Generic

        . Criando uma lista

            List<int> primeNumbers = new List<int>();
            primeNumbers.Add(1); // adding elements using add() method
            primeNumbers.Add(3);
            primeNumbers.Add(5);
            primeNumbers.Add(7);

            var cities = new List<string>();
            cities.Add("New York");
            cities.Add("London");
            cities.Add("Mumbai");
            cities.Add("Chicago");
            cities.Add(null);// nulls are allowed for reference type list

            //adding elements using collection-initializer syntax
            var bigCities = new List<string>()
                                {
                                    "New York",
                                    "London",
                                    "Mumbai",
                                    "Chicago"                    
                                };

        . Adicionando objetos num List

            var students = new List<Student>() { 
                new Student(){ Id = 1, Name="Bill"},
                new Student(){ Id = 2, Name="Steve"},
                new Student(){ Id = 3, Name="Ram"},
                new Student(){ Id = 4, Name="Abdul"}
            };

        . Acessando lista

            List<int> numbers = new List<int>() { 1, 2, 5, 7, 8, 10 };
            Console.WriteLine(numbers[0]); // prints 1
            Console.WriteLine(numbers[1]); // prints 2
            Console.WriteLine(numbers[2]); // prints 5
            Console.WriteLine(numbers[3]); // prints 7

            // using foreach LINQ method
            numbers.ForEach(num => Console.WriteLine(num + ", "));//prints 1, 2, 5, 7, 8, 10,

            // using for loop
            for(int i = 0; i < numbers.Count; i++)
                Console.WriteLine(numbers[i]);

        . Verificando a existência de um item

            var numbers = new List<int>(){ 10, 20, 30, 40 };
            numbers.Contains(10); // returns true
            numbers.Contains(11); // returns false
            numbers.Contains(20); // returns true

        . List<T> Class Properties and Methods

            Property 	    Usage
            --------        -----
            Items 	        Gets or sets the element at the specified index
            Count 	        Returns the total number of elements exists in the List<T>

            Method 	        Usage
            ------          -----
            Add 	        Adds an element at the end of a List<T>.
            AddRange 	    Adds elements of the specified collection at the end of a List<T>.
            BinarySearch 	Search the element and returns an index of the element.
            Clear 	        Removes all the elements from a List<T>.
            Contains 	    Checks whether the specified element exists or not in a List<T>.
            Find 	        Finds the first element based on the specified predicate function.
            Foreach 	    Iterates through a List<T>.
            Insert 	        Inserts an element at the specified index in a List<T>.
            InsertRange 	Inserts elements of another collection at the specified index.
            Remove 	        Removes the first occurrence of the specified element.
            RemoveAt 	    Removes the element at the specified index.
            RemoveRange 	Removes all the elements that match the supplied predicate function.
            Sort 	        Sorts all the elements.
            TrimExcess 	    Sets the capacity to the actual number of elements.
            TrueForAll 	    Determines whether every element in the List<T> matches the conditions defined by the specified predicate. 

    . Dictionary

        . Dictionary em C# permite que os dados sejam armazenados e gerenciados como pares chave-valor. Os dicionários cumprem um
            propósito semelhante ao de arrays e listas, exceto que cada item armazenado no dicionário tem associada uma chave única 
            (para ser mais preciso, a chave é única para o objeto específico do dicionário) que pode ser usada para referenciar e 
            acessar o valor correspondente.
        
        . A declaração de um Dictionary em C# é feita usando a classe genérica Dictionary<TKey, TValue>, onde TKey é o tipo da chave e TValue 
            é o tipo do valor. 

            . Sintaxe:

                Dictionary<int, string> alunos = new Dictionary<int, string>();

                Dictionary alunos = new Dictionary();
                
                var alunos = new Dictionary();

                var alunos = new Dictionary() {   { key1, value1 },
                                                { key2, value2 },
                                                { key3, value3 }, 
                                                ...
                                            }

        . Dictionary<T> Properties and Methods

            Propriedades
            ------------

                Count: retorna o número de pares chave-valor no dicionário.
                Keys: retorna uma coleção com todas as chaves.
                Values: retorna uma coleção com todos os valores.
                Item[TKey]: permite acessar ou definir o valor associado a uma chave específica (indexador).

            Métodos
            -------

                Add(TKey key, TValue value): adiciona um novo par chave-valor.
                Remove(TKey key): remove o elemento com a chave especificada.
                Clear(): remove todos os elementos do dicionário.
                ContainsKey(TKey key): verifica se uma chave existe no dicionário.
                ContainsValue(TValue value): verifica se um valor existe no dicionário.
                TryGetValue(TKey key, out TValue value): tenta obter o valor associado à chave, sem lançar exceção se não existir.
                GetEnumerator(): retorna um enumerador para iterar pelos pares chave-valor.

        . Iteração

            . Usando foreach nos pares chave-valor

                Dictionary<int, string> alunos = new Dictionary<int, string>();
                // ... adicionar elementos ...

                foreach (var item in alunos)
                {
                    Console.WriteLine($"Chave: {item.Key}, Valor: {item.Value}");
                }

            . Iterando apenas pelas chaves

                foreach (var valor in alunos.Values)
                {
                    Console.WriteLine($"Valor: {valor}");
                }

            .  Iterando apenas pelos valores

                foreach (var valor in alunos.Values)
                {
                    Console.WriteLine($"Valor: {valor}");
                }

        . Acessando itens na coleção pela chave

            using System;
            using System.Collections.Generic;

            class Program
            {
                static void Main()
                {
                    // Declarando o Dictionary com chave string e valor int
                    Dictionary<string, int> estoque = new Dictionary<string, int>();

                    // Adicionando elementos
                    estoque.Add("Arroz", 50);
                    estoque.Add("Feijão", 30);
                    estoque.Add("Macarrão", 20);

                    // Acessando um valor pela chave
                    Console.WriteLine($"Quantidade de Arroz: {estoque["Arroz"]}");  // Saída: Quantidade de Arroz: 50

                    // Iterando sobre o Dictionary
                    foreach (var item in estoque)
                    {
                        Console.WriteLine($"Produto: {item.Key}, Quantidade: {item.Value}");
                    }

                                /* Saída

                                    Produto: Arroz, Quantidade: 50
                                    Produto: Feijão, Quantidade: 30
                                    Produto: Macarrão, Quantidade: 20
                                */
                }
            }

Processamento Assincrono
------------------------

    . Processamento assíncrono em C# permite executar tarefas de forma não bloqueante, ou seja, o programa pode continuar 
        executando outras operações enquanto aguarda a conclusão de uma tarefa demorada (como acesso a arquivos, banco de 
        dados ou chamadas de rede). Isso é feito principalmente com as palavras-chave async e await, usando métodos que 
        retornam Task ou Task<T>.

    . Exemplos:

        // Processamento Assíncrono "Program.cs"
        class Program
        {
            static void Main(string[] args)
            {
                // Executa o método ExecutarAsync
                var retorno1 = ExecutarAsync("Processamento 1");
                var retorno2 = ExecutarAsync("Processamento 2");
                var retorno3 = ExecutarAsync("Processamento 3");

                Console.WriteLine("Já passou os 2 segundos...");
                Console.WriteLine("Fim");

                Console.ReadLine();                 // IMPORTANTE: É necessário a parada do processamento, para que o fluxo retorne a linha abaixo do
                                                    //              "await Task.Delay(TimeSpan.FromSeconds(2));" 

                Console.WriteLine(retorno1.Result); // IMPORTANTE: Como dito anterior é necessário ter uma parada no fluxo para que seja retornado
                Console.WriteLine(retorno2.Result); //              na linha do "await", neste caso poderiamos comentar o "Console.ReadLine()" porque
                Console.WriteLine(retorno3.Result); //              o "retorno1[2,3].Result" terá que aguardar a conclusão do método "ExecutarAsync" 
                                                    //              para ter o seu resultado.
            }

            static async Task<string> ExecutarAsync(string msg)
            {
                Console.WriteLine($"Iníciando espera {msg}");

                await Task.Delay(TimeSpan.FromSeconds(2)); // Espera 2 segundos sem bloquear a thread principal

                Console.WriteLine($"Fim da espera {msg}");

                return $"Tarefa concluída do {msg}!";
            }

        }


        . Task      - Representa uma tarefa assíncrona, ou seja, uma operação que pode ser executada de forma independente e não bloqueia 
                        o fluxo principal do programa. Ela faz parte do namespace System.Threading.Tasks e é usada para facilitar o processamento 
                        assíncrono e paralelo

            . Uma Task pode executar métodos que demoram (como acesso a arquivos, banco de dados, etc.) sem travar a aplicação.

            . Pode retornar um resultado (Task<T>) ou apenas indicar a conclusão (Task).

            . No caso dos métodos assíncronos o retorno será uma tarefa "Task" (tarefas a serem executadas em paralelo)



            static async Task<string> ExecutarAsync()

        . async     - Significa que o método será executado assincronamente.

            static async void ExecutarAsync()
                    |                 -----
                    |                   |
                    +--> Configuração   +----> Por convenção, qdo utilizamos "async" no método, o nome 
                        do método como           dele também é batizado como "Async"
                        "async"

        . await     - Pausa a execução até que a operação assíncrona termine, mas não bloqueia a thread/fluxo principal retornando para o chamador. 
                        Assim, outros processos podem continuar rodando enquanto a Task está em execução.

                    Quando a Task termina, o método continua a execução a partir da linha seguinte ao await. Isso facilita o uso de operações 
                    demoradas (como acesso a banco, arquivos, APIs) sem travar a aplicação.

                    . Exemplo prático:
        
                        Console.WriteLine("Início");

                        await Task.Delay(2000); // Pausa aqui por 2 segundos, sem bloquear a thread, retornando para o chamador

                        Console.WriteLine("Fim"); // Só executa após o await terminar, saindo do chamador retornando para cá

        
         Significa que irá aguardar a execução do método especificado como "await" para sair do método pai/chamador. ATENÇÃO: Se 
                        for colocado "await" o processamento deixa de ser assíncrono

            await Task.Delay(TimeSpan.FromSeconds(2)); // Espera 2 segundos sem bloquear a thread principal

    . Task.WaitAll  - É um método síncrono, utilizado para aguardar a conclusão de várias tarefas (Tasks) assíncronas antes de continuar 
                        a execução do código. Ele bloqueia a thread atual até que todas as Tasks passadas como parâmetro tenham terminado.

                    Não pode ser usado com await.
                      

        . Exemplo:

            static void Main(string[] args)
            {
                // Executa o método ExecutarAsync
                var retorno1 = ExecutarAsync("Processamento 1");
                var retorno2 = ExecutarAsync("Processamento 2");
                var retorno3 = ExecutarAsync("Processamento 3");

                Console.WriteLine("Já passou os 2 segundos...");
                Console.WriteLine("Fim");

                Task.WaitAll( retorno1, retorno2, retorno3 );       // Podemos eliminar quaisquer outras forma de parar o processamento e utilizar 
                                                                    // "Task.WaitAll" para aguardar a conclusão de todos os processamentos.
            }

    . Task.WhenAll  - Quase igual ao "Task.WaitAll", só que assíncrono.

        . Recebe um array ou lista de Tasks.

        . Retorna uma Task que pode ser aguardada com await.

        . Se todas as Tasks terminarem com sucesso, a Task retornada também termina com sucesso.

        . Se alguma Task lançar exceção, a Task retornada lança uma AggregateException com todas as exceções.

        . Exemplo:
                              +---------> observe que fomos obrigado utilizar "async" "Task" porque a chamada do "Task.WhenAll" é feita com "await"
                              |
                         |----------|
            public static async Task Main(string[] args)
            {
                var t1 = ExecutarAsync("Processo 1");
                var t2 = ExecutarAsync("Processo 2");
                var t3 = ExecutarAsync("Processo 3");

                await Task.WhenAll(t1, t2, t3);

                Console.WriteLine("Todos os processamentos concluídos!");
            }

    . No cenário em que você precisa executar vários comandos (INSERT, UPDATE, DELETE) no banco de dados usando ADO.NET, o recomendado é:

        . Executar cada comando de forma assíncrona usando await.

        . Evitar executar comandos concorrentes na mesma conexão (cada conexão só pode processar um comando por vez).

        . Se os comandos precisam ser executados em sequência (um depende do outro), use await em cada chamada, um após o outro.

        . Se os comandos são independentes e podem ser executados em paralelo, use conexões diferentes para cada comando e aguarde todos com Task.WhenAll.

        . Exemplo:

            using (var connection = new SqlConnection(connectionString))
            {
                await connection.OpenAsync();

                using (var transaction = connection.BeginTransaction())
                {
                    try
                    {
                        using (var insertCmd = new SqlCommand("INSERT INTO Tabela ...", connection, transaction))
                        {
                            await insertCmd.ExecuteNonQueryAsync();
                        }

                        using (var updateCmd = new SqlCommand("UPDATE Tabela ...", connection, transaction))
                        {
                            await updateCmd.ExecuteNonQueryAsync();
                        }

                        using (var deleteCmd = new SqlCommand("DELETE FROM Tabela ...", connection, transaction))
                        {
                            await deleteCmd.ExecuteNonQueryAsync();
                        }

                        transaction.Commit();
                    }
                    catch
                    {
                        transaction.Rollback();
                        throw;
                    }
                }
            }







    . Threads são unidades de execução independentes dentro de um processo. Em C#, você pode criar threads manualmente usando 
        a classe Thread, mas normalmente o processamento assíncrono moderno utiliza o ThreadPool ou o Task Parallel Library (TPL), 
        que gerenciam threads de forma eficiente.

    . Relação entre Processamento Assíncrono e Threads são:

        . O processamento assíncrono pode usar threads para executar tarefas em paralelo, mas nem toda operação assíncrona cria uma 
            nova thread (por exemplo, operações de I/O podem ser aguardadas sem ocupar uma thread).

        . O uso de async/await facilita o código assíncrono sem precisar gerenciar threads manualmente.

        . Para tarefas que realmente exigem paralelismo (várias tarefas ao mesmo tempo), threads são usadas por trás dos panos.

        // Thread
        using System;
        using System.Threading;

        public class Exemplo
        {
            public void ExecutarComThread()
            {
                Thread thread = new Thread(() =>
                {
                    Console.WriteLine("Executando em outra thread");
                });
                thread.Start();
            }
        }        






Injection Dependency
--------------------

https://andrewlock.net/using-dependency-injection-in-a-net-core-console-application/
https://www.youtube.com/watch?v=4mEN1XpLN_s
https://marcionizzola.medium.com/como-fazer-inje%C3%A7%C3%A3o-de-depend%C3%AAncia-em-um-console-application-com-net-core-c5d66f092593
https://dev.to/joeldroid/dependency-injection-in-a-net-core-console-application-3flh
https://www.programmingwithwolfgang.com/configure-dependency-injection-for-net-5-console-applications/
https://www.macoratti.net/20/05/c_consoledi3.htm
https://www.c-sharpcorner.com/article/implementing-dependency-injection-in-net-core-console-applications/
http://www.techtutorhub.com/article/How-to-implement-Dependency-Injection-in-NET-Core-Console-Application/87


Lambda
------

https://www.youtube.com/watch?v=Ftbrn82BPcc


Nested Class
------------

https://www.geeksforgeeks.org/nested-classes-in-c-sharp/

