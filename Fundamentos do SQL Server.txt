Fundamentos do SQL Server
-------------------------


Aula 2.  Ferramentas
--------------------

. Instalando o SQL Server

    https://balta.io/blog/sql-server-docker
    https://www.sqlservertutorial.net/getting-started/what-is-sql-server/
    https://docs.microsoft.com/pt-br/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash
    https://docs.microsoft.com/pt-br/sql/linux/sql-server-linux-setup-tools?view=sql-server-ver15#ubuntu


    docker container run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=Joao3.16"    -p 1433:1433 --name sql1 --hostname sql1    -d mcr.microsoft.com/mssql/server:2019-latest
    docker container ps -a
    docker container exec -t sql1 cat /var/opt/mssql/log/errorlog | grep connection

    # Testar no linux, não funcionou no windows
    docker container exec -it sql1 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA  -P "$(read -sp "Enter current SA password: "; echo "${REPLY}")"  -Q "ALTER LOGIN SA WITH PASSWORD=\"$(read -sp "Enter new SA password: "; echo "${REPLY}")\""
    docker exec -it sql1 "bash"
    hostname -I
    ip a
    curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
    curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list
    sudo apt-get update 
    sudo apt-get install mssql-tools unixodbc-dev
    sudo apt-get update 
    sudo apt-get install mssql-tools
    echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bash_profile
    echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bashrc
    source ~/.bashrc
    hostname -I
    sqlcmd -S 192.168.0.82,1433 -U SA -P "Joao3.16"


    . String de conexão:

        Server=localhost,1433;Database=<user>;User ID=sa;Password=<password>


. Instalando Azure Data Studio

    . Para Linux siga os passos abaixo:

        Acessar o link abaixo para fazer o download do arquivo .deb:

            https://go.microsoft.com/fwlink/?linkid=2169956

        cd ~
        sudo dpkg -i ./Downloads/azuredatastudio-linux-<version string>.deb
        azuredatastudio

    . Para Windows acesse o link abaixo:

        https://docs.microsoft.com/pt-br/sql/azure-data-studio/download-azure-data-studio?view=sql-server-ver15    


    . Acesse o Azure data studio e configure uma conexão com os parâmetros abaixo:

        Connection Type:        Microsoft SQL Server
        Server:                 localhost,1433
        Authentication Type:    SQL Login
        User Name:              sa
        Password:               Joao3.16
        Remember password:      True
        Database:               master
        Server group:           LOCAL     # Escolha "Add new group" e crie o grupo LOCAL
        Name:                   Docker Localhost


Aula 3. Create Database
-----------------------

    . Acesse o Azure Data Studio, na parte de "Query" posicionado no banco "master" execute o comando abaixo:

        CREATE DATABASE [Curso]

        . Clique no botão "Run"

        . Clique direito no item "Databases" e escolha "Refresh"

    . Apagar um database não é algo simples no SQL Server, porque se ele estiver em uso ele não deixará isso acontecer.
        Porém o comando para isso está abaixo:

        DROP DATABASE [Curso]

        /*  Desconsiderar o código abaixo, não funcionou
        USE [master]

        DECLARE @kill VARCHAR(8000) = '';

        SELECT @kill = @kill + 'kill ' + CONVERT( VARCHAR(5) , session_id );
        FROM sys.dm_exec_sessions
        WHERE database_id = db_id('Curso')

        EXEC @kill;
        */

    . Os nomes dos objetos como tables, databases, etc podem vir entre colchetes.


Aula 4. CREATE TABLE
--------------------
    
. Data Types SQL Server:

    String Data Types
    =================

    Data type	            Description	                                                        Max size	                    Storage
    ---------               -----------                                                         --------                        -------
    char(n)	                Fixed width character string	                                    8,000 characters	            Defined width
    varchar(n)	            Variable width character string	                                    8,000 characters	            2 bytes + number of chars
    varchar(max)	        Variable width character string	                                    1,073,741,824 characters	    2 bytes + number of chars
    *text	                Variable width character string	                                    2GB of text data	            4 bytes + number of chars
    nchar	                Fixed width Unicode string	                                        4,000 characters	            Defined width x 2
    nvarchar	            Variable width Unicode string	                                    4,000 characters	 
    nvarchar(max)	        Variable width Unicode string	                                    536,870,912 characters	 
    ntext	                Variable width Unicode string	                                    2GB of text data	 
    binary(n)	            Fixed width binary string	                                        8,000 bytes	 
    varbinary	            Variable width binary string	                                    8,000 bytes	 
    varbinary(max)	        Variable width binary string	                                    2GB	 
    image	                Variable width binary string	                                    2GB	 


    Numeric Data Types
    ==================

    Data type	            Description	                                                                                            Storage
    ---------               -----------                                                                                             -------
    bit	                    Integer that can be 0, 1, or NULL	 
    tinyint	                Allows whole numbers from 0 to 255	                                                                    1 byte
    smallint	            Allows whole numbers between -32,768 and 32,767	                                                        2 bytes
    int	                    Allows whole numbers between -2,147,483,648 and 2,147,483,647	                                        4 bytes
    bigint	                Allows whole numbers between -9,223,372,036,854,775,808 and 9,223,372,036,854,775,807	                8 bytes
    decimal(p,s)	        Fixed precision and scale numbers.                                                                      5-17 bytes
                            Allows numbers from -10^38 +1 to 10^38 –1.

                            The p parameter indicates the maximum total number of digits that can be stored (both to the left 
                            and to the right of the decimal point). p must be a value from 1 to 38. Default is 18.

                            The s parameter indicates the maximum number of digits stored to the right of the decimal 
                            point. s must be a value from 0 to p. Default value is 0
    numeric(p,s)	        Fixed precision and scale numbers.                                                                      5-17 bytes
                            Allows numbers from -10^38 +1 to 10^38 –1.

                            The p parameter indicates the maximum total number of digits that can be stored (both to the left 
                            and to the right of the decimal point). p must be a value from 1 to 38. Default is 18.

                            The s parameter indicates the maximum number of digits stored to the right of the decimal 
                            point. s must be a value from 0 to p. Default value is 0
    smallmoney	            Monetary data from -214,748.3648 to 214,748.3647	                                                    4 bytes
    money	                Monetary data from -922,337,203,685,477.5808 to 922,337,203,685,477.5807	                            8 bytes
    float(n)	            Floating precision number data from -1.79E + 308 to 1.79E + 308.                                        4 or 8 bytes
                            The n parameter indicates whether the field should hold 4 or 8 bytes. float(24) holds a 4-byte field 
                            and float(53) holds an 8-byte field. Default value of n is 53.
    real	                Floating precision number data from -3.40E + 38 to 3.40E + 38	                                        4 bytes



    Date and Time Data Types
    ========================
    Data type	            Description	                                                                                            Storage
    ---------               -----------                                                                                             -------
    datetime	            From January 1, 1753 to December 31, 9999 with an accuracy of 3.33 milliseconds	                        8 bytes
    datetime2	            From January 1, 0001 to December 31, 9999 with an accuracy of 100 nanoseconds	                        6-8 bytes
    smalldatetime	        From January 1, 1900 to June 6, 2079 with an accuracy of 1 minute	                                    4 bytes
    date	                Store a date only. From January 1, 0001 to December 31, 9999	                                        3 bytes
    time	                Store a time only to an accuracy of 100 nanoseconds	                                                    3-5 bytes
    datetimeoffset	        The same as datetime2 with the addition of a time zone offset	                                        8-10 bytes
    timestamp	            Stores a unique number that gets updated every time a row gets created or modified. The timestamp 
                            value is based upon an internal clock and does not correspond to real time. Each table may have only 
                            one timestamp variable	 

    Other Data Types
    ================
    Data type	            Description
    ---------               -----------
    sql_variant	            Stores up to 8,000 bytes of data of various data types, except text, ntext, and timestamp
    uniqueidentifier	    Stores a globally unique identifier (GUID)
    xml	                    Stores XML formatted data. Maximum 2GB
    cursor	                Stores a reference to a cursor used for database operations
    table	                Stores a result-set for later processing

. Boolean - Não existe boolean em SQL Server, no lugar podemos usar o tipo "bit" que tem 0, ou 1.

. Exemplos de DDL:

    CREATE TABLE [Aluno](   [Id] INT,
                            [Nome] VARCHAR(100),
                            [Nascimento] DATETIME,
                            [Active] BIT)

    CREATE TABLE Stock (
        ProductId INT,
        ProductName VARCHAR,
        ProductCount INT
    );


Aula 5. Alter/Drop Table
------------------------

    USE [Curso]

    ALTER TABLE [Aluno]
        ADD [Document] VARCHAR(11)

    ALTER TABLE [Aluno]
        DROP COLUMN [Document]

    ALTER TABLE [Aluno]
        ALTER COLUMN [Document] CHAR(11)


Aula 6. Constraints - Not Null
------------------------------

    USE [Curso]

    DROP TABLE [Aluno]

    CREATE TABLE [Aluno](   [Id] INT NOT NULL,
                            [Nome] VARCHAR(100) NOT NULL,
                            [Nascimento] DATETIME NOT NULL,
                            [Active] BIT)       -- ou [Active] BIT DEFAULT(0)
    GO

    ALTER TABLE [Aluno]
        ALTER COLUMN [Active] BIT NOT NULL

    -- Ou forçar com um valor default
    ALTER TABLE [Aluno]
        ALTER COLUMN [Active] BIT DEFAULT(0)


Aula 7. Constraint - Unique
---------------------------

    USE [Curso]

    DROP TABLE [Aluno]

    CREATE TABLE [Aluno](   [Id] INT NOT NULL UNIQUE,
                            [Nome] VARCHAR(100) NOT NULL,
                            [Nascimento] DATETIME NOT NULL,
                            [Email] VARCHAR(100) NOT NULL,
                            [Active] BIT DEFAULT(1))

    ALTER TABLE [Aluno]
        DROP CONSTRAINT [UQ_Aluno]

    GO

    -- ou

    CREATE TABLE [Aluno](   [Id] INT NOT NULL UNIQUE,
                            [Nome] VARCHAR(100) NOT NULL,
                            [Nascimento] DATETIME NOT NULL,
                            [Email] VARCHAR(100) NOT NULL,
                            [Active] BIT DEFAULT(1),
                            CONSTRAINT [UQ_Aluno] UNIQUE([Id]) )

Aula 8. Primary Key
-------------------

    USE [Curso]

    DROP TABLE [Aluno]

    CREATE TABLE [Aluno](   [Id] INT NOT NULL UNIQUE,
                            [Nome] VARCHAR(100) NOT NULL,
                            [Nascimento] DATETIME NOT NULL,
                            [Email] VARCHAR(100) NOT NULL,
                            [Active] BIT DEFAULT(1),
                            CONSTRAINT [PK_Aluno] PRIMARY KEY([Id])  )    -- Para chaves compostas "PRIMARY KEY( [Id], [Email] )
    GO

    -- ou

    ALTER TABLE [Aluno]
        ADD PRIMARY KEY( [Id] )


    ALTER TABLE [Aluno]
        DROP CONSTRAINT [PK_Aluno]


Aula 9. Compose Key
-------------------

    USE [Curso]

    DROP TABLE [ProgressoCurso]

    CREATE TABLE [ProgressoCurso](  [AlunoId]   INT     NOT NULL,
                                    [CursoId]   INT     NOT NULL,
                                    [Progresso] INT     NOT NULL,
                                    [UltimaAtualizacao] DATETIME NOT NULL DEFAULT( GETDATE() ),
                                    CONSTRAINT [PK_ProgressoCurso] PRIMARY KEY( [Id], [CursoId])
    GO

    DROP TABLE [Categoria]

    CREATE TABLE [Categoria]( [Id] INT NOT NULL,
                            [Nome] NVARCHAR(80) NOT NULL,
                            CONSTRAINT [PK_Categoria] PRIMARY KEY([Id]) )
    GO

    DROP TABLE [Curso]

    CREATE TABLE [Curso](   [Id] INT NOT NULL,
                            [Nome] NVARCHAR(80) NOT NULL,
                            [CategoriaId] INT NOT NULL,
                            CONSTRAINT [PK_Curso] PRIMARY KEY([Id]),
                            CONSTRAINT [FK_Curso_Categoria] 
                                FOREIGN KEY [CategoriaId]
                                REFERENCES [Categoria]( [Id] ) )
    GO



Aula 10. Indíces
----------------

    CREATE INDEX [IX_Aluno_Email] ON [Aluno]( [Email] )

    DROP INDEX [IX_Aluno_Email] ON [Aluno]


Aula 11. Identity
-----------------


    DROP TABLE [Curso]

    CREATE TABLE [Curso](   [Id] INT NOT NULL IDENTITY( 1, 1),          -- Começa no No. 1 e incrementa de 1 em 1
                            [Nome] NVARCHAR(80) NOT NULL,
                            [CategoriaId] INT NOT NULL,
                            CONSTRAINT [PK_Curso] PRIMARY KEY([Id]),
                            CONSTRAINT [FK_Curso_Categoria] 
                                FOREIGN KEY [CategoriaId]
                                REFERENCES [Categoria]( [Id] ) )
    GO

    . Another way to auto-generate key values is to specify your column as a type of uniqueidentifier and 
        DEFAULT using NEWID() or NEWSEQUENTIALID(). Unlike IDENTITY, a DEFAULT constraint must be used 
        to assign a GUID value to the column.

        CREATE TABLE NEWID_TEST
        (
            ID UNIQUEIDENTIFIER DEFAULT NEWID() PRIMARY KEY,
            TESTCOLUMN CHAR(2000) DEFAULT REPLICATE('X',2000)
        )
        GO

        // https://www.mssqltips.com/sqlservertip/1600/auto-generated-sql-server-keys-with-the-uniqueidentifier-or-identity/
    

Aula 12. Insert
---------------

    . Apague o "database" [Curso] com o script abaixo:

        USE [master]

        DECLARE @kill VARCHAR(8000) = '';

        SELECT @kill = @kill + 'kill ' + CONVERT( VARCHAR(5) , session_id );
        FROM sys.dm_exec_sessions
        WHERE database_id = db_id('Curso')

        EXEC @kill;

        DROP DATABASE [Curso]

    . Recrie o database e execute os comandos abaixo:


        CREATE DATABASE [Cursos]

        USE [Cursos]

        CREATE TABLE [Categoria]( [Id] INT NOT NULL IDENTITY(1,1),
                                [Nome] NVARCHAR(80) NOT NULL,
                                CONSTRAINT [PK_Categoria] PRIMARY KEY([Id]) )

        CREATE TABLE [Curso](   [Id] INT NOT NULL IDENTITY( 1, 1),          
                                [Nome] NVARCHAR(80) NOT NULL,
                                [CategoriaId] INT NOT NULL,
                                CONSTRAINT [PK_Curso] PRIMARY KEY([Id]),
                                CONSTRAINT [FK_Curso_Categoria] 
                                    FOREIGN KEY [CategoriaId]
                                    REFERENCES [Categoria]( [Id] ) )
        GO

    . Crie informações na tabela Categoria:

        INSERT INTO [Categoria] VALUES('Backend');
        INSERT INTO [Categoria] VALUES('Frontend');
        INSERT INTO [Categoria] VALUES('Mobile');

        INSERT INTO [Curso]([Nome], [CategoriaId]) VALUES('Fundamentos de C#', 1)
        INSERT INTO [Curso]([Nome], [CategoriaId]) VALUES('Fundamentos OOP', 1)
        INSERT INTO [Curso]([Nome], [CategoriaId]) VALUES('Angular', 2)
        INSERT INTO [Curso]([Nome], [CategoriaId]) VALUES('Flutter', 3)


Aula 13. Select
---------------        

    USE [Cursos]

    SELECT * FROM [Curso]

    SELECT TOP 2 * FROM [Curso]

    SELECT [Id], [Nome] FROM [Curso]

    SELECT DISTINT [Nome] FROM [Curso]


Aula 14. Queries
----------------    

    SELECT TOP 100 * 
    FROM [Curso]
    WHERE [CategoriaId] {= > < >= <= !=} 1
        AND/OR [Id] = 1

    SELECT TOP 100 * 
    FROM [Curso]
    WHERE [CategoriaId] IS NULL / IS NOT NULL


Aula 15. Order by
-----------------    

    SELECT [Id], [Nome] 
    FROM [Curso]
    ORDER BY [Nome] -- ASC/DESC


Aula 16. Update
---------------

    UPDATE [Categoria]
    SET [Nome] = 'Backend'
    WHERE [Id] = 1


Aula 17. Delete
---------------




