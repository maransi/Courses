Fundamentos do Entity Framework - Balta
---------------------------------------

https://www.entityframeworktutorial.net/
https://entityframework.net/ef-code-first
https://www.tutorialspoint.com/entity_framework/index.htm


INTRODUÇÃO
----------


Aula 2. Ferramentas
-------------------

. Este curos é continuação do curso Fundamentos C#, OOP, SQL Server e Dapper.

. Utilizaremos:

    Umas das plataformas Windows. MAC, Ou Linux
    NET 5 ou superior
    Azure Data Studio
    SQL Server
    VS Code

. Instalação do Docker

	. Instalação

		. Instalação nas distribuições baseadas no Ubuntu:

			. A URL abaixo tem os passos atualizado para instalação do Docker:

				https://docs.docker.com/engine/install/ubuntu/

			. Instalação Atualizada

				sudo apt-get update
				sudo apt-get install \
					ca-certificates \
					curl \
					gnupg \
					lsb-release

				curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

				echo \
					"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
					$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

				sudo apt-get update
				sudo apt-get install docker-ce docker-ce-cli containerd.io
				sudo docker --version

				sudo groupadd docker
				sudo gpasswd -a <usuario> docker
				sudo chown "$USER":"$USER" /var/run/docker.sock -R
				sudo service docker restart

				docker --version

		. Instalação no Mint

			sudo apt-get update
			cd Downloads/
			sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common
			curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
			sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(. /etc/os-release; echo "$UBUNTU_CODENAME") stable"
			sudo apt-get update
			sudo apt-get -y install docker-ce docker-compose
			sudo usermod -aG docker $USER
			docker --version

            sudo groupadd docker
            sudo gpasswd -a <usuario> docker
            sudo chown "$USER":"$USER" /var/run/docker.sock -R
            sudo service docker restart

            docker --version

. Instalando o .NET Core SDK

    . Instalçao Atualizada:

        . URL com informações para realizar a instalação.

            https://docs.microsoft.com/pt-br/dotnet/core/install/linux-ubuntu

            . IMPORTANTE: Acesse a instalação da distribuição e versão especifica do linux que estamos utilizando para 
                            proceder os comandos adequadamente.

                            A instalação abaixo está para o Ubuntu 20.04

        # Comando para o Ubuntu 22.04 em diante
        # wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.0g-2ubuntu4_amd64.deb
        # sudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb

        # Instalação do SDK
        wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
        sudo dpkg -i packages-microsoft-prod.deb

        sudo dpkg --purge packages-microsoft-prod && sudo dpkg -i packages-microsoft-prod.deb
        sudo apt-get update

        sudo apt-get install -y gpg
        wget -O - https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor -o microsoft.asc.gpg
        sudo mv microsoft.asc.gpg /etc/apt/trusted.gpg.d/
        wget https://packages.microsoft.com/config/ubuntu/20.04/prod.list
        sudo mv prod.list /etc/apt/sources.list.d/microsoft-prod.list
        sudo chown root:root /etc/apt/trusted.gpg.d/microsoft.asc.gpg
        sudo chown root:root /etc/apt/sources.list.d/microsoft-prod.list

        # Comando para o Ubuntu 22.04 em diante
        # wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.0g-2ubuntu4_amd64.deb
        # sudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb

        sudo apt-get update; \
        sudo apt-get install -y apt-transport-https && \
        sudo apt-get update && \
        sudo apt-get install -y dotnet-sdk-5.0

        sudo apt-get install -y apt-transport-https && \
        sudo apt-get update && \
        sudo apt-get install -y aspnetcore-runtime-5.0

        sudo apt-get install -y dotnet-runtime-5.0


. Instalando o VS Code

    Instalação das extensões do VSCode

            C# 
            C# Extensions
            C# XML Documentation Comments
            vscode-icons (Opcional)
            Docker

        . Atalhos:

            Ctrl + K + D ou Shit + Alt + F:             Identa todo o seu código automaticamente;
            Ctrl + K + C:                               comenta um bloco de linhas;
            Ctrl + K + U:                               descomenta um bloco de linhas;
            Alt + Left Arrow:                           durante a programação, volta um método que você estava navegando;
            Alt + Right Arrow:                          durante a programação, avança um método que você estava navegando;
            Ctrl + .:                                   implementa o método/classe inexistente que você acabou de escrever;
            Ctrl + M + O:                               esconde todas as regions da classe atual;
            Ctrl + Shift + B:                           compila todos os projetos;
            F5:                                         manda depurar um projeto;
            Ctrl + F5:                                  manda executar um projeto;
            F10:                                        durante a depuração, avança uma linha;
            F11:                                        durante a depuração, avança uma linha entrando nos detalhes da mesma;


    Configurar Visual Studio Code para .NETCore

        . Acesse File / Preferences / Settings

        . Digite C#

        . Acesse "C# Configuration / CSharp Format Enabled" e habilite a configuração

        . Digite "Format on save" e habilite a configuração

        . Digite "Final" e habilite a configuração "Files: Insert final newline" e habilite a configuração


. Instalando o SQL Server

    https://docs.microsoft.com/pt-br/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash
    https://docs.microsoft.com/pt-br/sql/linux/sql-server-linux-setup-tools?view=sql-server-ver15#ubuntu


    docker container run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=<password>"    -p 1433:1433 --name sqlserver --hostname sqlserver    -d mcr.microsoft.com/mssql/server:2019-latest
    docker container ps -a
    docker container exec -t sqlserver cat /var/opt/mssql/log/errorlog | grep connection

    # Testar no linux, não funcionou no windows
    docker container exec -it sqlserver /opt/mssql-tools/bin/sqlcmd -S localhost -U SA  -P "$(read -sp "Enter current SA password: "; echo "${REPLY}")"  -Q "ALTER LOGIN SA WITH PASSWORD=\"$(read -sp "Enter new SA password: "; echo "${REPLY}")\""

    # Execute os comandos abaixo ao entrar no container
    #
    # hostname -I
    # ip a
    docker exec -it sqlserver "bash"

    curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
    curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list
    sudo apt-get update 
    sudo apt-get install mssql-tools unixodbc-dev
    sudo apt-get update 
    sudo apt-get install mssql-tools
    echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bash_profile
    echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bashrc
    source ~/.bashrc
    
    # Execute o comando abaixo e substitua o endereço IP do comando "sqlcmd" pelo adquirido no "hostname -I"
    #
    # hostname -I
    sqlcmd -S 192.168.0.82,1433 -U SA -P "<password>"


    # Execute os comandos abaixo dentro do sqlcmd
    EXEC sp_databases
    GO

    EXEC sp_helpdb    
    GO

    SELECT name FROM master..sysdatabases ORDER BY name
    GO

    EXEC sp_msForEachDB 'PRINT ''?'''
    GO

    EXIT

. Instalando Azure Data Studio

    . Para Linux siga os passos abaixo:

        Acessar o link abaixo para fazer o download do arquivo .deb:

            https://go.microsoft.com/fwlink/?linkid=2169956

        cd ~
        sudo dpkg -i ./Downloads/azuredatastudio-linux-<version string>.deb
        azuredatastudio

    . Para Windows acesse o link abaixo:

        https://docs.microsoft.com/pt-br/sql/azure-data-studio/download-azure-data-studio?view=sql-server-ver15    




https://entityframework.net/ef-code-first
https://www.entityframeworktutorial.net/code-first/simple-code-first-example.aspx
https://www.tutorialspoint.com/entity_framework/entity_framework_environment_setup.htm#



Aula 3. ORM
-----------

    . ORM - Object Relational Mapping

    . Responsável por fazer o de-para das tabelas para os objetos de classes.

    . Substitui o desenvolvimento de SQL pelo mapeamento das classes de forma que criem os objetos
        automaticamente.


Aula 4. Entity Framework
------------------------

    . O EF é um framework

    . É um conjunto de bibliotecas, muito mais poderoso, complexo e pesado do que o Dapper.

    . Permite trabalhar com CRUD, Migrações.


    .NET Core Command-Line Interface (CLI)    
    --------------------------------------

        . Digite no terminal "dotnet --info" para apresentar informações variadas da instação do dotnet

        . Digite no terminal "dotnet new" irá apresentar as várias possibilidades de criar diversos projetos, exemplo:

            dotnet new mvc

            dotnet run

            #Acesse o navegador e digite a URL: https://localhost:5001/ para ver o resultado do projeto criado.

        . Ctrl + C no terminal acaba com a execução do projeto:

        https://www.infoq.com/br/articles/netcore-cli/    

    . Instalar pacotes através do Nuget.org
    ---------------------------------------

        https://www.nuget.org/packages/Microsoft.EntityFrameworkCore/7.0.0-preview.4.22229.2#versions-body-tab

        . Ao ser compilada, uma biblioteca gera um arquivo DLL. Será esta DLL que os outros projetos irão utilizar. 
            O NuGet aproveita desta característica da plataforma para definir seus pacotes.

        . Na prática, um pacote NuGet é um arquivo compactado com a extensão .nupkg que contém um código compilado (DLL), 
            outros arquivos relacionados a este código (como imagens, etc.) e um arquivo de configuração que contém 
            informações sobre o pacote, como: número de versão, criador, etc.

        . Estes pacotes .nupkg podem ser publicados em repositórios públicos ou privados, onde os desenvolvedores podem 
            consumi-los, adicionando-os em seus projetos e utilizando no código as funcionalidades que fornecerem.

        . Em se tratando de projeto, como se fosse as dependências de bibliotecas.

        . Acesse o site nuget.org, digite "Microsoft Entity Framework Core" e faça a pesquisa.

        . Acesse o item Microsoft.EntityFrameworkCore.

        . Acesse uma das versões, atualmente 5.0.5.
        
        . Acesse a aba .NetCli.

        . Copie o comando sugerido por esse caminho:

            dotnet add package Microsoft.EntityFrameworkCore --version 5.0.5

        . Acesse o terminal, vá na pasta do projeto e execute o comando acima. Cuidado é necessário acessar a pasta do projeto
            e não da solução, exemplo: ~/workspace-two/CSharpBasico/helloWorld.


        . Após a execução, no terminal, execute um dos comandos abaixo:

            dotnet restore

            ou

            dotnet build

        . Acesse o Visual Studio Code "code ." para entrar no projeto e acesse o arquivo com extensão "*.csproj". Podemos verificar 
            que agora temos o pacote dentro da aplicação:

            <ItemGroup>
                <PackageReference Include="Microsoft.EntityFrameworkCore" Version="5.0.5" />
            </ItemGroup>

        . Retorne ao Home do site nuget.org e digite "Pomelo Entity Framework core" e acesse o link do MySQL.

        . Acesse a aba "PackageReference" e copie o comando sugerido:

        . Acesse novamente o arquivo com a extensão *.csproj e insira a dependência copiada dentro do nó "ItemGroup":

            <ItemGroup>
                <PackageReference Include="Microsoft.EntityFrameworkCore" Version="5.0.5" />
                <PackageReference Include="Pomelo.EntityFrameworkCore.MySql" Version="5.0.0-alpha.2" />    
            </ItemGroup>

        . Salve o conteúdo do arquivo, o VsCode irá pedir para dar o "Restore", confirme o restore.

        . Se quiser podemos dar o "dotnet restore", ou o "dotnet build", no terminal.

        . Caso haja a necessidade de retirar alguma dependência do nó "ItemGroup", acesse o terminal, e execute os comandos abaixo:

            dotnet clean
            dotnet restore

Aula 4. DataContext
-------------------

    . DB Context - Uma instância DbContext representa uma combinação da unidade de padrões de trabalho e de repositório, 
                    de modo que ele possa ser usado para consultar de um banco de dados e agrupar alterações que serão 
                    gravadas novamente no armazenamento como uma unidade. DbContext é conceitualmente semelhante a 
                    ObjectContext.

        . As classes de contexto derivam da "System.Data.e/ntity.DbContextDbContext".
        . Uma instância de uma classe de contexto representa a unidade de trabalho e segue o "pattern" "Repository".
        . Pode combinar várias transações numa simples transação.
        . Usada para consultar e salvar dados
        . Usada para configurar classes de domínio, mapeamento de relacionamento, cache, transação, etc.

        . Exemplo:

            using System.Data.Entity;

            public class SchoolContext : DbContext
            {
                public SchoolContext()
                {

                }
                // Entities        
                public DbSet<Student> Students { get; set; }
                public DbSet<StudentAddress> StudentAddresses { get; set; }
                public DbSet<Grade> Grades { get; set; }
            } 
    
    . DBSet - Um DbSet representa a coleção de todas as entidades no contexto ou que pode ser consultada a partir do 
                banco de dados, de um determinado tipo. Os objetos DbSet são criados a partir de um DbContext usando 
                o método DbContext.


Aula 5. Restaurando o banco
---------------------------

    . Levante o docker do SQL Server.

    . No Azure Data Studio, acesse o banco de dados do docker e execute o script abaixo:

        CREATE DATABASE [Blog]
        GO

        USE [Blog]
        GO

        -- DROP TABLE [User]
        -- DROP TABLE [Role]
        -- DROP TABLE [UserRole]
        -- DROP TABLE [Post]
        -- DROP TABLE [Category]
        -- DROP TABLE [Tag]
        -- DROP TABLE [PostTag]

        CREATE TABLE [User] (
            [Id] INT NOT NULL IDENTITY(1, 1),
            [Name] NVARCHAR(80) NOT NULL,
            [Email] VARCHAR(200) NOT NULL,
            [PasswordHash] VARCHAR(255) NOT NULL,
            [Bio] TEXT NOT NULL,
            [Image] VARCHAR(2000) NOT NULL,
            [Slug] VARCHAR(80) NOT NULL,

            CONSTRAINT [PK_User] PRIMARY KEY([Id]),
            CONSTRAINT [UQ_User_Email] UNIQUE([Email]),
            CONSTRAINT [UQ_User_Slug] UNIQUE([Slug])
        )
        CREATE NONCLUSTERED INDEX [IX_User_Email] ON [User]([Email])
        CREATE NONCLUSTERED INDEX [IX_User_Slug] ON [User]([Slug])

        CREATE TABLE [Role] (
            [Id] INT NOT NULL IDENTITY(1, 1),
            [Name] VARCHAR(80) NOT NULL,
            [Slug] VARCHAR(80) NOT NULL,

            CONSTRAINT [PK_Role] PRIMARY KEY([Id]),
            CONSTRAINT [UQ_Role_Slug] UNIQUE([Slug])
        )
        CREATE NONCLUSTERED INDEX [IX_Role_Slug] ON [Role]([Slug])

        CREATE TABLE [UserRole] (
            [UserId] INT NOT NULL,
            [RoleId] INT NOT NULL,

            CONSTRAINT [PK_UserRole] PRIMARY KEY([UserId], [RoleId])
        )

        CREATE TABLE [Category] (
            [Id] INT NOT NULL IDENTITY(1, 1),
            [Name] VARCHAR(80) NOT NULL,
            [Slug] VARCHAR(80) NOT NULL,

            CONSTRAINT [PK_Category] PRIMARY KEY([Id]),
            CONSTRAINT [UQ_Category_Slug] UNIQUE([Slug])
        )
        CREATE NONCLUSTERED INDEX [IX_Category_Slug] ON [Category]([Slug])

        CREATE TABLE [Post] (
            [Id] INT NOT NULL IDENTITY(1, 1),
            [CategoryId] INT NOT NULL,
            [AuthorId] INT NOT NULL,
            [Title] VARCHAR(160) NOT NULL,
            [Summary] VARCHAR(255) NOT NULL,
            [Body] TEXT NOT NULL,
            [Slug] VARCHAR(80) NOT NULL,
            [CreateDate] DATETIME NOT NULL DEFAULT(GETDATE()),
            [LastUpdateDate] DATETIME NOT NULL DEFAULT(GETDATE()),

            CONSTRAINT [PK_Post] PRIMARY KEY([Id]),
            CONSTRAINT [FK_Post_Category] FOREIGN KEY([CategoryId]) REFERENCES [Category]([Id]),
            CONSTRAINT [FK_Post_Author] FOREIGN KEY([AuthorId]) REFERENCES [User]([Id]),
            CONSTRAINT [UQ_Post_Slug] UNIQUE([Slug])
        )
        CREATE NONCLUSTERED INDEX [IX_Post_Slug] ON [Post]([Slug])

        CREATE TABLE [Tag] (
            [Id] INT NOT NULL IDENTITY(1, 1),
            [Name] VARCHAR(80) NOT NULL,
            [Slug] VARCHAR(80) NOT NULL,

            CONSTRAINT [PK_Tag] PRIMARY KEY([Id]),
            CONSTRAINT [UQ_Tag_Slug] UNIQUE([Slug])
        )
        CREATE NONCLUSTERED INDEX [IX_Tag_Slug] ON [Tag]([Slug])

        CREATE TABLE [PostTag] (
            [PostId] INT NOT NULL,
            [TagId] INT NOT NULL,

            CONSTRAINT PK_PostTag PRIMARY KEY([PostId], [TagId])
        )


Aula 6 e 7. Criando os modelo - Parte 1 e 2
-------------------------------------------

    . Acesse a pasta local de projetos e execute o comando:

        dotnet new console -o Blog -n blog -f net5.0

    . Abra o VsCode e abra a pasta do projeto criado anteriormente.

    . Crie uma pasta no projeto com o nome "Models"

    . Crie a classe "User" dentro da pasta "Models" conforme o código abaixo:

        namespace Blog.Models
        {
            public class User
            {
                public int Id { get; set; }
                public string Name { get; set; }
                public string Email { get; set; }
                public string PasswordHash { get; set; }
                public string Image { get; set; }
                public string Slug { get; set; }
                public string Bio { get; set; }
            }
        }

    . Crie a classe "Role" dentro da pasta "Models" conforme o código abaixo:

        namespace Blog.Models
        {
            public class Role
            {
                public int Id { get; set; }
                public string Name { get; set; }
                public string Slug { get; set; }
            }
        }

    . Crie a classe "UserRole" dentro da pasta "Models" conforme o código abaixo:

        namespace Blog.Models
        {
            public class UserRole
            {
                public int UserId { get; set; }
                public int RoleId { get; set; }
            }
        }

    . Crie a classe "Category" dentro da pasta "Models" conforme o código abaixo:

        namespace Blog.Models
        {
            public class Category
            {
                public int Id { get; set; }
                public string Name { get; set; }
                public string Slug { get; set; }
            }
        }

    . Crie a classe "Tag" dentro da pasta "Models" conforme o código abaixo:

        using System.ComponentModel.DataAnnotations;
        using System.ComponentModel.DataAnnotations.Schema;

        namespace Blog.Models
        {
            public class Tag
            {
                public int Id { get; set; }
                public string Name { get; set; }
                public string Slug { get; set; }
            }
        }

    . Crie a classe "Post" dentro da pasta "Models" conforme o código abaixo:

        using System;

        namespace Blog.Models
        {
            public class Post
            {
                public int Id { get; set; }
                public int CategoryId { get; set; }
                public int AuthorId { get; set; }
                public string Title { get; set; }
                public string Summary { get; set; }
                public string Body { get; set; }
                public string Slug { get; set; }
                public DateTime CreateDate { get; set; }
                public DateTime LastUpdateDate { get; set; }
            }
        }

    . Crie a classe "PostTag" dentro da pasta "Models" conforme o código abaixo:

        namespace Blog.Models
        {
            public class PostTag
            {
                public int PostId { get; set; }
                public int TagId { get; set; }
            }
        }

Aula 8 - DbSet
--------------

    . Acesse a pasta raiz do projeto e execute os comandos abaixo:

        dotnet add package Microsoft.EntityFrameworkCore --version 5.0.9        
        
        dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 5.0.9

    . Crie a pasta "Data" dentro do projeto e crie a classe "BlogDataContext.cs" com o código abaixo:

        using Blog.Models;
        using Microsoft.EntityFrameworkCore;

        namespace Blog.Data
        {
            public class BlogDataContext : DbContext
            {

                // Devido a problema de chaves, as linhas comentadas referem-se a classes onde a chave primária são chaves composta
                // Mais a frente iremos configurar esses tipos de classes

                public DbSet<Category> Categories { get; set; }
                public DbSet<Post> Posts { get; set; }
                // public DbSet<PostTag> PostTags { get; set; }
                public DbSet<Role> Roles { get; set; }
                public DbSet<Tag> Tags { get; set; }
                public DbSet<User> Users { get; set; }
                // public DbSet<UserRole> UserRoles { get; set; }

                protected override void OnConfiguring(DbContextOptionsBuilder options)
                    => options.UseSqlServer("Server=localhost,1433;Database=Blog;User ID=sa;Password=<password>");
            }
        }

    . A partir deste momento se formos na classe "Program.cs", criarmos a classe de "context", já estará
        visivel os "DbContext":

        . Insira as linhas abaixo na classe "Program.cs":

            ...
            class Program
            {
                static void Main( string[] args)
                {
                    ...

                    var ctx = new BlogDataContext();

                    ctx.Categories();   // Já está visivel
                }
            }

        . O código acima é somente como exemplo, porque precisa de algumas configurações no "model"

Aula 9 - Configurando o DAtaContext
-----------------------------------

    . O método "OnConfiguring" é o local onde faremos a conexão com o banco de dados.

    . Altere o código do método "Main" da classe "Program.cs":

        ...
        static void Main( string[] args ){
            using( var context = new BlogDataContext() ){

            }
        }
        ...


Aula 10. Create
---------------

    . Acesse a classe "Tag.cs" e inclua as linhas abaixo:

        ...
        using System.ComponentModel.DataAnnotations;            // Linha inserida
        using System.ComponentModel.DataAnnotations.Schema;     // Linha inserida
        namespace Blog.Models
        {
            [Table("Tag")]                                      // Linha inserida
            public class Tag
            {
                [Key]                                           // Linha inserida
                public int Id { get; set; }

                ...
            }
        }

    . Altere o código do método "Main" da classe "Program.cs":

        ...
        static void Main( string[] args ){
            using( var context = new BlogDataContext() ){

                var tag = new Tag { Name = "ASP.NET", Slug = "aspnet" };    // Linha inserida

                context.Tags.Add( tag );                                    // Linha inserida

            }
        }
        ...

    . Execute o projeto e verifique no banco se a linha acima foi criada com sucesso na tabela "tag"

        . IMPORTANTE: Ela não foi criada, porque o "context" é um banco em memória, para efetivar a inserção
                        no banco é necessário usar o comando "context.SaveChanges()"

    . Insira a linha abaixo no método "Main" da classe "Program.cs":


        ...
        static void Main( string[] args ){
            using( var context = new BlogDataContext() ){

                var tag = new Tag { Name = "ASP.NET", Slug = "aspnet" };    

                context.Tags.Add( tag );                                    

                context.SaveChanges();              // Linha inserida

            }
        }
        ...

    . Execute o projeto e verifique no banco se a linha acima foi criada com sucesso na tabela "tag"


Aula 11. Update
---------------

    . Altere o método "Main" como abaixo:

        ...
        static void Main( string[] args ){
            using( var context = new BlogDataContext() ){

                // var tag = new Tag { Name = "ASP.NET", Slug = "aspnet" };    

                // context.Tags.Add( tag );                                    

                // context.SaveChanges();              

                var tag = context.Tags.FirstOrDefault( x => x.Id == 2 );    // Linha inserida

                tag.Name = ".NET";                                      // Linha inserida

                tag.Slug = "dotnet";                                    // Linha inserida

                context.Update( tag );                                  // Linha inserida
                context.SaveChanges();              // Linha inserida
            }
        }
        ...

    . Execute o projeto e verifique no banco se a linha acima foi criada com sucesso na tabela "tag"

    . Quando fazemos a localização de uma ocorrência "context.Tags.FirstOrDefault" o EF traz diversas 
        informações do banco conhecida como METADADOS (Última atualização, data da criação, versão atual e a
        que está no banco ). Dessa forma que o EF consegue comparar as informações são alteradas dos DBSet.
        Por isso precisamos trazer as informações do banco para que o EF possa realizar essas comparações.

Aula 12. Delete
---------------

    . Altere o método "Main" como abaixo:

        ...
        static void Main( string[] args ){
            using( var context = new BlogDataContext() ){

                // var tag = new Tag { Name = "ASP.NET", Slug = "aspnet" };    

                // context.Tags.Add( tag );                                    

                // context.SaveChanges();              

                var tag = context.Tags.FirstOrDefault( x => x == 2 )    

                // tag.Name = ".NET";                                      

                // tag.Slug = "dotnet";                              

                // context.Update( tag )      

                context.Remove( tag );              // Linha inserida
                context.SaveChanges();              
            }
        }
        ...

    . Execute o projeto e verifique no banco se a linha acima foi criada com sucesso na tabela "tag"


Aula 13. ToList
---------------


    . Altere o método "Main" como abaixo:

        . Apague as linhas no interior do método "Main" e substitua pela abaixo:

            ...
            static void Main( string[] args ){
                using( var context = new BlogDataContext() ){

                    var tag1 = new Tag { Name = "ASP.NET", Slug = "aspnet" };    

                    context.Tags.Add( tag1 );                                    

                    var tag2 = new Tag { Name = ".NET", Slug = "aspnet" };    

                    context.Tags.Add( tag2 );                                    

                    context.SaveChanges();              
                }
            }
            ...

        . Execute o projeto.

        . Altere o método "Main" novamente.

            using System.Linq;
            ...
            static void Main( string[] args ){
                using( var context = new BlogDataContext() ){

                    // var tag1 = new Tag { Name = "ASP.NET", Slug = "aspnet" };    

                    // context.Tags.Add( tag1 );                                    

                    // var tag2 = new Tag { Name = ".NET", Slug = "aspnet" };    

                    // context.Tags.Add( tag2 );                                    

                    // context.SaveChanges();              

                    // Execute o select internamente
                    var tags = context.Tags.ToList();

                    foreach( var tag in tags ){
                        System.Console.Write($"{tag.Name}");
                    }
                }
            }
            ...

        . Execute o projeto.

    . Algumas formas de executar o ToList()

        var tags = context
                    .Tags
                    .ToList()
                    .Where( x => x.Name.Contains(".NET"));  // Neste caso o filtro será aplicado em memória
                                                            // acarretando em lentidão

        var tags = context
                    .Tags
                    .Where( x => x.Name.Contains(".NET"))  // Neste caso o filtro será aplicado no banco no SQL
                    .ToList();

        . IMPORTANTE: A segunda forma é a mais rápida, dê preferência sempre colocar o "Where(...)" antes do "ToList()".

        var tags = context
                    .Tags
                    .FromSqlRaw($"Select Id, Name, Slug from Tag Where Slug = '{description}'")
                    .ToList();



Aula 14. AsNoTracking
---------------------

    var tags = context
                .Tags
                .AsNoTracking()
                .ToList();

    . O "AsNoTracking" não traz as informações do METADADO. Deixando mais rápido as consultas ao usar "ToList".

    . IMPORTANTE: Quando utilizar ".Update()" ".Remove()" não use "AsNoTracking", porque para essas operações
                    precisam saber detalhes de chaves, alterações, etc. para efetivar a alteração
                    no banco.

    . É necessário fazer o import abaixo:

        using Microsoft.EntityFrameworkCore;                



Aula 15. First, Single
----------------------

    . Diferença entre "FirstOrDefault", "First", "Single"

        . FirtsOrDefault        - Se tiver mais de um registro no banco o EF trará somente a primeira ocorrência
        . First                 - Se tiver mais de um registro no banco o EF dará erro
        . Single                - Idem, dará erro



OPERAÇÕES BÁSICAS
-----------------

Aula 16. DataAnnotations
------------------------

    . Tipos:

        . Fluent Mapping

            . Mapeamento fluente
            . Feito em uma classe externa
            . Não "polui" a classe principal
            . Não cria dependências na classe/projeto principal

        . Data Annotations

            . Feitos diretamente nas classes
            . Mais simples e diretos
            . Depende do System.ComponentModel.DataAnnotations
                . Alguns dependem do Microsof.EntityFrameworkCore 


    System.ComponentModel.DataAnnotations Attributes
    ------------------------------------------------

    Attribute	        Description
    ---------           -----------

    Key	                Can be applied to a property to specify a key property in an entity and make the 
                        corresponding column a PrimaryKey column in the database.

        using System.ComponentModel.DataAnnotations;

        public class Student
        {
            [Key]
            public int StudentKey { get; set; }
            public string StudentName { get; set; }
        }

    Timestamp	        Can be applied to a property to specify the data type of a corresponding column 
                        in the database as rowversion.

        EF 6 and EF Core both include the Timestamp data annotation attribute. It can only be applied once 
        in an entity class to a byte array type property. It creates a column with timestamp data type in 
        the SQL Server database. Entity Framework API automatically uses this Timestamp column in 
        concurrency check on the UPDATE statement in the database.

            using System.ComponentModel.DataAnnotations;

                public class Student
                {
                    public int StudentId { get; set; }
                    public string StudentName { get; set; }
                        
                    [Timestamp]
                    public byte[] RowVersion { get; set; }
                }

    ConcurrencyCheck	Can be applied to a property to specify that the corresponding column should be 
                        included in the optimistic concurrency check.

        The ConcurrencyCheck attribute can be applied to one or more properties in an entity class in EF 6 
        and EF Core. When applied to a property, the corresponding column in the database table will be 
        used in the optimistic concurrency check using the where clause.

            using System.ComponentModel.DataAnnotations;

            public class Student
            {
                public int StudentId { get; set; }
                
                [ConcurrencyCheck]
                public string StudentName { get; set; }
            }

        In the above example, the ConcurrencyCheck attribute is applied to the StudentName property of the 
        Student entity class. So, EF will include the StudentName column in the UPDATE statement to check 
        for optimistic concurrency. Consider the following example.

            using(var context = new SchoolContext()) 
            {
                var std = new Student()
                {
                    StudentName = "Bill"
                };

                context.Students.Add(std);
                context.SaveChanges();

                std.StudentName = "Steve";
                context.SaveChanges();
            }

        The above example will execute the following UPDATE statement on SaveChanges(), where it includes 
        StudentName in the where clause.

            exec sp_executesql N'UPDATE [dbo].[Students]
            SET [StudentName] = @0
            WHERE (([StudentId] = @1) AND ([StudentName] = @2))
            ',N'@0 nvarchar(max) ,@1 int,@2 nvarchar(max) ',@0=N'Steve',@1=1,@2=N'Bill'
            go            

    Required	        Can be applied to a property to specify that the corresponding column is a 
                        NotNull column in the database.

        The Required attribute can be applied to one or more properties in an entity class. EF will 
        create a NOT NULL column in a database table for a property on which the Required attribute is 
        applied.

            using System.ComponentModel.DataAnnotations;
                
            public class Student
            {
                public int StudentID { get; set; }
                [Required]
                public string StudentName { get; set; }
            }


    MinLength	        Can be applied to a property to specify the minimum string length allowed in 
                        the corresponding column in the database.

        The MinLength attributes allow you to specify additional property validations. It is applied to a 
        property to specify a minimum number of characters or bytes for the column that the property should map to.

        The following example specifies that the Title column in the Books table must have a minimum length of 5 characters.

            public class Book
            {
                public int BookId { get; set; }
                [MinLength(5)]
                public string Title { get; set; }
            }

    MaxLength	        Can be applied to a property to specify the maximum string length allowed in 
                        the corresponding column in the database.

        The MaxLength attribute specifies the maximum length of data value allowed for a property which in 
        turn sets the size of a corresponding column in the database. It can be applied to the string or 
        byte[] properties of an entity.

            using System.ComponentModel.DataAnnotations;
                
            public class Student
            {
                public int StudentID { get; set; }
                [MaxLength(50)]
                public string StudentName { get; set; }
                    
            }

    StringLength	    Can be applied to a property to specify the maximum string length allowed in the 
                        corresponding column in the database.

        The StringLength attribute can be applied to the string properties of an entity class. It specifies 
        the maximum characters allowed for a string property which in turn sets the size of a corresponding 
        column (nvarchar in SQL Server) in the database.

        using System.ComponentModel.DataAnnotations;

        public class Student
        {
            public int StudentID { get; set; }
            [StringLength(50)]
            public string StudentName { get; set; }
        }




    System.ComponentModel.DataAnnotations.Schema Attributes
    -------------------------------------------------------

    Attribute	        Description
    ---------           -----------

    Table	            Can be applied to an entity class to configure the corresponding table name and 
                        schema in the database.

        Table Attribute: [Table(string name, Properties:[Schema = string])

        name: Name of the Db table.
        Schema: Name of the Db Schema in which a specified table should be created. (Optional)
        using System.ComponentModel.DataAnnotations.Schema;

        [Table("StudentMaster")]
        public class Student
        {
            public int StudentID { get; set; }
            public string StudentName { get; set; }
        }

    Column	            Can be applied to a property to configure the corresponding column name, order 
                        and data type in the database.

        [Column (string name, Properties:[Order = int],[TypeName = string])

        name: Name of a column in a db table.
        Order: Order of a column, starting with zero index. (Optional)
        TypeName: Data type of a column. (Optional)
        The following example changes the name of a column.

        using System.ComponentModel.DataAnnotations.Schema;

        public class Student
        {
            public int StudentID { get; set; }
            
            [Column("Name")]
            public string StudentName { get; set; }
            public DateTime? DateOfBirth { get; set; }
            public byte[] Photo { get; set; }
            public decimal Height { get; set; }
            public float Weight { get; set; }
        }

    Index	            Can be applied to a property to configure that the corresponding column should 
                        have an Index in the database. (EF 6.1 onwards only)

        Entity Framework 6 provides the [Index] attribute to create an index on a particular column in the database, 
        as shown below:

            class Student
            {
                public int Student_ID { get; set; }
                public string StudentName { get; set; }
                    
                [Index]
                public int RegistrationNumber { get; set; }
            }

        By default, the index name will be IX_{property name}. However, you can change the index name.

        You can also make it a clustered index by specifying IsClustered = true or create a unique index by 
        specifying IsUnique=true.

            [Index( "INDEX_REGNUM", IsClustered=true, IsUnique=true )]
            public int RegistrationNumber { get; set; }


    NotMapped	        Can be applied to a property or entity class which should be excluded from the 
                        model and should not generate a corresponding column or table in the database.

        NotMapped Attribute: [NotMapped()]

        using System.ComponentModel.DataAnnotations.Schema;

        public class Student
        {
            public int StudentId { get; set; }
            public string StudentName { get; set; }
                
            [NotMapped]
            public int Age { get; set; }
        }


    InverseProperty	    Can be applied to a property to specify the inverse of a navigation property that 
                        represents the other end of the same relationship.

        https://www.entityframeworktutorial.net/code-first/inverseproperty-dataannotations-attribute-in-code-first.aspx

    ComplexType	        Marks the class as complex type in EF 6. EF Core 2.0 does not support this attribute.

https://www.entityframeworktutorial.net/code-first/table-dataannotations-attribute-in-code-first.aspx



Aula 17. Table, Key e Identity
------------------------------

    https://www.learnentityframeworkcore.com/configuration/data-annotation-attributes/databasegenerated-attribute
    https://www.entityframeworktutorial.net/code-first/databasegenerated-dataannotations-attribute.aspx    

    DatabaseGenerated	Can be applied to a property to configure how the underlying database should 
                        generate the value for the corresponding column e.g. identity, computed or none.

        a. Computed

            [DatabaseGenerated(DatabaseGeneratedOption.Computed)]


            The Computed option specifies that the property's value will be generated by the database when
            the value is first saved, and subsequently regenerated every time the value is updated. The 
            practical effect of this is that Entity Framework will not include the property in INSERT or UPDATE 
            statements, but will obtain the computed value from the database on retrieval.

            Entity Framework Core will not implement a value generation strategy. Database providers differ 
            in the way that values are automatically generated. Some will generate values for selected data 
            types such as Identity, rowversion, GUID. Others may require manual configuration such as setting 
            default values or triggers, or configuring the column as Computed.

        b. Identity
            
            [DataBaseGenerated(DatabaseGeneratedOption.Identity)]

            The Identity option specifies that the value will only be generated by the database when a value 
            is first added to the database. Thereafter, the property will not be included in UPDATE statements 
            by Entity Framework.

            Again, Entity Framework Core will not implement a value generation strategy. Database providers 
            differ in the way that values are automatically generated. Some will generate values for selected 
            data types such as Identity, rowversion, GUID.

            In the following example, the annotation is used to configure the Created property in the Contact 
            entity. Since the property is required, Entity Framework will configure a default value of 
            DateTime.MinValue. You can override this by setting a default value in the entity's constructor or 
            by initializing an auto-implemented property (as illustrated here):

                public class Contact
                {
                    public int Id { get; set; }
                    public string FullName { get; set; }
                    public string Email { get; set; } 
                    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
                    public DateTime Created { get; set; } = DateTime.UtcNow;
                }

        c. None

            [DatabaseGenerated(DatabaseGeneratedOption.None)

            DatabaseGeneratedOption.None option specifies that the value of a property will not be generated by 
            the underlying database. This will be useful to override the default convention for the id properties.

            For example, if you want to provide your own values to id properties instead of database generated 
            values, use the None option, as shown below.

                public class Course
                {
                    [DatabaseGenerated(DatabaseGeneratedOption.None)]
                    public int CourseId { get; set; }
                    public string CourseName { get; set; }
                }

            In the above example, EF will create the CourseId column in the database and will not mark it as an 
            IDENTITY column. So, each time you will have to provide the value of the CourseId property before 
            calling the SaveChanges() method.

                using (var context = new SchoolContext())
                {
                    // you must provide the unique CourseId value
                    var maths = new Course(){ CourseId=1,  CourseName="Maths"};
                    context.Courses.Add(maths);

                    // you must provide the unique CourseId value
                    var eng = new Course(){ CourseId=2,  CourseName="English"};
                    context.Courses.Add(eng);

                    // the following will throw an exception as CourseId has duplicate value
                    //var sci = new Course(){ CourseId=2,  CourseName="sci"};

                    context.SaveChanges();
                }

            Note: EF will throw an exception if you do not provide unique values each time because CourseId is a 
                  primary key property.


    . Acesse a classe "Category.cs" e faça as alterações abaixo:

        using System.ComponentModel.DataAnnotations;            // Linha inserida
        using System.ComponentModel.DataAnnotations.Schema;     // Linha inserida

        namespace Blog.Models
        {
            [Table("Category")]                                 // Linha inserida
            public class Category
            {
                [Key]                                           // Linha inserida
                [DatabaseGenerated(DatabaseGeneratedOption.Identity)]   // Linha inserida
                public int Id { get; set; }
                public string Name { get; set; }
                public string Slug { get; set; }
            }
        }


Aula 18. Required, MaxLength e Column
-------------------------------------

    . Acesse a classe "Category.cs" e faça as alterações abaixo:

        ...
        namespace Blog.Models
        {
            [Table("Category")]                                 
            public class Category
            {
                [Key]                                           
                [DatabaseGenerated(DatabaseGeneratedOption.Identity)]   
                public int Id { get; set; }

                [Required]                              // Linha inserida
                [MinLength(3)]                          // Linha inserida
                [MaxLength(80)]                         // Linha inserida
                [Column( "Name", TypeName= "NVARCHAR")] // Linha inserida
                public string Name { get; set; }

                [Required]                              // Linha inserida
                [MinLength(3)]                          // Linha inserida
                [MaxLength(80)]                         // Linha inserida
                [Column( "Slug", TypeName= "VARCHAR")] // Linha inserida
                public string Slug { get; set; }
            }
        }


Aula 19. Navigation Properties
------------------------------

    ForeignKey	        Can be applied to a property to mark it as a foreign key property.

        The [ForeignKey(name)] attribute can be applied in three ways:

        a. [ForeignKey] on the foreign key property in the dependent entity

            The [ForeignKey] on the foreign key property in the dependent entity and the related navigation property 
            name can be specified as a parameter as shown below.

                using System.ComponentModel.DataAnnotations.Schema;

                public class Student
                {
                    public int StudentID { get; set; }
                    public string StudentName { get; set; }
                        
                    [ForeignKey("Standard")]
                    public int StandardRefId { get; set; }
                    public Standard Standard { get; set; }
                }

                public class Standard
                {
                    public int StandardId { get; set; }
                    public string StandardName { get; set; }
                    
                    public ICollection<Student> Students { get; set; }
                }

            In the above example, the [ForeignKey] attribute is applied on the StandardRefId and specified in the name of 
            the navigation property Standard. This will create the foreign key column named StandardRefId in the Students 
            table, preventing the generation of a StandardId column in the database.

        b. [ForeignKey] on the navigation property in the dependent entity

            The [ForeignKey] attribute can be applied to the navigation property and the related foreign key 
            property name can be specified as shown below.

                using System.ComponentModel.DataAnnotations.Schema;

                public class Student
                {
                    public int StudentID { get; set; }
                    public string StudentName { get; set; }
                        
                    public int StandardRefId { get; set; }
                    
                    [ForeignKey("StandardRefId")]
                    public Standard Standard { get; set; }
                }

                public class Standard
                {
                    public int StandardId { get; set; }
                    public string StandardName { get; set; }
                    
                    public ICollection<Student> Students { get; set; }
                }

            In the above example, the [ForeignKey] attribute is applied on the Standard navigation property and the name 
            of the foreign key property StandardRefId is specified. This will create the foreign key column named 
            StandardRefId in the Students table, preventing the generation of a StandardId column in the database.

        c. [ForeignKey] on the navigation property in the principal entity

            The [ForeignKey] attribute can be applied to the navigation property in the principal entity and the related 
            foreign key property name can be specified in the dependent entity, as shown below.

            using System.ComponentModel.DataAnnotations.Schema;

            public class Student
            {
                public int StudentID { get; set; }
                public string StudentName { get; set; }
                    
                public int StandardRefId { get; set; }
                public Standard Standard { get; set; }
            }

            public class Standard
            {
                public int StandardId { get; set; }
                public string StandardName { get; set; }
                
                [ForeignKey("StandardRefId")]
                public ICollection<Student> Students { get; set; }
            }

            In the above example, the [ForeignKey] attribute is applied on the Students navigation property in the principal 
            entity Standard. This will create a foreign key column StandardRefId in the Students table in the database.

        . O Entity Framework utiliza a nomenclatura do parâmetro fornecido para descobrir a classe e o campo para encontrar a 
            referẽncia, por exemplo:

                                 +--> Nome da propriedade
                                 |
                                 --
            [ForeignKey("CategoryId")]
                         --------  
                            |
                            +-> Nome da classe

    . Acesse as demais classes do projeto e implemente as "Annotation" conforme acima.

        . Acesse a classse User.cs e insira as linhas abaixo:

            using System.ComponentModel.DataAnnotations;            // Linha inserida
            using System.ComponentModel.DataAnnotations.Schema;     // Linha inserida

            namespace Blog.Models
            {
                [Table("User")]             // Linha inserida
                public class User
                {
                    [Key]                   // Linha inserida
                    [DatabaseGenerated( DatabaseGeneratedOption.Identity)]  // Linha inserida
                    public int Id { get; set; }

                    [Required]                              // Linha inserida
                    [MinLength(3)]                          // Linha inserida
                    [MaxLength(80)]                         // Linha inserida
                    [Column( "Name", TypeName= "VARCHAR")] // Linha inserida
                    public string Name { get; set; }

                    public string Email { get; set; }
                    public string PasswordHash { get; set; }
                    public string Image { get; set; }
                    public string Slug { get; set; }
                    public string Bio { get; set; }
                }
            }

        . Acesse a classse Post.cs e insira as linhas abaixo:

            using System.ComponentModel.DataAnnotations;            // Linha inserida
            using System.ComponentModel.DataAnnotations.Schema;     // Linha inserida

            namespace Blog.Models
            {
                [Table("Post")]                 // Linha inserida
                public class Post
                {
                    [Key]                       // Linha inserida
                    [DatabaseGenerated( DatabaseGeneratedOption.Identity)]      // Linha inserida
                    public int Id { get; set; }


                    [ForeignKey("CategoryId")]            // Linha inserida
                    public int CategoryId { get; set; }

                    public Category Category{ get; set; }     // Linha inserida

                    [ForeignKey("AuthorId")]                  // Linha inserida
                    public int AuthorId { get; set; }

                    public User Author { get; set; }          // Linha inserida

                    public string Title { get; set; }
                    public string Summary { get; set; }
                    public string Body { get; set; }
                    public string Slug { get; set; }
                    public DateTime CreateDate { get; set; }
                    public DateTime LastUpdateDate { get; set; }
                }
            }
        
        . Se quiser podemos anotar a "ForeignKey" diretamente nas propriedades que representa as classes, 
            informando o nome do campo chave para fazer o relacionamento:

            ...
            public int CategoryId { get; set; }

            [ForeignKey("CategoryId")]
            public Category Category {get; set;}

            public int AuthorId { get; set; }

            [ForeignKey("AuthorId")]
            public User Author {get; set;}
            ...

        . Nesse caso podemos comentar as propriedades "CategoryId" e "AuthorId", porém as DMLs fabricadas
            terão "LEFT JOIN" e não "INNER JOIN" nos critérios de relacionamento:

            ...
            // public int CategoryId { get; set; }

            [ForeignKey("CategoryId")]
            public Category Category {get; set;}

            // public int AuthorId { get; set; }

            [ForeignKey("AuthorId")]
            public User Author {get; set;}
            ...

    . Insira o método abaixo na classe "Program.cs":

        ...
        private static void InsertPost(){

            using var context = new BlogDataContext();

            var user = new User
            {
                Name = "André Baltieri",
                Slug = "andrebaltieri",
                Email = "andre@balta.io",
                Bio = "9x Microsoft MVP",
                Image = "https://balta.io",
                PasswordHash = "123098457"
            };
            
            var category = new Category {Name = "Backend", Slug = "backend"};
            
            var post = new Post
            {
                Author = user,
                Category = category,
                Body = "<p>Hello world</p>",
                Slug = "comecando-com-ef-core",
                Summary = "Neste artigo vamos aprender EF core",
                Title = "Começando com EF Core",
                CreateDate = DateTime.Now,
                LastUpdateDate = DateTime.Now,
            };
            
            context.Posts.Add(post); // Não adicionei autor nem categoria
            context.SaveChanges();            
        }
        ...

    . Insira a linha abaixo no método "Main" da classe "Program.cs", execute e veja o resultado

        ...
        class Program
        {
            static void Main(string[] args)
            {
                ...
                InsertPost();
                ...
            }
        }
        ...


Aula 20. Include
----------------

    . Insira o método abaixo na classe "Program.cs":

        ...
        private static void GetAllPost()
        {
            using( var context = new BlogDataContext() ){
                // var posts = context
                //             .Posts
                //             .ToList();
                var posts = context
                    .Posts
                    .AsNoTracking()
                    .Include(x => x.Author)
                    .Include(x => x.Category)
                    .OrderBy(x => x.LastUpdateDate)
                    .ToList();                                

                foreach( Post post in posts ){
                    System.Console.WriteLine($"{post.Id} - {post.Title} - {post.Author.Name} - {post.Category.Name} - {post.LastUpdateDate}");
                }
            }
        }
        ...

        . Por padrão o Entity Framework utiliza o conceito LAZY LOAD (Carregar os objetos dependentes quando realmente 
            for necessário), onde não carrega as informações dos objetos filho associado ao objeto pai.

        . Para resgatar os valores desses objetos dependentes precisamos utilizar o método ".include( x => x.<class> )"

        . Outra maneira de evitar erros durante a execução é colocar o caracter de interrogação "?" ao lado do nome da classe:

            ...
            foreach( Post post in posts ){
                System.Console.WriteLine($"{post.Id} - {post.Title} - {post.Author?.Name} - {post.Category?.Name} - {post.LastUpdateDate}");
            }                                                                     |                       |  
            ...                                                                   +-----------------------+-----> Evita erro em tempo de compilação
                                                                                                                  qdo tiver valor nulo

    . Insira a linha abaixo no método "Main" da classe "Program.cs", execute e veja o resultado

        ...
        class Program
        {
            static void Main(string[] args)
            {
                ...
                GetAllPost();
                ...
            }
        }
        ...


Aula 21. Log
------------

    . Altere o método "onConfiguring" da classe "BlogDataContext.cs" como abaixo:

        ...
        protected override void OnConfiguring( DbContextOptionsBuilder options ){
            options.UseSqlServer("Server=localhost,1433;Database=Blog;User ID=sa;Password=Joao3.16");            
            options.LogTo( Console.WriteLine );
        }
        ...
    
    . Execute o projeto e verifique se as DML estão saindo no log do terminal.

    . Existe a propriedade ".ThenInclude( x => x.<class> )" para pegar a propriedade de um objeto do filho
   

Aula 22. Alterando um subconjunto
---------------------------------

    . Crie o método "UpdatePostAuthorName" na classe "Program.cs":

        ...
        private static void UpdatePostAuthorName(){
            var post = context
                .Posts
                .Include(x => x.Author)
                .Include(x => x.Category)
                .OrderBy(x => x.LastUpdateDate)
                .FirstOrDefault(); // Pegando o primeiro item
            
            post.Author.Name = "Uncle Bob";
            
            context.Posts.Update(post);
            context.SaveChanges();
        }
        ...

    . Faça a chamada deste método no método "Main":

        ...
        UpdatePostAuthorName();
        ...

    . Execute o projeto e verifique se o conteúdo do campo "Name" do "Author" foi alterado com sucesso.


Aula 23. Introdução
-------------------    

    . Acesse todos as classes models e retire todas as "annotations"


Aula 24. Iniciando o Mapeamento
-------------------------------

    . Pesquisar mais sobre "Fluent Mapping":

        https://www.tektutorialshub.com/entity-framework-core/ef-core-fluent-api/
        https://www.entityframeworktutorial.net/efcore/fluent-api-in-entity-framework-core.aspx
        https://www.learnentityframeworkcore.com/configuration/fluent-api
        https://geeksarray.com/blog/using-fluent-api-in-efcore-code-first
        https://www.c-sharpcorner.com/article/entity-framework-core-code-first-approach-with-fluent-api/

    . Crie a pasta "Mappings" na pasta "Data" do projeto.

    . Crie a classe "CategoryMap.cs" dentro da pasta "Mapping" com o código abaixo:

        namespace Blog.Data.Mappings{

            public class CategoryMap: IEntityTypeConfiguration<Category>{
                public void Configure( EntityTypeBuilder<Category> builder){
                    builder.ToTable("Category");
                }
            }
        }

    . ".ToTable( <Classe Model> )"  Configures the database table that the entity maps to.


Aula 25. Chave Primária e Identity
----------------------------------

    . Altere a classe "CategoryMap.cs" com o código abaixo:

        namespace Blog.Data.Mappings{

            public class CategoryMap: IEntityTypeConfiguration<Category>{
                public void Configure( EntityTypeBuilder<Category> builder){
                    ...
                    
                    // Chave Primária
                    builder.HasKey( x => x.Id );        // Linha inserida

                    // Identity
                    builder.Property( x => x.Id )       // Linha inserida
                            .ValueGeneratedOnAdd()
                            .UseIdentityColumn();
                }
            }
        }

    . ".HasKey( ... )"  Configures the property or list of properties as Primary Key.

    . ".Property()"     provides a range of options for configuring entity properties using the Fluent API:

        . ".ValueGeneratedOnAdd()"  Indicates that the value for the selected property is generated by the database 
                                    whenever a new entity is added to the database.
        . ".UseIdentityColumn()"    Configura a propriedade chave para usar o recurso de identidade de SQL Server 
                                    para gerar valores para novas entidades ao direcionar SQL Server.

Aula 26. Mapeando Propriedades
------------------------------

    . Acesse a classe "CategoryMap.cs" e insira as linhas abaixo:



        namespace Blog.Data.Mappings: IEntityTypeConfiguration<Category>{

            public class CategoryMap{
                public void Configure( EntityTypeBuilder<Category> builder){
                    ...
    
                    // Propriedades
                    builder.Property(x => x.Name)       // Linha inserida
                        .IsRequired()
                        .HasColumnName("Name")
                        .HasColumnType("NVARCHAR")
                        .HasMaxLength(80);

                    builder.Property(x => x.Slug)       // Linha inserida
                        .IsRequired()
                        .HasColumnName("Slug")
                        .HasColumnType("VARCHAR")
                        .HasMaxLength(80);    
                }
            }
        }

    . ".IsRequired"        Configures the database column as not nullable

    . ".HasColumnName"      Specifies the name of the database column that the property should map to

    . ".HasColumnType"      Specifies the data type of the database column that the property should map to

    . ".HasMaxLength"       Specifies maximum length of data that can be stored for strings or binary data (arrays)


Aula 27. Indíces
----------------

    . Acesse a classe "CategoryMap.cs" e insira as linhas abaixo:

        namespace Blog.Data.Mappings: IEntityTypeConfiguration<Category>{

            public class CategoryMap{
                public void Configure( EntityTypeBuilder<Category> builder){
                    ...
                    // Índices
                    builder                             // Linha inserida
                        .HasIndex(x => x.Slug, "IX_Category_Slug")
                        .IsUnique();
                    ...
                    }
                }
            }

    . ".HasIndex"           method is used to create a database index on the column mapped to the specified 
                            entity property

        . Exemplo para uso de chaves compostas:

            public class SampleContext : DbContext
            {
                public DbSet<Patient> Patients { get; set; }
                protected override void OnModelCreating(ModelBuilder modelBuilder)
                {
                    modelBuilder.Entity<Patient>()
                        .HasIndex(p => new { p.Ssn, p.DateOfBirth});    // Chave Composta
                }
            }
            public class Patient
            {
                public int PatientId { get; set; }
                public string Ssn { get; set; }
                public DateTime DateOfBirth { get; set; }
            }


Aula 28. Iniciando o mapeamento do User
---------------------------------------

    . Acesse a classe "User.cs" e implemente os métodos abaixo:

        namespace Blog.Models
        {
            public class User
            {
                ...
                public IList<Post> Posts {get; set; }       // Linha Inserida

                public IList<Role> Roles {get; set;}        // Linha Inserida
            }
        }

    . Acesse a classe "Post" e implemente os métodos abaixo:

        namespace Blog.Models
        {
            public class Post
            {
                ...
                public IList<Tag> Tags { get; set; }        // Linha inserida
            }
        }

    . Acesse a classe "Tag" e implemente os métodos abaixo:

        namespace Blog.Models
        {
            public class Tag
            {
                ...

                public IList<Post> Posts { get; set; }      // Linha inserida
            }
        }

    . Acesse a classe "Role" e implemente o código abaixo:

        namespace Blog.Models
        {
            public class Role
            {
                ...

                public IList<User> Users {get; set;}        // Linha Inserida
            }
        }

    . Crie a classe "UserMap.cs" na pasta "Data.Mappings":

        using System.Collections.Generic;
        using Blog.Models;
        using Microsoft.EntityFrameworkCore;
        using Microsoft.EntityFrameworkCore.Metadata.Builders;

        namespace Blog.Data.Mappings
        {
            public class UserMap : IEntityTypeConfiguration<User>
            {
                public void Configure(EntityTypeBuilder<User> builder)
                {
                    // Tabela
                    builder.ToTable("User");

                    // Chave Primária
                    builder.HasKey(x => x.Id);

                    // Identity
                    builder.Property(x => x.Id)
                        .ValueGeneratedOnAdd()
                        .UseIdentityColumn();

                    // Propriedades
                    builder.Property(x => x.Name)
                        .IsRequired()
                        .HasColumnName("Name")
                        .HasColumnType("NVARCHAR")
                        .HasMaxLength(80);

                    builder.Property(x => x.Bio);
                    builder.Property(x => x.Email);
                    builder.Property(x => x.Image);
                    builder.Property(x => x.PasswordHash);

                    builder.Property(x => x.Slug)
                        .IsRequired()
                        .HasColumnName("Slug")
                        .HasColumnType("VARCHAR")
                        .HasMaxLength(80);

                    // Índices
                    builder
                        .HasIndex(x => x.Slug, "IX_User_Slug")
                        .IsUnique();
                }
            }
        }    


Aula 29. Default Values
-----------------------

    . Crie a classe "PostMap.cs" com o código abaixo na pasta "Data.Mapping":

        using System;
        using System.Collections.Generic;
        using Blog.Models;
        using Microsoft.EntityFrameworkCore;
        using Microsoft.EntityFrameworkCore.Metadata.Builders;

        namespace Blog.Data.Mappings
        {
            public class PostMap : IEntityTypeConfiguration<Post>
            {
                public void Configure(EntityTypeBuilder<Post> builder)
                {
                    // Tabela
                    builder.ToTable("Post");

                    // Chave Primária
                    builder.HasKey(x => x.Id);

                    // Identity
                    builder.Property(x => x.Id)
                        .ValueGeneratedOnAdd()
                        .UseIdentityColumn();

                    // Propriedades
                    builder.Property(x => x.LastUpdateDate)
                        .IsRequired()
                        .HasColumnName("LastUpdateDate")
                        .HasColumnType("SMALLDATETIME")
                        .HasMaxLength(60)
                        .HasDefaultValueSql("GETDATE()");           // <--- Valor Default
                    // .HasDefaultValue(DateTime.Now.ToUniversalTime());    // <-- Valor Default

                    // Índices
                    builder
                        .HasIndex(x => x.Slug, "IX_Post_Slug")
                        .IsUnique();

                }
            }
        }

        . Abaixo as linhas utilizadas para criar um valor padrão/default, foi dado preferência
            a função nativa do banco "GETDATE()" ao invés da função C#
        
            .HasDefaultValueSql("GETDATE()");           // <--- Valor Default
            // .HasDefaultValue(DateTime.Now.ToUniversalTime());    // <-- Valor Default


Aula 30. Relacionamento Um para Muitos
--------------------------------------

    . Acesse a classe "PostMap.cs" e insira as linhas abaixo:

        namespace Blog.Data.Mappings
        {
            public class PostMap : IEntityTypeConfiguration<Post>
            {
                public void Configure(EntityTypeBuilder<Post> builder)
                {
                    ...

                    // Relacionamentos                              // Linhas inseridas
                    builder
                        .HasOne(x => x.Author)
                        .WithMany(x => x.Posts)
                        .HasConstraintName("FK_Post_Author")
                        .OnDelete(DeleteBehavior.Cascade);

                    builder
                        .HasOne(x => x.Category)
                        .WithMany(x => x.Posts)
                        .HasConstraintName("FK_Post_Category")
                        .OnDelete(DeleteBehavior.Cascade);

                }
            }
        }


Aula 31. Relacionamento Muitos para Muitos
------------------------------------------

    . Acesse a classe "PostMap.cs" e insira as linhas abaixo:

https://www.learnentityframeworkcore.com/configuration/many-to-many-relationship-configuration
https://www.thereformedprogrammer.net/updating-many-to-many-relationships-in-ef-core-5-and-above/
https://dev.to/ruben_j/many-to-many-relations-in-entity-framework-core-3-1-and-5-59ei


        namespace Blog.Data.Mappings
        {
            public class PostMap : IEntityTypeConfiguration<Post>
            {
                public void Configure(EntityTypeBuilder<Post> builder)
                {
                    ...
                    // Relacionamentos                              // Linhas Inseridas
                    builder
                        .HasMany(x => x.Tags)
                        .WithMany(x => x.Posts)
                        .UsingEntity<Dictionary<string, object>>(       // Representação do relacionamento muitos para muitos
                            "PostTag",
                            post => post
                                .HasOne<Tag>()
                                .WithMany()
                                .HasForeignKey("PostId")
                                .HasConstraintName("FK_PostRole_PostId")
                                .OnDelete(DeleteBehavior.Cascade),
                            tag => tag
                                .HasOne<Post>()
                                .WithMany()
                                .HasForeignKey("TagId")
                                .HasConstraintName("FK_PostTag_TagId")
                                .OnDelete(DeleteBehavior.Cascade));
                }
            }
        }
    

        . Para representar a classe de relacionamento "muitos para muitos" utilizamos o código 
            abaixo:

            .UsingEntity<Dictionary<string, object>>(
                "PostTag",
                post => post
                    .HasOne<Tag>()
                    .WithMany()
                    .HasForeignKey("PostId")
                    .HasConstraintName("FK_PostRole_PostId")
                    .OnDelete(DeleteBehavior.Cascade),
                tag => tag
                    .HasOne<Post>()
                    .WithMany()
                    .HasForeignKey("TagId")
                    .HasConstraintName("FK_PostTag_TagId")
                    .OnDelete(DeleteBehavior.Cascade));

        . Para se ter acesso ao Objeto "Dictionary" fazemos a seguinte importação:

            using System.Collections.Generic;


Aula 32. Utilizando os Mapeamentos Criados
------------------------------------------

    . Acesse a classe "UserMap.cs" e implemente o código abaixo:

        namespace Blog.Data.Mappings
        {
            public class UserMap : IEntityTypeConfiguration<User>
            {
                public void Configure(EntityTypeBuilder<User> builder)
                {
                    ...
                    // Relacionamentos
                    builder
                        .HasMany(x => x.Roles)
                        .WithMany(x => x.Users)
                        .UsingEntity<Dictionary<string, object>>(
                            "UserRole",
                            role => role
                                .HasOne<Role>()
                                .WithMany()
                                .HasForeignKey("RoleId")
                                .HasConstraintName("FK_UserRole_RoleId")
                                .OnDelete(DeleteBehavior.Cascade),
                            user => user
                                .HasOne<User>()
                                .WithMany()
                                .HasForeignKey("UserId")
                                .HasConstraintName("FK_UserRole_UserId")
                                .OnDelete(DeleteBehavior.Cascade));
                }
            }
        }

    . Acesse a classe "BlogDataContext.cs" e verifique se a declaração dos "DbSet" estão conforme abaixo:

        using Blog.Data.Mappings;               // Linha inserida
        using Blog.Models;                      // Linha Inserida
        using Microsoft.EntityFrameworkCore;

        namespace Blog.Data
        {
            public class BlogDataContext : DbContext
            {
                public DbSet<Category> Categories { get; set; }

                public DbSet<Post> Posts { get; set; }

                public DbSet<User> Users { get; set; }


                ...

                protected override void OnModelCreating(ModelBuilder modelBuilder)      // Método inserido
                {
                    modelBuilder.ApplyConfiguration(new CategoryMap());
                    modelBuilder.ApplyConfiguration(new UserMap());
                    modelBuilder.ApplyConfiguration(new PostMap());
                }                
            }
        }

Aula 32.1 - Um pouco mais sobre relacionamentos
-----------------------------------------------

    . Insira as classes abaixo na pasta "Models" no projeto:

        // Classe Investidor
        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;

        namespace Blog.Models
        {
            public class Investidor
            {
                public int  Id { get; set; }
                public string Nome { get; set; }

                public IList<Aplicacao> Aplicacoes { get; set; }
                
            }
        }


        // Classe Instituicao
        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;

        namespace Blog.Models
        {
            public class Instituicao
            {
                public int Id { get; set; }
                public string Nome { get; set; }
                public string Rating { get; set; }

                public IList<Aplicacao> Aplicacoes { get; set; }
            }
        }


        // Classe Aplicacao
        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;

        namespace Blog.Models
        {
            public class Aplicacao
            {
                public int Id { get; set; }
                public string Titulo { get; set; }
                public DateTime DataAplicacao { get; set; }
                public string Indice { get; set; }
                public decimal PercentualRemuneracao { get; set; }
                public decimal  ValorInvestido { get; set; }
                public decimal ValorAtualizado { get; set; }
                public DateTime? DataFechamento { get; set; }
                public DateTime Vencimento { get; set; }
                public int? InstituicaoId { get; set; }
                public Instituicao Instituicao { get; set; }

                public int? InvestidorId { get; set; }
                public Investidor Investidor { get; set; }
            }
        }

    . Insira as classes abaixo na pasta "Data.Mapping":

        // Classe InvestidorMap

        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using Blog.Models;
        using Microsoft.EntityFrameworkCore;
        using Microsoft.EntityFrameworkCore.Metadata.Builders;

        namespace Blog.Data.Mapping
        {
            public class InvestidorMap : IEntityTypeConfiguration<Investidor>
            {
                public void Configure(EntityTypeBuilder<Investidor> builder)
                {
                    builder.ToTable("Investidor");

                    builder.HasKey( x => x.Id );

                    builder.Property( x => x.Id )
                            .ValueGeneratedOnAdd()
                            .UseIdentityColumn();

                    builder.Property( x => x.Nome )
                            .IsRequired()
                            .HasColumnName("Nome")
                            .HasColumnType("VARCHAR")
                            .HasMaxLength(50);
        
                    builder.HasMany( x => x.Aplicacoes )
                            .WithOne( i => i.Investidor )
                            .IsRequired();
                }
            }
        }

        // Classe InstituicaoMap

        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using Blog.Models;
        using Microsoft.EntityFrameworkCore;
        using Microsoft.EntityFrameworkCore.Metadata.Builders;

        namespace Blog.Data.Mapping
        {
            public class InstituicaoMap : IEntityTypeConfiguration<Instituicao>
            {
                public void Configure(EntityTypeBuilder<Instituicao> builder)
                {
                    builder.ToTable("Instituicao");

                    builder.HasKey( x => x.Id );

                    builder.Property( x => x.Id )
                            .ValueGeneratedOnAdd()
                            .UseIdentityColumn();

                    builder.Property( x => x.Nome )
                            .IsRequired()
                            .HasColumnName("Nome")
                            .HasColumnType("VARCHAR")
                            .HasMaxLength(50);

                    builder.Property( x => x.Rating )
                            .HasColumnName( "Rating")
                            .HasColumnType("VARCHAR")
                            .HasMaxLength(5);
                }
            }
        }


        // Classe AplicacaoMap

        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading.Tasks;
        using Blog.Models;
        using Microsoft.EntityFrameworkCore;
        using Microsoft.EntityFrameworkCore.Metadata.Builders;

        namespace Blog.Data.Mapping
        {
            public class AplicacaoMap : IEntityTypeConfiguration<Aplicacao>
            {
                public void Configure(EntityTypeBuilder<Aplicacao> builder)
                {
                    builder.ToTable("Aplicacao");

                    builder.HasKey( x => x.Id );

                    builder.Property( x => x.Titulo)
                            .IsRequired()
                            .HasColumnName("Titulo")
                            .HasColumnType("VARCHAR")
                            .HasMaxLength(50);

                    builder.Property( x => x.DataAplicacao )
                            .HasColumnName("DataAplicacao")
                            .HasColumnType("DATE")
                            .IsRequired()
                            .HasDefaultValueSql("GETDATE()");

                    builder.Property( x => x.Indice)
                            .IsRequired()
                            .HasColumnName("Indice")
                            .HasColumnType("VARCHAR")
                            .HasMaxLength(15);

                    builder.Property( x => x.PercentualRemuneracao )
                            .IsRequired()
                            .HasColumnName("PercentualRemuneracao")
                            .HasColumnType("DECIMAL(5,2)");

                    builder.Property( x => x.ValorInvestido )
                            .IsRequired()
                            .HasColumnName("ValorInvestido")
                            .HasColumnType("MONEY");

                    builder.Property( x => x.ValorAtualizado )
                            .IsRequired()
                            .HasColumnName("ValorAtualizado")
                            .HasColumnType("MONEY");
                    
                    builder.Property( x => x.DataFechamento )
                            .HasColumnName("DataFechamento")
                            .HasColumnType("DATE")
                            .HasDefaultValueSql("GETDATE()");

                    builder.Property( x => x.Vencimento )
                            .HasColumnName("Vencimento")
                            .HasColumnType("DATETIME");

                    builder.Property( x => x.InvestidorId )
                            .IsRequired(false)
                            .HasColumnName("InvestidorId")
                            .HasColumnType("INT");

                    builder.HasOne( x => x.Investidor )
                            .WithMany( i => i.Aplicacoes )
                            .IsRequired();

                    builder.HasIndex( x => x.InvestidorId );
                    
                    builder.Property( x => x.InstituicaoId )
                            .IsRequired(false)                      // Força a coluna da tabela ficar "NULL"
                            .HasColumnName("InstituicaoId")
                            .HasColumnType("INT");

                    builder.HasOne( x => x.Instituicao )
                            .WithMany( a => a.Aplicacoes )
                            .IsRequired();                          // Força as DMLs de SELECT ficar como "INNER JOIN"

                    builder.HasIndex( x => x.InstituicaoId );
                }
            }
        }

    . Dentro da Classe "BlogDataContext.cs" e no método "OnModelCreating" insira as linhas abaixo:

            ...
            modelBuilder.ApplyConfiguration(new InvestidorMap());
            modelBuilder.ApplyConfiguration(new InstituicaoMap());
            modelBuilder.ApplyConfiguration(new AplicacaoMap());
            ...

    . Relacionamento 1:1

        . Na classe             



    . Relacionamento 1:N

        . Na classe "Investidor" temos uma lista de "Aplicacao":

            ...
            public IList<Aplicacao> Aplicacoes { get; set; }
            ...
        
        . Para configurar essa lista num relacionamento 1:N teremos que configurar
            na classe de mapeamento "InvestidorMap" a seguinte configuração:


                public void Configure(EntityTypeBuilder<Investidor> builder)
                {
                    builder.ToTable("Investidor");

                    ...
                    builder.HasMany( x => x.Aplicacoes )        // Nome da lista Investidor.Aplicacoes
                            .WithOne( i => i.Investidor )       // Objeto que representa o "Investidor" na classe "Aplicacao"
                            .IsRequired();                                                                            |
                }                                                                                                     |
                                                                                                                      |
        . Para que o relacionamento 1:N execute com sucesso é obrigatorio que a classe da lista "Aplicacao",          |
            tenha um método getter/setter apontando para a classe pai "Investidor"                                    |
                                                                                                                      |
                ...                                                                                                   |
                public Investidor Investidor { get; set; }     <------------------------------------------------------+                                     
                ...

            . Não é obrigatório fornecer o parâmetro de identificação do objeto pai ".WithOne( i => i.Investidor )"
                como foi feito. Podemos omiti-lo:

                .WithOne()          // A execução continua a mesma

        . .IsRequired()     Era para funcionar e permitir que a lista "Aplicacoes" da classe "Investidor" fosse opcional
                            e assim deixar a DML de SELECT como INNER JOIN, porém no relacionamento 1:N não funcionou;
                            já no relacionamento 1:1 funcionou corretamente.

            . O ".IsRequired()" trabalha de formas diferentes dependendo de onde for colocado:

                . Se for colocado nas configurações de relacionamento ele definirá se haverá "INNER", ou "LEFT" JOIN

                    builder.HasOne( x => x.Instituicao )
                            .WithMany( a => a.Aplicacoes )
                            .IsRequired();                          // Força as DMLs de SELECT ficar como "INNER JOIN"

                . Se for colocado nas configurações da propriedade do campo em si "InvestidorId" ela definirá se 
                    o campo receberá "Null/Not Null":

                    builder.Property( x => x.InstituicaoId )
                            .IsRequired(false)                      // Força a coluna da tabela ficar "NULL"
                            .HasColumnName("InstituicaoId")
                            .HasColumnType("INT");

        . Na classe da lista (N) coloque a propriedade do "Id" do objeto pai se realmente for necessário ter uma perfomance
            durante a obtenção das informações, caso contrário não é obrigatório ter essa propriedade como apresentado na
            classe "Aplicacao.InvestidorId". Se colocar será para:
            
            . Criar um indice; 
            . Ou fazer uma pesquisa performática na classe destino pelo "Id" da classe pai; 
            . Ou para identificá-lo como um campo que poderá receber nulo, como foi o caso da propriedade 
                "public int? InstituicaoId { get; set; }" nesta classe, onde foi utilizado o caracter "?"
                ao lado do tipo "int". No final a estrutura no banco ficará como "null".



Aula 33. Testando os relacionamentos
------------------------------------

    . Acesse a classe "Program.cs" e implemente o código abaixo no método "Main":

        using Blog.Data;

        namespace Blog
        {
            class Program
            {
                static void Main(string[] args)
                {
                    using var context = new BlogDataContext();

                    context.Users.Add( new User{
                                                Name = "André Baltieri",
                                                Slug = "andrebaltieri",
                                                Email = "andre.baltieri@balta.io",
                                                Bio = "9x Microsoft MVP",
                                                Image = "https://balta.io",
                                                PasswordHash = "123098456"
                                            });
                    
                    context.SaveChanges();
                }
            }
        }

    . Execute o projeto e verifique se o "User" acima foi criado no banco

    . Comente o insert do "User" acima e implemente as linhas abaixo no método "Main":

        ...
        var user = context.Users.FindOrDefault<User>();

        var post = new Post{
            Author = user,
            Body = "Meu Artigo",
            Catgory = new Category{ Name = "Backend",
                                    Slug = "backend"
                            },
            CreateDate = System.DateTime.Now,
            Slug = "meu-artigo",
            Summary = "Neste artigo vamos conferir...",
            Title = "Meu Artigo"
        };

        context.Posts.add( post );
        context.SaveChanges();

        . As propriedades "LastUpdateDate" e "Tags" não foram informadas para testar os valores "DEfault".


    . Execute o projeto e verifique se o "User", "Category" e "Post" foram criadas no banco




Aula 34. Introdução a Relacionamentos
-------------------------------------

    . Apague o database "balta" do banco de dados com os comandos abaixo:

        USE [master]
        GO

        ALTER DATABASE [Blog] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
        GO

        DROP DATABASE [Blog]
        GO

    . Acesse a classe "Program.cs", apague todo o conteúdo do corpo do método "Main" e todos os métodos dela.

    . Acesse a pasta raiz do projeto e execute o comando abaixo:

        # https://www.nuget.org/packages/dotnet-ef/#versions-body-tab
        dotnet tool install --global dotnet-ef --version 5.0.17

        dotnet add package Microsoft.EntityFrameworkCore.Design --version 5.0.9

    . Acesse a pasta raiz do projeto e execute o comando abaixo para testar a instação do "dotnet-ef":

        dotnet ef


Aula 35. Criando uma Migração
-----------------------------

    . Acesse a pasta raiz do projeto e execute as linhas abaixo:

        dotnet clean

        dotnet build

        dotnet ef migrations add InitialCreation


Aula 36. Atualizando o banco
----------------------------

    . Acesse a pasta raiz do projeto e execute as linhas abaixo:

        dotnet ef database update

    . Acesse o banco de dados pelo Azure Studio e verifique se o database foi criado com 
        sucesso, juntamente com as tabelas.

    . A medida que nossas classes de entidades vão sendo alteradas podemos criar um novo script
        de alteração de banco com o comando abaixo:

        dotnet ef migrations add <nome do script>

    . Para apagar um script utilize o comando abaixo:

        # O comanda abaixo irá remover a última migração
        dotnet ef migrations remove  


Aula 37. Gerando uma nova versão do banco
-----------------------------------------

    . Acesse a classe "User" e inclua a propriedade abaixo:

        ...
        public string GitHub { get; set; }
        ...

    . Acesse a classe "UserMap" e inclua a propriedade abaixo:

        ...
        builder.Property(x => x.Bio);
        builder.Property(x => x.Email);
        builder.Property(x => x.Image);
        builder.Property(x => x.PasswordHash);

        builder.Property( x => x.GitHub );          // Linha inserida

        builder.Property(x => x.Slug)
            .IsRequired()
            .HasColumnName("Slug")
            .HasColumnType("VARCHAR")
            .HasMaxLength(80);
        ...

    . Acesse a pasta raiz do projeto e execute as linhas abaixo:

        dotnet clean

        dotnet build

        dotnet ef migrations add AdicionadoCampoGitHub

        dotnet ef database update 

    . Acesse o banco de dados e verifique se o campo "GitHub" foi criado com sucesso


Aula 38. Gerando o script do banco
----------------------------------

    . Para desabilitar a migração, basta:
    
        . Apagar a pasta "Migrations".
        
        . Apagar a tabela "__EFMigrationsHistory"
        
        . Apagar a biblioteca "Design":

            dotnet add package Microsoft.EntityFrameworkCore.Design  -v 5.0.9   

    . Apague o database "balta" do banco de dados com os comandos abaixo:

        USE [master]
        GO

        ALTER DATABASE [Blog] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
        GO

        DROP DATABASE [Blog]
        GO

    . Acesse a pasta raiz do projeto e execute as linhas abaixo:

        dotnet clean

        dotnet build

        dotnet ef migrations add InitialCreation

    . Execute o comando abaixo para gerar o script:

        dotnet ef migrations script -o ./script.sql

        . O comando acima irá criar na pasta raiz do projeto o arquivo "script.sql"

    . Acesse o "Azure Data Studio" digite as linhas abaixo, copie o conteúdo do "script.sql" abaixo das
        linhas e execute os comandos:

        CREATE DATABASE Blog
        GO

        USE Blog
        GO

        # Copie o script daqui em diante

    . Acesse o database "Blog" e verifique se todas as tabelas foram criadas com sucesso:


Aula 39. AsNoTracking
---------------------

    . Toda vez que o sistema requisita informações do banco de dados via Entity Framework, o ORM mantém na 
        memória objetos adicionais a fim de manter a rastreabilidade (tracking) de mudanças nos objetos 
        resgatados da base de dados, a fim de saber se um comando “UPDATE” precisa realmente ser executado 
        caso o método “SaveChanges” seja chamado.

    . Caso em rotinas do sistema que você está desenvolvendo existam operações apenas “readonly”, recomendo 
        que utilize o método AsNoTracking.


Aula 40. Async e Await - Processamento em paralelo
--------------------------------------------------

    . await     Informa que o processamento deve retornar ao chamador e retornar ao processamento corrente 
                quando ele terminar

    . async     Sempre que for necessário usar o "await" é obrigatório identificar no método que ele é 
                assincrono "async"

    . .<metodo>Async  Para fazer uso do processamento assincrono é necessário executar um método que 
                        termine com "Async", por exemplo: "ToLisAsync()", ".FirstOrDefaultAsync()", etc. 

    . Material complementar:

        https://www.youtube.com/watch?v=sYBhpA-ZEHI
        https://www.youtube.com/watch?v=LdkoxF_2k8Y

    . Acesse o banco de dados e dê carga na tabela "Category" caso não tenho registros:

        INSERT INTO Category( Name, Slug )
        VALUES('FICCAO', 'ficcao'),
                ('ACAO', 'acao'),
                ('COMEDIA', 'comedia'),
                ('SUSPENSE', 'suspense'),
                ('POLICIAL', 'policial'),
                ('RELIGIOSO', 'religioso'),
                ('FANTASIA','fantasia'),
                ('FAROESTE', 'faroeste')

    . Acesse a classe "Program.cs" e insira o método abaixo:

        ...
        private static void GetAllCategory()
        {
            using( var context = new BlogDataContext()){
                var categories = context
                                .Categories
                                .ToList();


                categories.ForEach( item => { 
                    System.Console.WriteLine($"{item.Id} - {item.Name} - {item.Slug}");
                } );
            }
        }

        ...

    . Acesse o método "Main" e insira a chamada do método acima:

        ...
        GetAllCategory()

        System.Console.Write("Aguardando...");

        System.Console.ReadLine();

        ...

    . Execute o projeto:

        . Perceba que a execução foi sincrona, que a mensagem "Aguardando..." só veio após a conclusão
            do método "GetAllCategory".

        . O resultado da saida foi:

            Entity Framework In Action

            19 - FICCAO - ficcao
            20 - ACAO - acao
            21 - COMEDIA - comedia
            22 - SUSPENSE - suspense
            23 - POLICIAL - policial
            24 - RELIGIOSO - religioso
            25 - FANTASIA - fantasia
            26 - FAROESTE - faroeste

            Aguardando...    

    . Transformando um método sincrono para assíncrono:

        . Acrescente ao método "GetAllCategory" a palavra "async", sempre que acrescentamos a palavra
            "async" na declaração do método somos obrigado colocar a palavra "await" em alguma chamada
            dentro do método como veremos no próximo ponto:

            ...
            private async static void GetAllCategory(){
                ...
            }        

        . Acrescente a chamada da lista de categoria a palavra "await" e altere o método
            ".ToList()" por ".ToListAsync()"

            ...
            var categories = await context
                                    .Categories
                                    .ToListAsync();

        . O método "GetAllCategory()" deverá ficar como abaixo:

            private async static void GetAllCategory()
            {
                using( var context = new BlogDataContext()){
                    var categories = await context
                                        .Categories
                                        .ToListAsync();


                    categories.ForEach( item => { 
                        System.Console.WriteLine($"{item.Id} - {item.Name} - {item.Slug}");
                    } );
                }
            }

        . Execute o projeto e verifique o resultado da saída:

            Entity Framework In Action
            Aguardando...
            19 - FICCAO - ficcao
            20 - ACAO - acao
            21 - COMEDIA - comedia
            22 - SUSPENSE - suspense
            23 - POLICIAL - policial
            24 - RELIGIOSO - religioso
            25 - FANTASIA - fantasia
            26 - FAROESTE - faroeste

        . Perceba que a mensagem "Aguardando..." agora veio antes da lista exibida de categorias. Isto 
            ocorreu porque assim que foi executado o método assincrono abaixo, o fluxo do programa
            retorno para o método chamador "Main", que exibiu a mensagem "Aguardando..." e ficou 
            aguardando algum pressionar de teclas. Assim que o método abaixo retornou o resultado
            o fluxo retornou a esse ponto e deu continuidade ao fluxo do programa deste ponto em diante.

            var categories = await context
                                .Categories
                                .ToListAsync();


Aula 41.  Eager Loading vs Lazy Loading
---------------------------------------

    . Retorne ao resumo da aula (Aula 20. Include) e faça uma recapitulação.

    . Lazy Loading      Carregamento é feito apenas no momento em que o método que disponibiliza o dado 
                        associativo é chamado

    . Eager Loading     Carregamento imediato quando o objeto principal é carregado

    . No exemplo da aula anterior se não fazermos nenhuma menção a lista de "Posts" o EF deixará a carga
        dos "Posts" como "LAZY":

        var categories = context
                            .Categories
                            .ToList();

        . O SQL derivado da linha de código acima será:

            SELECT [c].[Id], [c].[Name], [c].[Slug]
            FROM [Category] AS [c]        

    . Para que o "join" seja feito é necessário realizar o "Include" na chamada e o Loading se torna EAGER:

        var categories = context
                        .Categories
                        .Include( x => x.Posts )     // <-- Include
                        .ToList();

        . Desta forma o SQL fabricado será:

            SELECT [c].[Id], [c].[Name], [c].[Slug], [p].[Id], [p].[AuthorId], [p].[Body], 
                    [p].[CategoryId], [p].[CreateDate], [p].[LastUpdateDate], [p].[Slug], 
                    [p].[Summary], [p].[Title]
            FROM [Category] AS [c]
            LEFT JOIN [Post] AS [p] ON [c].[Id] = [p].[CategoryId]
            ORDER BY [c].[Id], [p].[Id]        

    . Ao invés de colocarmos a expressão "x => x.Posts" dentro do método "Include", podemos
        colocar a expressão/nome da propriedade da classe que representa o objeto externo:

        var categories = context
                        .Categories
                        .Include( "Posts" )     // <-- Include
                        .ToList();

    . Trabalhando com LAZY Loading:

        . Acesse a pasta raiz do projeto e instale a package/library abaixo:

            dotnet add package Microsoft.EntityFrameworkCore.Proxies -v 5.0.9        

        . Acesse a classe "BlogDataContext.cs" e insira a linha abaixo:

            ...
            namespace Blog.Data
            {
                public class BlogDataContext: DbContext
                {
                    ...
                    protected override void OnConfiguring( DbContextOptionsBuilder options ){
                        ...
                        options.UseLazyLoadingProxies();    // Linha inserida
                    }
                    ...
                }
            }

        . Acesse as classes "Investidor.cs" e "Aplicacao.cs" e inclua nas propriedades pertinentes ao
            relacionamento entre elas a identificação "virtual":

            ...
            namespace Blog.Models
            {
                public class Investidor
                {
                    ...
                    public virtual ICollection<Aplicacao> Aplicacoes { get; set; } // Linha alterada, foi inserido a instrução "virtual"
                }
            }

            ...
            namespace Blog.Models
            {
                public class Aplicacao
                {
                    ...
                    public virtual Investidor Investidor { get; set; }                  // Linha alterada, foi inserido a instrução "virtual"
                }
            }


            . Talvez seja necessário acrescentar "virtual" nas demais propriedades que faz
                referência a outras classes, não somente entre "Investidor" e "Aplicacao"

        . No método "Program.GetAllInvestidor" deixe-o como abaixo:

            private static void GetAllInvestidor()
            {
                using( var context = new BlogDataContext()){
                    var investidores = context.Investidores
                                                // .Include( x => x.Aplicacoes )
                                                // .Where( x => x.Nome.Contains("GUSTAVO") )
                                                .ToList();
                                                
                    investidores.ForEach( item => {
                        Console.WriteLine($"{item.Nome} ");
                        Console.WriteLine("---------------------");

                        foreach( var aplicacao in item.Aplicacoes){
                            Console.WriteLine($"{aplicacao.Titulo} {aplicacao.ValorAtualizado}");
                        }
                    });

                }
            }

        . No método "Main" da classe "Program" faça a chamada do método acima e execute o projeto.

        . Verifique que a chamada da coleção de "investidores" não carregou num primeiro momento a 
            coleção de "aplicacoes", somente na iteração da coleção "Aplicacoes", ficando "LAZY Loading".

    . Trabalhando com "LAZY Loading", colocando uma terceira classe relacionada:

        . Este exemplo trabalharemos com 3 classes nessa ordem: 

            . Instituicao ------+ 
                                |
                                | <-- Contêm
                                |
            . Aplicacao   <-----+
                  |
                  | Tem 
                  |
                  V
            . Investidor

        . Quando relacionamos as três classes acima, o máximo que podemos fazer EAGER Loading será entre as classes: 
            Instituicao e Aplicacao

        . Vamos acessar a classe "BlogDataContext.cs" para desabilitar o "Lazy loading". Comente a linha do comando
            "UseLazyLoadingProxies()".

            ...
            namespace Blog.Data
            {
                public class BlogDataContext: DbContext
                {
                    ...
                    protected override void OnConfiguring( DbContextOptionsBuilder options ){
                        ...
                        // options.UseLazyLoadingProxies();    // Linha comentada
                    }
                    ...
                }
            }

        . Insira o método abaixo na classe "Program":

            ...
            private static void GetAllInstituicao()
            {

                using( var context = new BlogDataContext()){
                    var instituicoes = context.Instituicoes
                                                .Include( x => x.Aplicacoes )   
                                                .ToList();

                    instituicoes.ForEach( item => {

                            System.Console.WriteLine($"{item.Nome} - {item.Rating}");

                            System.Console.WriteLine("-----------------------------");

                            item.Aplicacoes
                                .ToList()
                                .ForEach( aplicacao => {
                                                System.Console.WriteLine($"{aplicacao.Titulo} - {aplicacao.PercentualRemuneracao} - {aplicacao.InvestidorId} - {aplicacao.Investidor.Nome}");
                                        });

                            System.Console.WriteLine("-----------------------------");
                    });
                }
            }                                                                                                                                                                       ^
            ...                                                                                                                                                                     |
                                                                                                                                                                                    |
        . Execute o projeto. Ocorrerá um erro, pois as propriedades do método "instituicao.aplicacao.Investidor" não estará disponível ---------------------------------------------+

        . Não conseguiremos fazer o "loading" de primeira da classe "Investidor", para fazer isso com sucesso temos 3 opções:

            . ThenInclude

                . Insira o método "ThenInclude" como abaixo na carga do objeto "instituicoes":

                    ...
                    var instituicoes = context.Instituicoes
                                                .Include( x => x.Aplicacoes )   
                                                    .ThenInclude( inv => inv.Investidor)    // Linha inserida
                                                .ToList();
                    ...
                
                . Execute o projeto e verifique que agora foi sem erro. A linha que apresentava {aplicacao.Investidor.Nome} 
                    conseguiu executar sem erro.

            . Include

                . Insira o método "Include" como abaixo na carga do objeto "instituicoes" e apague o "ThenInclude"

                    ...
                    var instituicoes = context.Instituicoes
                                                .Include( x => x.Aplicacoes )   
                                                .Include( "Aplicacoes.Investidor")      // Linha inserida
                                                .ToList();
                    ...

                . Execute o projeto e verifique que também foi possivel executar o projeto sem erro

            .  Reference

                . Apague o ".Include( "Aplicacoes.Investidor")" do passo anterior

                    ...
                    var instituicoes = context.Instituicoes
                                                .Include( x => x.Aplicacoes )   
                                                .ToList();
                    ...

                . Na iteração da coleção "Aplicacoes" insira a linha "context.Entry( aplicacao )...."
                    como abaixo:

                        ...
                        item.Aplicacoes
                            .ToList()
                            .ForEach( aplicacao => {
                                            context.Entry( aplicacao ).Reference( x => x.Investidor ).Load();

                                            System.Console.WriteLine($"{aplicacao.Titulo} - {aplicacao.PercentualRemuneracao} - {aplicacao.InvestidorId} - {aplicacao.Investidor.Nome}");

                                    });
                        ...

                . Execute o projeto e verifique que também foi possivel executar o projeto sem erro

    . Trabalhando com LINQ para melhorar a performance:

        // Explicar o método 
        private static void GetAllInstituicao2()
        {
            using var context = new BlogDataContext();

            var consulta = from a in context.Instituicoes
                                   from c in a.Aplicacoes
                                   where a.Id == 1
                                   select new
                                   {
                                       a.Nome , a.Rating, c.Indice, c.Investidor
                                   };

                // var resultado = consulta.ToList(); 

                System.Console.WriteLine("");

                consulta.ToList().ForEach( item => {
                    System.Console.WriteLine($"{item.Nome} - {item.Rating} - {item.Indice} - {item.Investidor.Nome}");
                    System.Console.WriteLine("------------------");
                });

                System.Console.WriteLine("");

        }








// JOIN
https://www.tektutorialshub.com/entity-framework/join-query-entity-framework/

// TODO: DOcumenetar Lazy Loading com a marcação da propriedade como "virtual"
https://www.learnentityframeworkcore.com/lazy-loading


// TODO: Pegar o exemplo abaixo (One To Many) e fazer no projeto
https://www.learnentityframeworkcore.com/configuration/one-to-many-relationship-configuration


// TODO: Documentar os comando CLI do "dotnet ef ..."
https://www.entityframeworktutorial.net/efcore/cli-commands-for-ef-core-migration.aspx
https://www.entityframeworktutorial.net/efcore/entity-framework-core-migration.aspx