Fundamentos do Entity Framework - Balta
---------------------------------------

https://www.entityframeworktutorial.net/
https://entityframework.net/ef-code-first
https://www.tutorialspoint.com/entity_framework/index.htm


INTRODUÇÃO
----------


Aula 2. Ferramentas
-------------------

. Este curos é continuação do curso Fundamentos C#, OOP, SQL Server e Dapper.

. Utilizaremos:

    Umas das plataformas Windows. MAC, Ou Linux
    NET 5 ou superior
    Azure Data Studio
    SQL Server
    VS Code

. Instalação do Docker

	. Instalação

		. Instalação nas distribuições baseadas no Ubuntu:

			. A URL abaixo tem os passos atualizado para instalação do Docker:

				https://docs.docker.com/engine/install/ubuntu/

			. Instalação Atualizada

				sudo apt-get update
				sudo apt-get install \
					ca-certificates \
					curl \
					gnupg \
					lsb-release

				curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

				echo \
					"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
					$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

				sudo apt-get update
				sudo apt-get install docker-ce docker-ce-cli containerd.io
				sudo docker --version

				sudo groupadd docker
				sudo gpasswd -a <usuario> docker
				sudo chown "$USER":"$USER" /var/run/docker.sock -R
				sudo service docker restart

				docker --version

		. Instalação no Mint

			sudo apt-get update
			cd Downloads/
			sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common
			curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
			sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(. /etc/os-release; echo "$UBUNTU_CODENAME") stable"
			sudo apt-get update
			sudo apt-get -y install docker-ce docker-compose
			sudo usermod -aG docker $USER
			docker --version

            sudo groupadd docker
            sudo gpasswd -a <usuario> docker
            sudo chown "$USER":"$USER" /var/run/docker.sock -R
            sudo service docker restart

            docker --version

. Instalando o .NET Core SDK

    . Instalçao Atualizada:

        . URL com informações para realizar a instalação.

            https://docs.microsoft.com/pt-br/dotnet/core/install/linux-ubuntu

            . IMPORTANTE: Acesse a instalação da distribuição e versão especifica do linux que estamos utilizando para 
                            proceder os comandos adequadamente.

                            A instalação abaixo está para o Ubuntu 20.04

        # Comando para o Ubuntu 22.04 em diante
        # wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.0g-2ubuntu4_amd64.deb
        # sudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb

        # Instalação do SDK
        wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
        sudo dpkg -i packages-microsoft-prod.deb

        sudo dpkg --purge packages-microsoft-prod && sudo dpkg -i packages-microsoft-prod.deb
        sudo apt-get update

        sudo apt-get install -y gpg
        wget -O - https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor -o microsoft.asc.gpg
        sudo mv microsoft.asc.gpg /etc/apt/trusted.gpg.d/
        wget https://packages.microsoft.com/config/ubuntu/20.04/prod.list
        sudo mv prod.list /etc/apt/sources.list.d/microsoft-prod.list
        sudo chown root:root /etc/apt/trusted.gpg.d/microsoft.asc.gpg
        sudo chown root:root /etc/apt/sources.list.d/microsoft-prod.list

        # Comando para o Ubuntu 22.04 em diante
        # wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.0g-2ubuntu4_amd64.deb
        # sudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb

        sudo apt-get update; \
        sudo apt-get install -y apt-transport-https && \
        sudo apt-get update && \
        sudo apt-get install -y dotnet-sdk-5.0

        sudo apt-get install -y apt-transport-https && \
        sudo apt-get update && \
        sudo apt-get install -y aspnetcore-runtime-5.0

        sudo apt-get install -y dotnet-runtime-5.0


. Instalando o VS Code

    Instalação das extensões do VSCode

            C# 
            C# Extensions
            C# XML Documentation Comments
            vscode-icons (Opcional)
            Docker

        . Atalhos:

            Ctrl + K + D ou Shit + Alt + F:             Identa todo o seu código automaticamente;
            Ctrl + K + C:                               comenta um bloco de linhas;
            Ctrl + K + U:                               descomenta um bloco de linhas;
            Alt + Left Arrow:                           durante a programação, volta um método que você estava navegando;
            Alt + Right Arrow:                          durante a programação, avança um método que você estava navegando;
            Ctrl + .:                                   implementa o método/classe inexistente que você acabou de escrever;
            Ctrl + M + O:                               esconde todas as regions da classe atual;
            Ctrl + Shift + B:                           compila todos os projetos;
            F5:                                         manda depurar um projeto;
            Ctrl + F5:                                  manda executar um projeto;
            F10:                                        durante a depuração, avança uma linha;
            F11:                                        durante a depuração, avança uma linha entrando nos detalhes da mesma;


    Configurar Visual Studio Code para .NETCore

        . Acesse File / Preferences / Settings

        . Digite C#

        . Acesse "C# Configuration / CSharp Format Enabled" e habilite a configuração

        . Digite "Format on save" e habilite a configuração

        . Digite "Final" e habilite a configuração "Files: Insert final newline" e habilite a configuração


. Instalando o SQL Server

    https://docs.microsoft.com/pt-br/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash
    https://docs.microsoft.com/pt-br/sql/linux/sql-server-linux-setup-tools?view=sql-server-ver15#ubuntu


    docker container run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=<password>"    -p 1433:1433 --name sqlserver --hostname sqlserver    -d mcr.microsoft.com/mssql/server:2019-latest
    docker container ps -a
    docker container exec -t sqlserver cat /var/opt/mssql/log/errorlog | grep connection

    # Testar no linux, não funcionou no windows
    docker container exec -it sqlserver /opt/mssql-tools/bin/sqlcmd -S localhost -U SA  -P "$(read -sp "Enter current SA password: "; echo "${REPLY}")"  -Q "ALTER LOGIN SA WITH PASSWORD=\"$(read -sp "Enter new SA password: "; echo "${REPLY}")\""

    # Execute os comandos abaixo ao entrar no container
    #
    # hostname -I
    # ip a
    docker exec -it sqlserver "bash"

    curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
    curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list
    sudo apt-get update 
    sudo apt-get install mssql-tools unixodbc-dev
    sudo apt-get update 
    sudo apt-get install mssql-tools
    echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bash_profile
    echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bashrc
    source ~/.bashrc
    
    # Execute o comando abaixo e substitua o endereço IP do comando "sqlcmd" pelo adquirido no "hostname -I"
    #
    # hostname -I
    sqlcmd -S 192.168.0.82,1433 -U SA -P "<password>"


    # Execute os comandos abaixo dentro do sqlcmd
    EXEC sp_databases
    GO

    EXEC sp_helpdb    
    GO

    SELECT name FROM master..sysdatabases ORDER BY name
    GO

    EXEC sp_msForEachDB 'PRINT ''?'''
    GO

    EXIT

. Instalando Azure Data Studio

    . Para Linux siga os passos abaixo:

        Acessar o link abaixo para fazer o download do arquivo .deb:

            https://go.microsoft.com/fwlink/?linkid=2169956

        cd ~
        sudo dpkg -i ./Downloads/azuredatastudio-linux-<version string>.deb
        azuredatastudio

    . Para Windows acesse o link abaixo:

        https://docs.microsoft.com/pt-br/sql/azure-data-studio/download-azure-data-studio?view=sql-server-ver15    




https://entityframework.net/ef-code-first
https://www.entityframeworktutorial.net/code-first/simple-code-first-example.aspx
https://www.tutorialspoint.com/entity_framework/entity_framework_environment_setup.htm#



Aula 3. ORM
-----------

    . ORM - Object Relational Mapping

    . Responsável por fazer o de-para das tabelas para os objetos de classes.

    . Substitui o desenvolvimento de SQL pelo mapeamento das classes de forma que criem os objetos
        automaticamente.


Aula 4. Entity Framework
------------------------

    . O EF é um framework

    . É um conjunto de bibliotecas, muito mais poderoso, complexo e pesado do que o Dapper.

    . Permite trabalhar com CRUD, Migrações.


    .NET Core Command-Line Interface (CLI)    
    --------------------------------------

        . Digite no terminal "dotnet --info" para apresentar informações variadas da instação do dotnet

        . Digite no terminal "dotnet new" irá apresentar as várias possibilidades de criar diversos projetos, exemplo:

            dotnet new mvc

            dotnet run

            #Acesse o navegador e digite a URL: https://localhost:5001/ para ver o resultado do projeto criado.

        . Ctrl + C no terminal acaba com a execução do projeto:

        https://www.infoq.com/br/articles/netcore-cli/    

    . Instalar pacotes através do Nuget.org
    ---------------------------------------

        https://www.nuget.org/packages/Microsoft.EntityFrameworkCore/7.0.0-preview.4.22229.2#versions-body-tab

        . Ao ser compilada, uma biblioteca gera um arquivo DLL. Será esta DLL que os outros projetos irão utilizar. 
            O NuGet aproveita desta característica da plataforma para definir seus pacotes.

        . Na prática, um pacote NuGet é um arquivo compactado com a extensão .nupkg que contém um código compilado (DLL), 
            outros arquivos relacionados a este código (como imagens, etc.) e um arquivo de configuração que contém 
            informações sobre o pacote, como: número de versão, criador, etc.

        . Estes pacotes .nupkg podem ser publicados em repositórios públicos ou privados, onde os desenvolvedores podem 
            consumi-los, adicionando-os em seus projetos e utilizando no código as funcionalidades que fornecerem.

        . Em se tratando de projeto, como se fosse as dependências de bibliotecas.

        . Acesse o site nuget.org, digite "Microsoft Entity Framework Core" e faça a pesquisa.

        . Acesse o item Microsoft.EntityFrameworkCore.

        . Acesse uma das versões, atualmente 5.0.5.
        
        . Acesse a aba .NetCli.

        . Copie o comando sugerido por esse caminho:

            dotnet add package Microsoft.EntityFrameworkCore --version 5.0.5

        . Acesse o terminal, vá na pasta do projeto e execute o comando acima. Cuidado é necessário acessar a pasta do projeto
            e não da solução, exemplo: ~/workspace-two/CSharpBasico/helloWorld.


        . Após a execução, no terminal, execute um dos comandos abaixo:

            dotnet restore

            ou

            dotnet build

        . Acesse o Visual Studio Code "code ." para entrar no projeto e acesse o arquivo com extensão "*.csproj". Podemos verificar 
            que agora temos o pacote dentro da aplicação:

            <ItemGroup>
                <PackageReference Include="Microsoft.EntityFrameworkCore" Version="5.0.5" />
            </ItemGroup>

        . Retorne ao Home do site nuget.org e digite "Pomelo Entity Framework core" e acesse o link do MySQL.

        . Acesse a aba "PackageReference" e copie o comando sugerido:

        . Acesse novamente o arquivo com a extensão *.csproj e insira a dependência copiada dentro do nó "ItemGroup":

            <ItemGroup>
                <PackageReference Include="Microsoft.EntityFrameworkCore" Version="5.0.5" />
                <PackageReference Include="Pomelo.EntityFrameworkCore.MySql" Version="5.0.0-alpha.2" />    
            </ItemGroup>

        . Salve o conteúdo do arquivo, o VsCode irá pedir para dar o "Restore", confirme o restore.

        . Se quiser podemos dar o "dotnet restore", ou o "dotnet build", no terminal.

        . Caso haja a necessidade de retirar alguma dependência do nó "ItemGroup", acesse o terminal, e execute os comandos abaixo:

            dotnet clean
            dotnet restore

Aula 4. DataContext
-------------------

    . DB Context - Uma instância DbContext representa uma combinação da unidade de padrões de trabalho e de repositório, 
                    de modo que ele possa ser usado para consultar de um banco de dados e agrupar alterações que serão 
                    gravadas novamente no armazenamento como uma unidade. DbContext é conceitualmente semelhante a 
                    ObjectContext.

        . As classes de contexto derivam da "System.Data.e/ntity.DbContextDbContext".
        . Uma instância de uma classe de contexto representa a unidade de trabalho e segue o "pattern" "Repository".
        . Pode combinar várias transações numa simples transação.
        . Usada para consultar e salvar dados
        . Usada para configurar classes de domínio, mapeamento de relacionamento, cache, transação, etc.

        . Exemplo:

            using System.Data.Entity;

            public class SchoolContext : DbContext
            {
                public SchoolContext()
                {

                }
                // Entities        
                public DbSet<Student> Students { get; set; }
                public DbSet<StudentAddress> StudentAddresses { get; set; }
                public DbSet<Grade> Grades { get; set; }
            } 
    
    . DBSet - Um DbSet representa a coleção de todas as entidades no contexto ou que pode ser consultada a partir do 
                banco de dados, de um determinado tipo. Os objetos DbSet são criados a partir de um DbContext usando 
                o método DbContext.


Aula 5. Restaurando o banco
---------------------------

    . Levante o docker do SQL Server.

    . No Azure Data Studio, acesse o banco de dados do docker e execute o script abaixo:

        CREATE DATABASE [Blog]
        GO

        USE [Blog]
        GO

        -- DROP TABLE [User]
        -- DROP TABLE [Role]
        -- DROP TABLE [UserRole]
        -- DROP TABLE [Post]
        -- DROP TABLE [Category]
        -- DROP TABLE [Tag]
        -- DROP TABLE [PostTag]

        CREATE TABLE [User] (
            [Id] INT NOT NULL IDENTITY(1, 1),
            [Name] NVARCHAR(80) NOT NULL,
            [Email] VARCHAR(200) NOT NULL,
            [PasswordHash] VARCHAR(255) NOT NULL,
            [Bio] TEXT NOT NULL,
            [Image] VARCHAR(2000) NOT NULL,
            [Slug] VARCHAR(80) NOT NULL,

            CONSTRAINT [PK_User] PRIMARY KEY([Id]),
            CONSTRAINT [UQ_User_Email] UNIQUE([Email]),
            CONSTRAINT [UQ_User_Slug] UNIQUE([Slug])
        )
        CREATE NONCLUSTERED INDEX [IX_User_Email] ON [User]([Email])
        CREATE NONCLUSTERED INDEX [IX_User_Slug] ON [User]([Slug])

        CREATE TABLE [Role] (
            [Id] INT NOT NULL IDENTITY(1, 1),
            [Name] VARCHAR(80) NOT NULL,
            [Slug] VARCHAR(80) NOT NULL,

            CONSTRAINT [PK_Role] PRIMARY KEY([Id]),
            CONSTRAINT [UQ_Role_Slug] UNIQUE([Slug])
        )
        CREATE NONCLUSTERED INDEX [IX_Role_Slug] ON [Role]([Slug])

        CREATE TABLE [UserRole] (
            [UserId] INT NOT NULL,
            [RoleId] INT NOT NULL,

            CONSTRAINT [PK_UserRole] PRIMARY KEY([UserId], [RoleId])
        )

        CREATE TABLE [Category] (
            [Id] INT NOT NULL IDENTITY(1, 1),
            [Name] VARCHAR(80) NOT NULL,
            [Slug] VARCHAR(80) NOT NULL,

            CONSTRAINT [PK_Category] PRIMARY KEY([Id]),
            CONSTRAINT [UQ_Category_Slug] UNIQUE([Slug])
        )
        CREATE NONCLUSTERED INDEX [IX_Category_Slug] ON [Category]([Slug])

        CREATE TABLE [Post] (
            [Id] INT NOT NULL IDENTITY(1, 1),
            [CategoryId] INT NOT NULL,
            [AuthorId] INT NOT NULL,
            [Title] VARCHAR(160) NOT NULL,
            [Summary] VARCHAR(255) NOT NULL,
            [Body] TEXT NOT NULL,
            [Slug] VARCHAR(80) NOT NULL,
            [CreateDate] DATETIME NOT NULL DEFAULT(GETDATE()),
            [LastUpdateDate] DATETIME NOT NULL DEFAULT(GETDATE()),

            CONSTRAINT [PK_Post] PRIMARY KEY([Id]),
            CONSTRAINT [FK_Post_Category] FOREIGN KEY([CategoryId]) REFERENCES [Category]([Id]),
            CONSTRAINT [FK_Post_Author] FOREIGN KEY([AuthorId]) REFERENCES [User]([Id]),
            CONSTRAINT [UQ_Post_Slug] UNIQUE([Slug])
        )
        CREATE NONCLUSTERED INDEX [IX_Post_Slug] ON [Post]([Slug])

        CREATE TABLE [Tag] (
            [Id] INT NOT NULL IDENTITY(1, 1),
            [Name] VARCHAR(80) NOT NULL,
            [Slug] VARCHAR(80) NOT NULL,

            CONSTRAINT [PK_Tag] PRIMARY KEY([Id]),
            CONSTRAINT [UQ_Tag_Slug] UNIQUE([Slug])
        )
        CREATE NONCLUSTERED INDEX [IX_Tag_Slug] ON [Tag]([Slug])

        CREATE TABLE [PostTag] (
            [PostId] INT NOT NULL,
            [TagId] INT NOT NULL,

            CONSTRAINT PK_PostTag PRIMARY KEY([PostId], [TagId])
        )


Aula 6 e 7. Criando os modelo - Parte 1 e 2
-------------------------------------------

    . Acesse a pasta local de projetos e execute o comando:

        dotnet new console -o Blog -n blog -f net5.0

    . Abra o VsCode e abra a pasta do projeto criado anteriormente.

    . Crie uma pasta no projeto com o nome "Models"

    . Crie a classe "User" dentro da pasta "Models" conforme o código abaixo:

        namespace Blog.Models
        {
            public class User
            {
                public int Id { get; set; }
                public string Name { get; set; }
                public string Email { get; set; }
                public string PasswordHash { get; set; }
                public string Image { get; set; }
                public string Slug { get; set; }
                public string Bio { get; set; }
            }
        }

    . Crie a classe "Role" dentro da pasta "Models" conforme o código abaixo:

        namespace Blog.Models
        {
            public class Role
            {
                public int Id { get; set; }
                public string Name { get; set; }
                public string Slug { get; set; }
            }
        }

    . Crie a classe "UserRole" dentro da pasta "Models" conforme o código abaixo:

        namespace Blog.Models
        {
            public class UserRole
            {
                public int UserId { get; set; }
                public int RoleId { get; set; }
            }
        }

    . Crie a classe "Category" dentro da pasta "Models" conforme o código abaixo:

        namespace Blog.Models
        {
            public class Category
            {
                public int Id { get; set; }
                public string Name { get; set; }
                public string Slug { get; set; }
            }
        }

    . Crie a classe "Tag" dentro da pasta "Models" conforme o código abaixo:

        using System.ComponentModel.DataAnnotations;
        using System.ComponentModel.DataAnnotations.Schema;

        namespace Blog.Models
        {
            public class Tag
            {
                public int Id { get; set; }
                public string Name { get; set; }
                public string Slug { get; set; }
            }
        }

    . Crie a classe "Post" dentro da pasta "Models" conforme o código abaixo:

        using System;

        namespace Blog.Models
        {
            public class Post
            {
                public int Id { get; set; }
                public int CategoryId { get; set; }
                public int AuthorId { get; set; }
                public string Title { get; set; }
                public string Summary { get; set; }
                public string Body { get; set; }
                public string Slug { get; set; }
                public DateTime CreateDate { get; set; }
                public DateTime LastUpdateDate { get; set; }
            }
        }

    . Crie a classe "PostTag" dentro da pasta "Models" conforme o código abaixo:

        namespace Blog.Models
        {
            public class PostTag
            {
                public int PostId { get; set; }
                public int TagId { get; set; }
            }
        }

Aula 8 - DbSet
--------------

    . Acesse a pasta raiz do projeto e execute os comandos abaixo:

        dotnet add package Microsoft.EntityFrameworkCore --version 5.0.9        
        
        dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 5.0.9

    . Crie a pasta "Data" dentro do projeto e crie a classe "BlogDataContext.cs" com o código abaixo:

        using Blog.Models;
        using Microsoft.EntityFrameworkCore;

        namespace Blog.Data
        {
            public class BlogDataContext : DbContext
            {

                // Devido a problema de chaves, as linhas comentadas referem-se a classes onde a chave primária são chaves composta
                // Mais a frente iremos configurar esses tipos de classes

                public DbSet<Category> Categories { get; set; }
                public DbSet<Post> Posts { get; set; }
                // public DbSet<PostTag> PostTags { get; set; }
                public DbSet<Role> Roles { get; set; }
                public DbSet<Tag> Tags { get; set; }
                public DbSet<User> Users { get; set; }
                // public DbSet<UserRole> UserRoles { get; set; }

                protected override void OnConfiguring(DbContextOptionsBuilder options)
                    => options.UseSqlServer("Server=localhost,1433;Database=Blog;User ID=sa;Password=<password>");
            }
        }

    . A partir deste momento se formos na classe "Program.cs", criarmos a classe de "context", já estará
        visivel os "DbContext":

        . Insira as linhas abaixo na classe "Program.cs":

            ...
            class Program
            {
                static void Main( string[] args)
                {
                    ...

                    var ctx = new BlogDataContext();

                    ctx.Categories();   // Já está visivel
                }
            }

        . O código acima é somente como exemplo, porque precisa de algumas configurações no "model"

Aula 9 - Configurando o DAtaContext
-----------------------------------

    . O método "OnConfiguring" é o local onde faremos a conexão com o banco de dados.

    . Altere o código do método "Main" da classe "Program.cs":

        ...
        static void Main( string[] args ){
            using( var context = new BlogDataContext() ){

            }
        }
        ...


Aula 10. Create
---------------

    . Acesse a classe "Tag.cs" e inclua as linhas abaixo:

        ...
        using System.ComponentModel.DataAnnotations;            // Linha inserida
        using System.ComponentModel.DataAnnotations.Schema;     // Linha inserida
        namespace Blog.Models
        {
            [Table("Tag")]                                      // Linha inserida
            public class Tag
            {
                [Key]                                           // Linha inserida
                public int Id { get; set; }

                ...
            }
        }

    . Altere o código do método "Main" da classe "Program.cs":

        ...
        static void Main( string[] args ){
            using( var context = new BlogDataContext() ){

                var tag = new Tag { Name = "ASP.NET", Slug = "aspnet" };    // Linha inserida

                context.Tags.Add( tag );                                    // Linha inserida

            }
        }
        ...

    . Execute o projeto e verifique no banco se a linha acima foi criada com sucesso na tabela "tag"

        . IMPORTANTE: Ela não foi criada, porque o "context" é um banco em memória, para efetivar a inserção
                        no banco é necessário usar o comando "context.SaveChanges()"

    . Insira a linha abaixo no método "Main" da classe "Program.cs":


        ...
        static void Main( string[] args ){
            using( var context = new BlogDataContext() ){

                var tag = new Tag { Name = "ASP.NET", Slug = "aspnet" };    

                context.Tags.Add( tag );                                    

                context.SaveChanges();              // Linha inserida

            }
        }
        ...

    . Execute o projeto e verifique no banco se a linha acima foi criada com sucesso na tabela "tag"


Aula 11. Update
---------------

    . Altere o método "Main" como abaixo:

        ...
        static void Main( string[] args ){
            using( var context = new BlogDataContext() ){

                // var tag = new Tag { Name = "ASP.NET", Slug = "aspnet" };    

                // context.Tags.Add( tag );                                    

                // context.SaveChanges();              

                var tag = context.Tags.FirstOrDefault( x => x.Id == 2 );    // Linha inserida

                tag.Name = ".NET";                                      // Linha inserida

                tag.Slug = "dotnet";                                    // Linha inserida

                context.Update( tag );                                  // Linha inserida
                context.SaveChanges();              // Linha inserida
            }
        }
        ...

    . Execute o projeto e verifique no banco se a linha acima foi criada com sucesso na tabela "tag"

    . Quando fazemos a localização de uma ocorrência "context.Tags.FirstOrDefault" o EF traz diversas 
        informações do banco conhecida como METADADOS (Última atualização, data da criação, versão atual e a
        que está no banco ). Dessa forma que o EF consegue comparar as informações são alteradas dos DBSet.
        Por isso precisamos trazer as informações do banco para que o EF possa realizar essas comparações.

Aula 12. Delete
---------------

    . Altere o método "Main" como abaixo:

        ...
        static void Main( string[] args ){
            using( var context = new BlogDataContext() ){

                // var tag = new Tag { Name = "ASP.NET", Slug = "aspnet" };    

                // context.Tags.Add( tag );                                    

                // context.SaveChanges();              

                var tag = context.Tags.FirstOrDefault( x => x == 2 )    

                // tag.Name = ".NET";                                      

                // tag.Slug = "dotnet";                              

                // context.Update( tag )      

                context.Remove( tag );              // Linha inserida
                context.SaveChanges();              
            }
        }
        ...

    . Execute o projeto e verifique no banco se a linha acima foi criada com sucesso na tabela "tag"


Aula 13. ToList
---------------


    . Altere o método "Main" como abaixo:

        . Apague as linhas no interior do método "Main" e substitua pela abaixo:

            ...
            static void Main( string[] args ){
                using( var context = new BlogDataContext() ){

                    var tag1 = new Tag { Name = "ASP.NET", Slug = "aspnet" };    

                    context.Tags.Add( tag1 );                                    

                    var tag2 = new Tag { Name = ".NET", Slug = "aspnet" };    

                    context.Tags.Add( tag2 );                                    

                    context.SaveChanges();              
                }
            }
            ...

        . Execute o projeto.

        . Altere o método "Main" novamente.

            using System.Linq;
            ...
            static void Main( string[] args ){
                using( var context = new BlogDataContext() ){

                    // var tag1 = new Tag { Name = "ASP.NET", Slug = "aspnet" };    

                    // context.Tags.Add( tag1 );                                    

                    // var tag2 = new Tag { Name = ".NET", Slug = "aspnet" };    

                    // context.Tags.Add( tag2 );                                    

                    // context.SaveChanges();              

                    // Execute o select internamente
                    var tags = context.Tags.ToList();

                    foreach( var tag in tags ){
                        System.Console.Write($"{tag.Name}");
                    }
                }
            }
            ...

        . Execute o projeto.

    . Algumas formas de executar o ToList()

        var tags = context
                    .Tags
                    .ToList()
                    .Where( x => x.Name.Contains(".NET"));  // Neste caso o filtro será aplicado em memória
                                                            // acarretando em lentidão

        var tags = context
                    .Tags
                    .Where( x => x.Name.Contains(".NET"))  // Neste caso o filtro será aplicado no banco no SQL
                    .ToList();

        . IMPORTANTE: A segunda forma é a mais rápida, dê preferência sempre colocar o "Where(...)" antes do "ToList()".

        var tags = context
                    .Tags
                    .FromSqlRaw($"Select Id, Name, Slug from Tag Where Slug = '{description}'")
                    .ToList();



Aula 14. AsNoTracking
---------------------

    var tags = context
                .Tags
                .AsNoTracking()
                .ToList();

    . O "AsNoTracking" não traz as informações do METADADO. Deixando mais rápido as consultas ao usar "ToList".

    . IMPORTANTE: Quando utilizar ".Update()" ".Remove()" não use "AsNoTracking", porque para essas operações
                    precisam saber detalhes de chaves, alterações, etc. para efetivar a alteração
                    no banco.

    . É necessário fazer o import abaixo:

        using Microsoft.EntityFrameworkCore;                



Aula 15. First, Single
----------------------

    . Diferença entre "FirstOrDefault", "First", "Single"

        . FirtsOrDefault        - Se tiver mais de um registro no banco o EF trará somente a primeira ocorrência
        . First                 - Se tiver mais de um registro no banco o EF dará erro
        . Single                - Idem, dará erro



OPERAÇÕES BÁSICAS
-----------------

Aula 16. DataAnnotations
------------------------

    . Tipos:

        . Fluent Mapping

            . Mapeamento fluente
            . Feito em uma classe externa
            . Não "polui" a classe principal
            . Não cria dependências na classe/projeto principal

        . Data Annotations

            . Feitos diretamente nas classes
            . Mais simples e diretos
            . Depende do System.ComponentModel.DataAnnotations
                . Alguns dependem do Microsof.EntityFrameworkCore 


    System.ComponentModel.DataAnnotations Attributes
    ------------------------------------------------

    Attribute	        Description
    ---------           -----------

    Key	                Can be applied to a property to specify a key property in an entity and make the 
                        corresponding column a PrimaryKey column in the database.

        using System.ComponentModel.DataAnnotations;

        public class Student
        {
            [Key]
            public int StudentKey { get; set; }
            public string StudentName { get; set; }
        }

    Timestamp	        Can be applied to a property to specify the data type of a corresponding column 
                        in the database as rowversion.

        EF 6 and EF Core both include the Timestamp data annotation attribute. It can only be applied once 
        in an entity class to a byte array type property. It creates a column with timestamp data type in 
        the SQL Server database. Entity Framework API automatically uses this Timestamp column in 
        concurrency check on the UPDATE statement in the database.

            using System.ComponentModel.DataAnnotations;

                public class Student
                {
                    public int StudentId { get; set; }
                    public string StudentName { get; set; }
                        
                    [Timestamp]
                    public byte[] RowVersion { get; set; }
                }

    ConcurrencyCheck	Can be applied to a property to specify that the corresponding column should be 
                        included in the optimistic concurrency check.

        The ConcurrencyCheck attribute can be applied to one or more properties in an entity class in EF 6 
        and EF Core. When applied to a property, the corresponding column in the database table will be 
        used in the optimistic concurrency check using the where clause.

            using System.ComponentModel.DataAnnotations;

            public class Student
            {
                public int StudentId { get; set; }
                
                [ConcurrencyCheck]
                public string StudentName { get; set; }
            }

        In the above example, the ConcurrencyCheck attribute is applied to the StudentName property of the 
        Student entity class. So, EF will include the StudentName column in the UPDATE statement to check 
        for optimistic concurrency. Consider the following example.

            using(var context = new SchoolContext()) 
            {
                var std = new Student()
                {
                    StudentName = "Bill"
                };

                context.Students.Add(std);
                context.SaveChanges();

                std.StudentName = "Steve";
                context.SaveChanges();
            }

        The above example will execute the following UPDATE statement on SaveChanges(), where it includes 
        StudentName in the where clause.

            exec sp_executesql N'UPDATE [dbo].[Students]
            SET [StudentName] = @0
            WHERE (([StudentId] = @1) AND ([StudentName] = @2))
            ',N'@0 nvarchar(max) ,@1 int,@2 nvarchar(max) ',@0=N'Steve',@1=1,@2=N'Bill'
            go            

    Required	        Can be applied to a property to specify that the corresponding column is a 
                        NotNull column in the database.

        The Required attribute can be applied to one or more properties in an entity class. EF will 
        create a NOT NULL column in a database table for a property on which the Required attribute is 
        applied.

            using System.ComponentModel.DataAnnotations;
                
            public class Student
            {
                public int StudentID { get; set; }
                [Required]
                public string StudentName { get; set; }
            }


    MinLength	        Can be applied to a property to specify the minimum string length allowed in 
                        the corresponding column in the database.

        The MinLength attributes allow you to specify additional property validations. It is applied to a 
        property to specify a minimum number of characters or bytes for the column that the property should map to.

        The following example specifies that the Title column in the Books table must have a minimum length of 5 characters.

            public class Book
            {
                public int BookId { get; set; }
                [MinLength(5)]
                public string Title { get; set; }
            }

    MaxLength	        Can be applied to a property to specify the maximum string length allowed in 
                        the corresponding column in the database.

        The MaxLength attribute specifies the maximum length of data value allowed for a property which in 
        turn sets the size of a corresponding column in the database. It can be applied to the string or 
        byte[] properties of an entity.

            using System.ComponentModel.DataAnnotations;
                
            public class Student
            {
                public int StudentID { get; set; }
                [MaxLength(50)]
                public string StudentName { get; set; }
                    
            }

    StringLength	    Can be applied to a property to specify the maximum string length allowed in the 
                        corresponding column in the database.

        The StringLength attribute can be applied to the string properties of an entity class. It specifies 
        the maximum characters allowed for a string property which in turn sets the size of a corresponding 
        column (nvarchar in SQL Server) in the database.

        using System.ComponentModel.DataAnnotations;

        public class Student
        {
            public int StudentID { get; set; }
            [StringLength(50)]
            public string StudentName { get; set; }
        }




    System.ComponentModel.DataAnnotations.Schema Attributes
    -------------------------------------------------------

    Attribute	        Description
    ---------           -----------

    Table	            Can be applied to an entity class to configure the corresponding table name and 
                        schema in the database.

        Table Attribute: [Table(string name, Properties:[Schema = string])

        name: Name of the Db table.
        Schema: Name of the Db Schema in which a specified table should be created. (Optional)
        using System.ComponentModel.DataAnnotations.Schema;

        [Table("StudentMaster")]
        public class Student
        {
            public int StudentID { get; set; }
            public string StudentName { get; set; }
        }

    Column	            Can be applied to a property to configure the corresponding column name, order 
                        and data type in the database.

        [Column (string name, Properties:[Order = int],[TypeName = string])

        name: Name of a column in a db table.
        Order: Order of a column, starting with zero index. (Optional)
        TypeName: Data type of a column. (Optional)
        The following example changes the name of a column.

        using System.ComponentModel.DataAnnotations.Schema;

        public class Student
        {
            public int StudentID { get; set; }
            
            [Column("Name")]
            public string StudentName { get; set; }
            public DateTime? DateOfBirth { get; set; }
            public byte[] Photo { get; set; }
            public decimal Height { get; set; }
            public float Weight { get; set; }
        }

    Index	            Can be applied to a property to configure that the corresponding column should 
                        have an Index in the database. (EF 6.1 onwards only)

        Entity Framework 6 provides the [Index] attribute to create an index on a particular column in the database, 
        as shown below:

            class Student
            {
                public int Student_ID { get; set; }
                public string StudentName { get; set; }
                    
                [Index]
                public int RegistrationNumber { get; set; }
            }

        By default, the index name will be IX_{property name}. However, you can change the index name.

        You can also make it a clustered index by specifying IsClustered = true or create a unique index by 
        specifying IsUnique=true.

            [Index( "INDEX_REGNUM", IsClustered=true, IsUnique=true )]
            public int RegistrationNumber { get; set; }


    NotMapped	        Can be applied to a property or entity class which should be excluded from the 
                        model and should not generate a corresponding column or table in the database.

        NotMapped Attribute: [NotMapped()]

        using System.ComponentModel.DataAnnotations.Schema;

        public class Student
        {
            public int StudentId { get; set; }
            public string StudentName { get; set; }
                
            [NotMapped]
            public int Age { get; set; }
        }


    InverseProperty	    Can be applied to a property to specify the inverse of a navigation property that 
                        represents the other end of the same relationship.

        https://www.entityframeworktutorial.net/code-first/inverseproperty-dataannotations-attribute-in-code-first.aspx

    ComplexType	        Marks the class as complex type in EF 6. EF Core 2.0 does not support this attribute.

https://www.entityframeworktutorial.net/code-first/table-dataannotations-attribute-in-code-first.aspx



# Só pra não esquecer
https://www.nuget.org/packages/dotnet-ef/#versions-body-tab
dotnet tool install --global dotnet-ef --version 5.0.17

dotnet add package Microsoft.EntityFrameworkCore.Design --version 5.0.17


Aula 17. Table, Key e Identity
------------------------------

    https://www.learnentityframeworkcore.com/configuration/data-annotation-attributes/databasegenerated-attribute
    https://www.entityframeworktutorial.net/code-first/databasegenerated-dataannotations-attribute.aspx    

    DatabaseGenerated	Can be applied to a property to configure how the underlying database should 
                        generate the value for the corresponding column e.g. identity, computed or none.

        a. Computed

            [DatabaseGenerated(DatabaseGeneratedOption.Computed)]


            The Computed option specifies that the property's value will be generated by the database when
            the value is first saved, and subsequently regenerated every time the value is updated. The 
            practical effect of this is that Entity Framework will not include the property in INSERT or UPDATE 
            statements, but will obtain the computed value from the database on retrieval.

            Entity Framework Core will not implement a value generation strategy. Database providers differ 
            in the way that values are automatically generated. Some will generate values for selected data 
            types such as Identity, rowversion, GUID. Others may require manual configuration such as setting 
            default values or triggers, or configuring the column as Computed.

        b. Identity
            
            [DataBaseGenerated(DatabaseGeneratedOption.Identity)]

            The Identity option specifies that the value will only be generated by the database when a value 
            is first added to the database. Thereafter, the property will not be included in UPDATE statements 
            by Entity Framework.

            Again, Entity Framework Core will not implement a value generation strategy. Database providers 
            differ in the way that values are automatically generated. Some will generate values for selected 
            data types such as Identity, rowversion, GUID.

            In the following example, the annotation is used to configure the Created property in the Contact 
            entity. Since the property is required, Entity Framework will configure a default value of 
            DateTime.MinValue. You can override this by setting a default value in the entity's constructor or 
            by initializing an auto-implemented property (as illustrated here):

                public class Contact
                {
                    public int Id { get; set; }
                    public string FullName { get; set; }
                    public string Email { get; set; } 
                    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
                    public DateTime Created { get; set; } = DateTime.UtcNow;
                }

        c. None

            [DatabaseGenerated(DatabaseGeneratedOption.None)

            DatabaseGeneratedOption.None option specifies that the value of a property will not be generated by 
            the underlying database. This will be useful to override the default convention for the id properties.

            For example, if you want to provide your own values to id properties instead of database generated 
            values, use the None option, as shown below.

                public class Course
                {
                    [DatabaseGenerated(DatabaseGeneratedOption.None)]
                    public int CourseId { get; set; }
                    public string CourseName { get; set; }
                }

            In the above example, EF will create the CourseId column in the database and will not mark it as an 
            IDENTITY column. So, each time you will have to provide the value of the CourseId property before 
            calling the SaveChanges() method.

                using (var context = new SchoolContext())
                {
                    // you must provide the unique CourseId value
                    var maths = new Course(){ CourseId=1,  CourseName="Maths"};
                    context.Courses.Add(maths);

                    // you must provide the unique CourseId value
                    var eng = new Course(){ CourseId=2,  CourseName="English"};
                    context.Courses.Add(eng);

                    // the following will throw an exception as CourseId has duplicate value
                    //var sci = new Course(){ CourseId=2,  CourseName="sci"};

                    context.SaveChanges();
                }

            Note: EF will throw an exception if you do not provide unique values each time because CourseId is a 
                  primary key property.


    . Acesse a classe "Category.cs" e faça as alterações abaixo:

        using System.ComponentModel.DataAnnotations;            // Linha inserida
        using System.ComponentModel.DataAnnotations.Schema;     // Linha inserida

        namespace Blog.Models
        {
            [Table("Category")]                                 // Linha inserida
            public class Category
            {
                [Key]                                           // Linha inserida
                [DatabaseGenerated(DatabaseGeneratedOption.Identity)]   // Linha inserida
                public int Id { get; set; }
                public string Name { get; set; }
                public string Slug { get; set; }
            }
        }


Aula 18. Required, MaxLength e Column
-------------------------------------

    . Acesse a classe "Category.cs" e faça as alterações abaixo:

        ...
        namespace Blog.Models
        {
            [Table("Category")]                                 
            public class Category
            {
                [Key]                                           
                [DatabaseGenerated(DatabaseGeneratedOption.Identity)]   
                public int Id { get; set; }

                [Required]                              // Linha inserida
                [MinLength(3)]                          // Linha inserida
                [MaxLength(80)]                         // Linha inserida
                [Column( "Name", TypeName= "NVARCHAR")] // Linha inserida
                public string Name { get; set; }

                [Required]                              // Linha inserida
                [MinLength(3)]                          // Linha inserida
                [MaxLength(80)]                         // Linha inserida
                [Column( "Slug", TypeName= "VARCHAR")] // Linha inserida
                public string Slug { get; set; }
            }
        }


Aula 19. Navigation Properties
------------------------------

    ForeignKey	        Can be applied to a property to mark it as a foreign key property.

        The [ForeignKey(name)] attribute can be applied in three ways:

        a. [ForeignKey] on the foreign key property in the dependent entity

            The [ForeignKey] on the foreign key property in the dependent entity and the related navigation property 
            name can be specified as a parameter as shown below.

                using System.ComponentModel.DataAnnotations.Schema;

                public class Student
                {
                    public int StudentID { get; set; }
                    public string StudentName { get; set; }
                        
                    [ForeignKey("Standard")]
                    public int StandardRefId { get; set; }
                    public Standard Standard { get; set; }
                }

                public class Standard
                {
                    public int StandardId { get; set; }
                    public string StandardName { get; set; }
                    
                    public ICollection<Student> Students { get; set; }
                }

            In the above example, the [ForeignKey] attribute is applied on the StandardRefId and specified in the name of 
            the navigation property Standard. This will create the foreign key column named StandardRefId in the Students 
            table, preventing the generation of a StandardId column in the database.

        b. [ForeignKey] on the navigation property in the dependent entity

            The [ForeignKey] attribute can be applied to the navigation property and the related foreign key 
            property name can be specified as shown below.

                using System.ComponentModel.DataAnnotations.Schema;

                public class Student
                {
                    public int StudentID { get; set; }
                    public string StudentName { get; set; }
                        
                    public int StandardRefId { get; set; }
                    
                    [ForeignKey("StandardRefId")]
                    public Standard Standard { get; set; }
                }

                public class Standard
                {
                    public int StandardId { get; set; }
                    public string StandardName { get; set; }
                    
                    public ICollection<Student> Students { get; set; }
                }

            In the above example, the [ForeignKey] attribute is applied on the Standard navigation property and the name 
            of the foreign key property StandardRefId is specified. This will create the foreign key column named 
            StandardRefId in the Students table, preventing the generation of a StandardId column in the database.

        c. [ForeignKey] on the navigation property in the principal entity

            The [ForeignKey] attribute can be applied to the navigation property in the principal entity and the related 
            foreign key property name can be specified in the dependent entity, as shown below.

            using System.ComponentModel.DataAnnotations.Schema;

            public class Student
            {
                public int StudentID { get; set; }
                public string StudentName { get; set; }
                    
                public int StandardRefId { get; set; }
                public Standard Standard { get; set; }
            }

            public class Standard
            {
                public int StandardId { get; set; }
                public string StandardName { get; set; }
                
                [ForeignKey("StandardRefId")]
                public ICollection<Student> Students { get; set; }
            }

            In the above example, the [ForeignKey] attribute is applied on the Students navigation property in the principal 
            entity Standard. This will create a foreign key column StandardRefId in the Students table in the database.

        . O Entity Framework utiliza a nomenclatura do parâmetro fornecido para descobrir a classe e o campo para encontrar a 
            referẽncia, por exemplo:

                                 +--> Nome da propriedade
                                 |
                                 --
            [ForeignKey("CategoryId")]
                         --------  
                            |
                            +-> Nome da classe

    . Acesse as demais classes do projeto e implemente as "Annotation" conforme acima.

        . Acesse a classse User.cs e insira as linhas abaixo:

            using System.ComponentModel.DataAnnotations;            // Linha inserida
            using System.ComponentModel.DataAnnotations.Schema;     // Linha inserida

            namespace Blog.Models
            {
                [Table("User")]             // Linha inserida
                public class User
                {
                    [Key]                   // Linha inserida
                    [DatabaseGenerated( DatabaseGeneratedOption.Identity)]  // Linha inserida
                    public int Id { get; set; }

                    [Required]                              // Linha inserida
                    [MinLength(3)]                          // Linha inserida
                    [MaxLength(80)]                         // Linha inserida
                    [Column( "Name", TypeName= "VARCHAR")] // Linha inserida
                    public string Name { get; set; }

                    public string Email { get; set; }
                    public string PasswordHash { get; set; }
                    public string Image { get; set; }
                    public string Slug { get; set; }
                    public string Bio { get; set; }
                }
            }

        . Acesse a classse Post.cs e insira as linhas abaixo:

            using System.ComponentModel.DataAnnotations;            // Linha inserida
            using System.ComponentModel.DataAnnotations.Schema;     // Linha inserida

            namespace Blog.Models
            {
                [Table("Post")]                 // Linha inserida
                public class Post
                {
                    [Key]                       // Linha inserida
                    [DatabaseGenerated( DatabaseGeneratedOption.Identity)]      // Linha inserida
                    public int Id { get; set; }


                    [ForeignKey("CategoryId")]            // Linha inserida
                    public int CategoryId { get; set; }

                    public Category Category{ get; set; }     // Linha inserida

                    [ForeignKey("AuthorId")]                  // Linha inserida
                    public int AuthorId { get; set; }

                    public User Author { get; set; }          // Linha inserida

                    public string Title { get; set; }
                    public string Summary { get; set; }
                    public string Body { get; set; }
                    public string Slug { get; set; }
                    public DateTime CreateDate { get; set; }
                    public DateTime LastUpdateDate { get; set; }
                }
            }
        
        . Se quiser podemos anotar a "ForeignKey" diretamente nas propriedades que representa as classes, 
            informando o nome do campo chave para fazer o relacionamento:

            ...
            public int CategoryId { get; set; }

            [ForeignKey("CategoryId")]
            public Category Category {get; set;}

            public int AuthorId { get; set; }

            [ForeignKey("AuthorId")]
            public User Author {get; set;}
            ...

        . Nesse caso podemos comentar as propriedades "CategoryId" e "AuthorId", porém as DMLs fabricadas
            terão "LEFT JOIN" e não "INNER JOIN" nos critérios de relacionamento:

            ...
            // public int CategoryId { get; set; }

            [ForeignKey("CategoryId")]
            public Category Category {get; set;}

            // public int AuthorId { get; set; }

            [ForeignKey("AuthorId")]
            public User Author {get; set;}
            ...

    . Insira o método abaixo na classe "Program.cs":

        ...
        private static void InsertPost(){

            using var context = new BlogDataContext();

            var user = new User
            {
                Name = "André Baltieri",
                Slug = "andrebaltieri",
                Email = "andre@balta.io",
                Bio = "9x Microsoft MVP",
                Image = "https://balta.io",
                PasswordHash = "123098457"
            };
            
            var category = new Category {Name = "Backend", Slug = "backend"};
            
            var post = new Post
            {
                Author = user,
                Category = category,
                Body = "<p>Hello world</p>",
                Slug = "comecando-com-ef-core",
                Summary = "Neste artigo vamos aprender EF core",
                Title = "Começando com EF Core",
                CreateDate = DateTime.Now,
                LastUpdateDate = DateTime.Now,
            };
            
            context.Posts.Add(post); // Não adicionei autor nem categoria
            context.SaveChanges();            
        }
        ...

    . Insira a linha abaixo no método "Main" da classe "Program.cs", execute e veja o resultado

        ...
        class Program
        {
            static void Main(string[] args)
            {
                ...
                InsertPost();
                ...
            }
        }
        ...


Aula 20. Include
----------------

    . Insira o método abaixo na classe "Program.cs":

        ...
        private static void GetAllPost()
        {
            using( var context = new BlogDataContext() ){
                // var posts = context
                //             .Posts
                //             .ToList();
                var posts = context
                    .Posts
                    .AsNoTracking()
                    .Include(x => x.Author)
                    .Include(x => x.Category)
                    .OrderBy(x => x.LastUpdateDate)
                    .ToList();                                

                foreach( Post post in posts ){
                    System.Console.WriteLine($"{post.Id} - {post.Title} - {post.Author.Name} - {post.Category.Name} - {post.LastUpdateDate}");
                }
            }
        }
        ...

        . Por padrão o Entity Framework utiliza o conceito LAZY LOAD (Carregar os objetos dependentes quando realmente 
            for necessário), onde não carrega as informações dos objetos filho associado ao objeto pai.

        . Para resgatar os valores desses objetos dependentes precisamos utilizar o método ".include( x => x.<class> )"

        . Outra maneira de evitar erros durante a execução é colocar o caracter de interrogação "?" ao lado do nome da classe:

            ...
            foreach( Post post in posts ){
                System.Console.WriteLine($"{post.Id} - {post.Title} - {post.Author?.Name} - {post.Category?.Name} - {post.LastUpdateDate}");
            }                                                                     |                       |  
            ...                                                                   +-----------------------+-----> Evita erro em tempo de compilação
                                                                                                                  qdo tiver valor nulo

    . Insira a linha abaixo no método "Main" da classe "Program.cs", execute e veja o resultado

        ...
        class Program
        {
            static void Main(string[] args)
            {
                ...
                GetAllPost();
                ...
            }
        }
        ...


Aula 21. Log
------------

    . Altere o método "onConfiguring" da classe "BlogDataContext.cs" como abaixo:

        ...
        protected override void OnConfiguring( DbContextOptionsBuilder options ){
            options.UseSqlServer("Server=localhost,1433;Database=Blog;User ID=sa;Password=Joao3.16");            
            options.LogTo( Console.WriteLine );
        }
        ...
    
    . Execute o projeto e verifique se as DML estão saindo no log do terminal.

    . Existe a propriedade ".ThenInclude( x => x.<class> )" para pegar a propriedade de um objeto do filho
   

Aula 22. Alterando um subconjunto
---------------------------------

    . Crie o método "UpdatePostAuthorName" na classe "Program.cs":

        ...
        private static void UpdatePostAuthorName(){
            var post = context
                .Posts
                .Include(x => x.Author)
                .Include(x => x.Category)
                .OrderBy(x => x.LastUpdateDate)
                .FirstOrDefault(); // Pegando o primeiro item
            
            post.Author.Name = "Uncle Bob";
            
            context.Posts.Update(post);
            context.SaveChanges();
        }
        ...

    . Faça a chamada deste método no método "Main":

        ...
        UpdatePostAuthorName();
        ...

    . Execute o projeto e verifique se o conteúdo do campo "Name" do "Author" foi alterado com sucesso.

    