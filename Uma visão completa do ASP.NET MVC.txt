Uma visão completa do ASP.NET MVC
---------------------------------

https://www.tutorialsteacher.com/core
https://www.completecsharptutorial.com/asp-net-mvc5/html-hiddenfor-example-aspnet-mvc5.php
https://dotnettutorials.net/lesson/asp-net-core-project-file/
https://asp.net-tutorials.com/
https://dotnettutorials.net/course/asp-net-core-tutorials/
https://dotnettutorials.net/lesson/setup-mvc-asp-net-core-application/
https://www.tutorialspoint.com/asp.net_core/asp.net_core_setup_mvc.htm

Fundamentos
-----------

Aula 1. Instalação
------------------

    . Como funciona a Web?

        . Para uma aplicação funcionar é necessário o conjunto abaixo:

            . HTTP - Protocolo utilizado para transferência de informações

            . REQUEST - Requisição feita ao servidor

            . RESPONSE - Resposta que o servidor ofrerece em relação a um Requisição

            . POST - Envio de informações

            . GET - Obtenção de informações

        . Os envolvidos nesse ambiente:

            . Client

                . Cliente: O Browser (Menos seguro)

                . Server: Azure, UOL, HOST, ETC. ( Mais seguro )

        . As linguagens:

            . HTML

            . CSS        

            . Javascript

            . ASP.NET

            . C#

            . Razor - Interações C# em um arquivo HTML

    
    . Sequência de eventos num ambiente ASP.NET:

        . Toda comunicação entre o Cliente e o Servidor ocorre através do protocolo HTTP.

        . O cliente faz uma Requisição (REQUEST) ao servidor, por POST ( FORM/URLENCODE ) por exemplo.

        . O servidor faz o processamento, utilizando ASP.NET, C#, RAZOR.

        . O servidor responde (RESPONSE) ao cliente (GET - HTML, CSS, JS) 

    . Padrão MVC

        . O que significa a sigla MVC:

            . Model - Classes, objetos, representação do seu BD

            . View - Html por exemplo.

            . Controllers - Interage com o model para preparar as informações para as views.

        . Normalmente usado para o desenvolvimento de interfaces de usuário que divide uma aplicação em partes (camadas/componentes) interconectadas. 
            Isto é feito para separar representações de informação internas dos modos como a informação é apresentada para e aceita pelo usuário,
            levando ao desenvolvimento paralelo de maneira eficiente.

        . Vantagens

            . Alto desacoplamento

            . Altamente testável

            . Maior organização

            . Boa divisão  de responsabilidades

    . Como funciona o ASP.NET MVC

        . Implementação do padrão MVC sobre o ASP.NET

        . Utiliza toda base do ASP.NET

            . Pipeline

            . Autenticação

            . Acesso a dados 

        . Modelo MVC dentro do ASP.NET:

            . Model - Representado pelas classes C#, exemplo: Produto.cs, Categoria.cs.

            . View - Arquivos CSHTML (RAZOR)

            . Controller
            
                . Classes que herdam de controller

                . Action - Um método do controller que executa algum código e retorna uma view

                . Route - Rotas para alcançar um controller/action via url

        . Sequência de eventos num ambiente ASP.NET MVC

            . O Cliente faz uma requisição HTTP ( HTTP Request );

            . A request passar pelas rotas (Roteamento);

            . O roteamento encontra a rota e instância o controller (Criação do controller);

            . O controller criado é feito a Autenticação/Autorização. Se o cliente não tem direito a rota é retornado uma request
                com statuscode 404.

            . De para (Model Binding). É o processo pelo qual o ASP.NET Core MVC recebe uma solicitação HTTP e "liga" partes dessa solicitação, 
                bem como outras fontes de dados, a entradas (por exemplo, parâmetros) em uma Action do controlador.  
                
                Por exemplo, vamos ver um URL simples: http://www.meusite.com/blog/posts/5

                Sabemos que esse URL está tentando recuperar a postagem do blog com o ID 5 da seção /blog do meusite.com. Mas o ASP.NET não 
                tem como saber quais são as nossas intenções e, portanto, usa a vinculação de modelo para analisar a URL. Por padrão, 
                o ASP.NET Core MVC usa a seguinte rota para mapear URLs de entrada: {controller}/{action}/{id?}
        
            . Execução da Action

            . Execução do resultado (view, file, etc).

            . Http Response.

        . Criando uma aplicação

            . Acesse o Visual Studio

            . Acesse File / New Project 

            . Na tela que abrirá escolha o "framework 4.2"; ASP.NET Web Application; informe o "Name:", "Location: " e o "Solution Name:"; 
                e pressione o botão OK.

            . Na próxima tela  de templates, escolha a opção "MVC"; Na parte de "Change Authentication", escolha "No Authentication"; 
                pressione o botão OK.

            . Ao final da criação, podemos notar que na estrutura do projeto foi criado as pastas: Models, Views e Controllers.

            . Clique com o botão direito sobre a pasta "Models", acione "Add/Class...". Dê o nome de Product.cs.

            . Na classe criada, implemente as propriedades abaixo:

                ...
                public class Product
                {
                    public int Id{ get; set; }
                    public string Title {get; set;}
                }
                ...

            . Acesse a opção "Build/Rebuild Solution"

            . Clique com o botão direito sobre a pasta "Controllers"; Escolha "Add new Controller"; Escolha a opção 
                "MVC5 Controller with views, using Entity framework"; acione o botão "Add".

            . Na tela seguinte informe os parâmetros abaixo:

                Model Class: Product
                Data Context class: "Acesse o botão de +; informe o conteúdo [Nome da aplicação].Models.AppDataContext"; Acione o "Add".

                . Pressione o botão "Add".

            . Dê um "run" na aplicação;

            . No navegador acione a url: localhost:51773/Products e testes a operações de CRUD da página.


Introdução ao ASP.NET
---------------------

Aula 2. Criando o Modelo
------------------------

    . Sobre o Model

        . É o coração do sistema

        . Também chamado de domínio.

        . Se possível de ser criado um projeto web separado

        . Quanto mais puro, melhor.

        . Cada item da sua composição pode ser chamado de entidade (produto, categoria, empregado)

    
    . Criando uma aplicação

        . Acesse o Visual Studio

        . Acesse File / New Project 

        . Na tela que abrirá escolha o "framework 4.2"; ASP.NET Web Application; informe o "Name:" como "BookStore", "Location: " e o "Solution Name:"; 
            e pressione o botão OK.

        . Na próxima tela  de templates, escolha a opção "MVC"; Na parte de "Change Authentication", escolha "No Authentication"; 
            pressione o botão OK.

        . Ao final da criação, podemos notar que na estrutura do projeto foi criado as pastas: Models, Views e Controllers.

        . Clique com o botão direito sobre a pasta "Models", acione "Add/Class...". Dê o nome de Categoria.cs.

        . Clique com o botão direito sobre a pasta "Models", acione "Add/Class...". Dê o nome de Livro.cs.

        . Clique com o botão direito sobre a pasta "Models", acione "Add/Class...". Dê o nome de Autor.cs.

        . Na classe criada, implemente as propriedades abaixo:

            ...
            public class Categoria
            {
                public int Id{ get; set; }
                public string Nome {get; set;}

                public ICollection<Livro> Livros{ get; set; }

                public Categoria()
                {
                    this.Livros = new List<Livro>();
                }
            }
            ...

            . Sempre que tiver uma collection num model faça a inicialização dela dentro do construtor.

            ...
            public class Livro
            {
                public int Id{ get; set; }
                public string Nome {get; set;}
                public string ISBN {get; set;}
                public DateTime DataLancamento {get; set;}

                public int CategoriaId { get; set; }
                public Categoria Categoria{ get; set; }

                public ICollection<Autor> Autores{ get; set; }

                public Livro()
                {
                    this.Autores = new List<Autor>();
                }

            }
            ...


            . Através do CategoriaId será feito o relacionamento com a classe Categoria.


            ...
            public class Autor
            {
                public int Id{ get; set; }
                public string Nome {get; set;}

                public ICollection<Livro> Livros { get; set; }

                public Autor()
                {
                    this.Livros = new List<Livro>();
                }


            }
            ...

            . IMPORTANTE: Quando for implementar as propriedades, se for digitado "prop" + Tab + Tab ocorre o autocomplete 

                            "public int MyProperty { get; set; }"

                          Outra forma de fazer isso seria com o comando "propfull"

                          Para realizar o autocomplete do Constructor digite "ctor"

    . Decorando as entidades

        . Uma entidade pode ser decorada (Required, stringlength, datatype)

        . Isto ger um metada que é utilizado pela view nas validações de formulários e pelo Entity Franework na geração do banco de dados.

        . Data Annotations.


    . Domínios e bancod de dados

        . Frameworks ORM abstraem nossa responsabilidade sobre o banco de dados.

        . Entity Framework é o ORM da Microsoft.

        . Instalado via NuGet
        
        . Precisa apenas de uma classe para trabalhar.


    . Decorando as entidades

        . Acesse a opção de menu "Project / Add Reference"

        . Localize a referência "System.ComponentModel.DataAnnotations"     
        
        . Acesse a classe Categoria e faça o decoration [Key] na propriedade Id que representa a chave da tabela e o [Required], 
            [StringLength] na propriedade Nome.

            ...
            public class Categoria
            {
                [Key]
                public int Id{ get; set; }

                [Required(ErrorMessage = "Campo Obrigatório")]
                [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")]
                public string Nome {get; set;}

            ...

    . Classe Livro

        using System;
        using System.Collections.Generic;
        using System.ComponentModel.DataAnnotations;    

        public class Livro
        {
            [Key]            
            public int Id{ get; set; }

            [Required(ErrorMessage = "Campo Obrigatório")]
            [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")]
            public string Nome {get; set;}

            [Required(ErrorMessage = "Campo Obrigatório")]
            [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")]
            public string ISBN {get; set;}

            [Required(ErrorMessage = "Campo Obrigatório")]
            [DataType(Datatype.Date)]
            public DateTime DataLancamento {get; set;}

            public int CategoriaId { get; set; }
            public Categoria Categoria{ get; set; }

            public ICollection<Autor> Autores{ get; set; }

            public Livro()
            {
                this.Autores = new List<Autor>();
            }

        }
        ...

    . Classe Autor

        ...
        public class Autor
        {
            [Key]
            public int Id{ get; set; }

            [Required(ErrorMessage = "Campo Obrigatório")]
            [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")]
            public string Nome {get; set;}

            public ICollection<Livro> Livros { get; set; }

            public Autor()
            {
                this.Livros = new List<Livro>();
            }


        }
        ...


    . Acesse a opção "Build/Rebuild"

    . No Visual Studio:

        . Acesse a opção "Ferramentas/SQL Server/New Query".

        . Escolha na tela que se abrir os parâmetros abaixo e dê "OK":
        
            Local: MSSQLLocalDB
            Server Name: (localdb)\MSSQLLocalDB
            Authentication: Windows Authentication
            User Name: [nome da máquina]/[Nome do Usuário da máquina]

    . No script que se abrir execute a DDL abaixo:

        ALTER LOGIN [sa]
            WITH PASSWORD = 'admin';


        GO
        ALTER LOGIN [sa] enable;

    . Acesse no menu "Ferramentas/Add SQL Server..." e informe os parâmetros abaixo:

        Local: MSSQLLocalDB
        Server Name: (localdb)\MSSQLLocalDB
        Authentication: SQL Server Authentication
        User Name: sa
        Password: admin

    . Com click direito sobre o nó principal do projeto "BookStore", escolha a opção "Manage NuGet Packages...", localize a referência 
        entityframework e faça a instalação.

    . Outra forma de fazer isso é via pacote (dê preferência a essa forma), acesse "View/Other Windows/Package Manager Console", sugirá no rodapé do IDE a aba 
        "Package Manager Console". Acesse essa aba e digite o comando abaixo:

            install-package entityframework

    . Acesse o arquivo "package.config" e verifique as dependências criadas.

    . Acesse o nó principal do projeto "BookStore" com o botão direito, escolha "Add/New Folder..." e nomeie com "Context".

    . Clique com o botão direito sobre a pasta "Context", Escolha "Add/Class" e coloque o nome da classe como "BookStoreDataContext".

    . Acesse a classe "BookStoreDataContext" e implemente o código abaixo:

        ...
        namespace BookStore.Context
        {
            public class BookStoreDataContext : DbContext
            {
                public BookStoreDataContext()
                    :base("BookStoreConnectionString")
                {

                }

                public DbSet<Autor> Autores{ get; set; }
                public DbSet<Categoria> Categorias{ get; set; }
                public DbSet<Livro> Livros{ get; set; }
            }
        }

    . Acesse o arquivo Web.Config e digite o trecho abaixo dentro da tag <configuration>:

        <configuration>
            ...
            <connectionStrings>
                <add name="BookStoreConnectionString" 
                        connectionString="Server=.\sqlexpress;Database=bookstore;User ID=sa;Password=sqlexpress"
                        providerName="System.Data.SqlClient"/>
            </connectionStrings>
            ...
        </configuration>            

        . A senha do sa no banco local ficou "Joao3.16"

    . Acione "Build/Clean" e "Build/Rebuild".

    . Acesse "Package Manager Console" no rodapé da IDE e digite o comando abaixo:

        enable-migrations

        . Esse comando criará uma classe "Configuration.cs" dentro da pasta "Migrations".

    . Digite na "Package Manager Console" o comando abaixo:

        add-migration v1

    . Digite também:

        update-database

    . Acesse o SQL Server e verifique se foi criado as classes com sucesso.

    . Reutlizando os models:

        . O domínio é o coração do seu sistema, ele pode ser reutilizado em vários pontos.

        . Manter o domínio separado da aplicação web poder ser uma boa escolha.

        . Evitar uso de pacotes adicionais na criação do domínio.

    Separando o domínio do projeto Web
    ----------------------------------

    . Clique com o botão direito do mouse sobre a solução, escolha "Add/New project", escolha "Windows/Class Library", 
        informe o nome do projeto "BookStore.Domain.

    . Selecione as Classes "Model" (Autor, Categoria, Livro) e mova elas para o projeto "BookStore.Domain".

    . Acesse a classe Livro.cs e elimine tudo que se refere ao decorator "DataAnnotations":


        using System;
        using System.Collections.Generic;
        // using System.ComponentModel.DataAnnotations;     // Eliminar

        namespace BookStore.Domain          // Inclua o Domain no namespace
        {
            public class Livro
            {
                // [Key]                                        // Eliminar
                public int Id{ get; set; }

                // [Required(ErrorMessage = "Campo Obrigatório")]       // Eliminar
                // [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")] // Eliminar
                public string Nome {get; set;}

                // [Required(ErrorMessage = "Campo Obrigatório")]       // Eliminar
                // [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")] // Eliminar
                public string ISBN {get; set;}

                // [Required(ErrorMessage = "Campo Obrigatório")]       // Eliminar
                // [DataType(Datatype.Date)]                            // Eliminar
                public DateTime DataLancamento {get; set;}

                public int CategoriaId { get; set; }
                public Categoria Categoria{ get; set; }

                public ICollection<Autor> Autores{ get; set; }

                public Livro()
                {
                    this.Autores = new List<Autor>();
                }

            }
        }
        ...

    . Faça o mesmo procedimento acima para as demais classes Model.

    . Acesso o projeto "BookStore" com o clique direito do mouse, selecione a opção "References Manager", vá em "Projects" e escolha o projeto
        "BookStore.Domain".

    . Retorne ao projeto "BookStore", acesse a classe "BookStoreDataContext.cs", faça a importação dos models com "Ctrl + .".

    . Acesse o projeto "BookStore" com o botão direito do mouse, escolha "Add/New Folder" e renomeie ela para "ViewModels".

    . Dê um clique direito sobre a pasta "ViewModels", escolha "Add/Class Diagram", dê o nome a ela de "VincularLivroAutorViewModel".

    . Implemente o código abaixo na classe "VincularLivroAutorViewModel":

        using System.ComponentModel.DataAnnotations;

        namespace BookStore.ViewModels
        {
            public class VincularLivroAutorViewModel
            {
                [Required(ErrorMessage="*")]
                public int AutorId { get; set; }

                [Required(ErrorMessage="*")]
                public int LivroId { get; set; }
            }
        }

    . Acesse o SQL Server e apague o banco de dados "BookStore".

    . Acesse a pasta "Migrations", apague o arquivo com a terminação "*_v1.cs".

    . Acesse o "Package Manager Console" no rodapé e digite os comandos abaixo:

        add-migration v1

        update-database

    . Acesse o SQL Server e veja:

        . A criação da tabela de relacionamento "LivroAutors".

        . As especificações de tamanho de campo, campos requeridos, etc. Observe que agora não existe mais nenhuma definição porque retiramos
            todos os decoration dos models.

    . Acesse o SQL Server e apague o banco de dados "BookStore".
    
    . Acesse a pasta "Migrations", apague o arquivo com a terminação "*_v1.cs".


    Forma diferente de mapear os models para o banco de dados
    ---------------------------------------------------------

    . Acesse o projeto "BookStore" com o botão direito do mouse, escolha "Add/New Folder" e renomeie ela para "Mappings".

    . Dê um clique direito sobre a pasta "Mapping", escolha "Add/Class Diagram", dê o nome a ela de "CategoriaMap".

    . Implemente o código abaixo na classe "CategoriaMap":

        using BookStore.Domain;
        using System.Data.Entity.ModelConfiguration;

        namespace BookStore.Mapping
        {
            public class CategoriaMap : EntityTypeConfiguration<Categoria>
            {
                public CategoriaMap()
                {
                    ToTable("Categoria");

                    HasKey( x => x.Id);
                    Property( x => x.Nome ).HasMaxLength(30).IsRequered();

                    HasMany( x=> x.Livros).WithRequired( x => x.Categoria);
                }
            }
        }

        . Dessa forma podemos ter mais flexibilidade para configurar as nossas classes entity. Verifique as propriedades disponíveis
            nos métodos do "Property()." e "HasMany()."

        
    . Dê um clique direito sobre a pasta "Mapping", escolha "Add/Class Diagram", dê o nome a ela de "AutorMap".

    . Implemente o código abaixo na classe "AutorMap":

        using BookStore.Domain;
        using System.Data.Entity.ModelConfiguration;

        namespace BookStore.Mapping
        {
            public class AutorMap : EntityTypeConfiguration<Autor>
            {

                public AutorMap()
                {
                    ToTable("Autor");

                    HasKey( x => x.Id);
                    Property( x => x.Nome ).HasMaxLength(60).IsRequered();

                    HasMany( x=> x.Livros)
                        .WithMany( x => x.Autores)
                        .Map( x => x.ToTable("LivroAutor"));
                }
            }
        }

    . Dê um clique direito sobre a pasta "Mapping", escolha "Add/Class Diagram", dê o nome a ela de "LivroMap".

    . Implemente o código abaixo na classe "LivroMap":

        using BookStore.Domain;
        using System.Data.Entity.ModelConfiguration;

        namespace BookStore.Mapping
        {
            public class LivroMap : EntityTypeConfiguration<Livro>
            {
                public LivroMap()
                {
                    ToTable("Livro");

                    HasKey( x => x.Id);
                    Property( x => x.Nome ).HasMaxLength(60).IsRequered();
                    Property( x => x.ISBN ).HasMaxLength(32).IsRequered();
                    Property( x => x.DataLancamento ).IsRequered();
                }
            }
        }
        
    . Retorne a classe "BookStoreDataContext" e implemente o método abaixo na classe:

        ...
        protected override void OnModelCreating( DbModelBuilder modelBuilder)
        {
            modelBuilder.Configurations.Add( new AutorMap() );
            modelBuilder.Configurations.Add( new CategoriaMap() );
            modelBuilder.Configurations.Add( new LivroMap() );
        }

    . Acesse o "Package Manager Console" no rodapé e digite os comandos abaixo:

        add-migration v1

        update-database

    . Acesse o SQL Server e veja:

        . A criação da tabela de relacionamento "LivroAutor".

        . As especificações de tamanho de campo, campos requeridos, etc. Observe que agora não existe mais nenhuma definição porque retiramos
            todos os decoration dos models.


3. Criando um Controller
------------------------

    . Um pouco mais sobre o controller...

        . Nada mais é do que uma classe que herda de uma classe base.

        . Possui métodos públicos acessíveis via URL.

        . Ficam armazenados na pasta controllers da aplicação.

    . Abra a classe HomeController.cs e observe herança da classe "Controller".

    . Métodos "public" no controller serão acessíveis via URL.

    . Actions:

        . São métodos públicos dentro de controllers.

        . Retornam views (cshtml), arquivos, strings, json, inteiros, etc. Baseados no action result.

        . Podem ser interrompidas antes ou depois de sua execução.

        . Pode ter um retorno genérico (actionresult) ou um retorno específico (viewresult, fileresult...).

    . Existem vários tipos de retornos de um métodos controller ( ActionResult, ViewResult, etc) :

        ...
        public ActionResult Index()     // No lugar do retorno ActionResult poderiamos retornar uma ViewResult neste caso.
        {                               // ActionResult é o mais generico de todos os results
            return View();
        }


    . Action Results

        . São os resultados da execução de uma action

        . Possuem classes espcíficas para otimizar o retorno.

    . De um clique direito sobre a pasta "Controllers", acione "Add/Class..."; porém o correto seria "Add/Controller..."

    . Informe o nome da classe "TesteController.cs"

    . Implemente o código abaixo na classe "TesteController.cs":

        using System.Web.Mvc;

        namespace Bookstore.Controllers
        {
            public class TesteController: Controller
            {
                public string Teste()
                {
                    return "Testado";
                }
            }
        }

    . Execute o projeto, vá no navegador e acione a url abaixo:

        localhost:[porta]/Teste/Teste

    . Altere o código da classe TesteController como abaixo:

        using System.Web.Mvc;

        namespace Bookstore.Controllers
        {
            public class TesteController: Controller
            {
                public JsonResult Teste()
                {
                    var autor = new Autor{
                        Id=1,
                        Nome="Marco Antonio"
                    };

                    return Json( autor, JsonRequestBehavior.AllowGet);
                }
            }
        }

    . Execute o projeto, vá no navegador e acione a url abaixo:

        localhost:[porta]/Teste/Teste

    . Recebendo parâmetros:

        . Podemos receber parâmetros via query string.

        . Podemos receber parâmetros via post.

        . Podemos receber objetos complexos.

    . Uma requisição é coposta por um cabeçalho (Header) e um corpo (body).

    . O cabeçalho contém uma lista (chave/valor) informando vários parâmetros como tipo de dados do corpo, token de segurança e afins.

    . O corpo em sí contém as informações que devem ser serializadas de acordo com o parâmetro "contenttype" presente no cabeçalho.

    . Model Binder:

        . Faz a atribuição dos parâmetros recebidos no corpo da requisição.

        . Consegue instanciar objetos complexos.

        . Tenta obrigatoriamente mapear todos os parâmetros não nulos da requisição.


Aula 3 - Entendendo as URL amigáveis.
-------------------------------------        

    . Sobre a rota padrão do MVC

        . http://localhost:2030/

            . localhost - Representa seu domínio, ou seja, localhost significa rodando localmente.

            . :2030 - Representa a porta na qual o site está respondendo.

        . Se nda for informado após a porta do domínio, o ASP.NET MVC interpreta a rota padrão:

            . http://dominio:porta/controller/action/parâmetros

                . O controller padrão é o homeController

                . A action padrão é sempre a index.

    . Sobre a rota padrão do MVC

        . Um controller no MVC sempre possui o sufixo "controller" que é ignorado na URL:

            . http://localhost:2030/home/sobre
            . http://localhost:2030/home/empresa
            . http://localhost:2030/home/contato
            

        . Caso nenhuma action seja informada, o ASP.NET MVC tentará mapear uma action chamada "index" no controller

            . http://localhost:3020/cliente - busca automaticamente uma action chamada "index" no controller "clienteController"

    . Acesse a classe TesteController e altere o nome da propriedade "Teste" para "UmaAction".

        ...
        public JsonResult UmaAction()
        {
            var autor = new Autor{
                Id=1,
                Nome="Marco Antonio"
            };

            return Json( autor, JsonRequestBehavior.AllowGet);
        }
        ...


    . Execute o projeto e no navegador execute a URL abaixo:

        http://localhost:52147/Teste/UmaAction
                                |       |
                                |       |
                                |       +----> Irá chamar o método "public Autor UmaAction()"
                                |
                                +---> irá chamar a classe controller "public class TesteController: Controller"

    . Execute a URL http://localhost:52147/Index e veja o resultado:

        . Dará erro porque a classe TesteController não tem o método/action com o nome "index".

        . Acrescente o método abaixo e execute novamente a url "http://localhost:52147/Index"

            ... 
            public string Index()
            {
                return "Index";
            }
            ...

    . Sobre a rota padrão do MVC

        . Uma action pode ser decorada com um atributo actionName, para trocar seu nome.

        . Por padrão, uma parâmetro do tipo inteiro, opcional, é esperado no final da rota.

        . Caso este parâmetro seja informado ele é automaticamente mapeado para um parâmetro "id" da action:

            http://localhost:2030/produto/detalhes/23

    . Altere o método "Index" da classe "TesteController" acrescentando o parâmetro "Id":

        ... 
        public string Index( int Id )
        {
            return "Index " + Id.ToString();
        }
        ...

    . Execute o projeto e no navegador execute a URL abaixo:

        http://localhost:52147/Teste/Index/1

    
    . Sobre a rota padrão do MVC

        . Em resumo, podemos definir a rota padrão do ASP.NET MVC como:

            . http://{dominio}:{porta}/{controller}/{action}/{id?}

            . Onde "id" é um parâmetro opcional, o "?" seria para representar essa definição.

        . Sendo assim, se temos um controller chamado {LivroController}, com uma action chamada {detalhes}, recebendo um {id}
            do livro a ser exibido como {parâmetro}, teriamos a seguinte URL:

          http://localhost:2030/livro/detalhes/32


        . Parâmetros adicionais podem ser passados para a rota via query string:

            . http://localhost:2030/livro/listar?categoria=2

            . Lista todos os livros da categoria 2

        . Neste caso, a action deve esperar um parâmetro chamado "categoria" do tipo inteiro

        . Em caso de parâmetros adionais deve-se utilizaro "&"

            . http://localhost:2030/livro/listar?categoria=2&autor=1

            . Lista todos os livros da categoria 2 cujo "id" do autor é 1

        . Existe um limite de 1024 caracteres para uma URL

        . Em caso de muitos parâmetros, realize um POST.

    . Acesse a classe TesteController e altere o método "UmaAction" conforme abaixo:

        ...
        public Autor UmaAction( int id, string nome)
        {
            var autor = new Autor{
                Id= id,
                Nome=nome
            };

            return Json( autor, JsonRequestBehavior.AllowGet);
        }
        ...

    . Execute o projeto e no navegador execute a URL abaixo:

        http://localhost:52147/Teste/UmaAction

        . A URL acima dará erro porque não foram informado os parâmetros da URL.

    . Execute o projeto e no navegador execute a URL abaixo com os parâmetros necessários:

        http://localhost:52147/Teste/UmaAction?id=1&nome=MARCO

    . O parâmetro "nome" por ser uma "string" ele é opcional, porém o "id" que é um "int" este é Obrigatório. Para deixar o parâmetro
        opcional devemos utilizar o caracter "?" no tipo do parâmetro.

    . Altere a assinatura do método "UmaAction" como abaixo:


        ...
        public Autor UmaAction( int? id, string nome)   // Alterado int?. Neste caso deve-se colocar um valor default 0
        {
            var autor = new Autor{
                Id= 0,
                Nome=nome
            };

            return Json( autor, JsonRequestBehavior.AllowGet);
        }
        ...

    . Execute o projeto e no navegador execute a URL abaixo:

        http://localhost:52147/Teste/UmaAction

        . Agora não dará mais erro porque o parâmetro "id" agora é opcional.

    . O recurso de querystring somente é interessante qdo estamos trabalhando com paginação:

        http://localhost:52147/Teste/UmaAction?listar=10&pagina=5

    . Evitar o uso de querystring devido a limitação de 1024 byte de tamanho da querystring

    . Acrescente o método "ActionDois" na classe "TesteController" como abaixo:

        ...
        [HttpPost]
        public JsonResult ActionDois( Autor autor)
        {
            return Json( autor );
        }
        ...

    . Acesse o Postman, crie uma nova URL como:

        method: POST
        url: http://localhost:52147/Teste/ActionDois
        body: [
            raw
            type: JSON
            parameters: { 
                        "Id": "1",
                        "Nome": "Marco"
            }
        ]

    . Coloque um "BreakPoint" na linha com "return Json( autor )" na classe "TesteController" e execute a URL no Postman.

    . Outra forma para executar a URL "ActionDois" com parâmetros dentro do Postman seria fazendo uso do "form-data".

        . Dentro da aba "Body", escolha o tipo "form-data".

        . Insira os parâmetros abaixo:

            . Id: 1
            . Nome: "Marco"

        . Execute a URL no Postman.

    . Insira a decoration "ActionName" no método "ActionDois" como abaixo:

        ...
        [HttpPost]
        [ActionName("Autor")]
        public JsonResult ActionDois( Autor autor)
        {
            return Json( autor );
        }
        ...

    . No Postman altere a chamada da URL como abaixo:

        url: http://localhost:52147/Teste/Autor


    . Route Table

        . Existe uma ordem na execução das rotas no ASP.NET MVC.

        . A rota padrão pode ser alterada.

        . Caso a rota não seja encontrada, a padrão é acionada.

        . Caso a rota padrão seja incompatível, o erro 404 será lançado.


Aula 4 - Travegando informações para a View
------------------------------------------- 

    . Um pouco mais sobre as Views

        . São HTML, CSS e Javascript.

        . Podem executar funções do C# com Razor (View Engine).

        . Podem interagir com objetos enviados a ela.

        . São processadas no servidor e enviadas para o cliente.

        . As Views podem receber parâmetros como variáveis ou tipos complexos.

        . Estes parâmetros são recebidos através da sintaxe @Model

        . Se um parâmetro diferente do esperado for enviado a view, causará um erro.

            . Este erro só ocorrerá em tempo de execução.

        . Além dados fisos, a view pode receber dados de outras formas.

    . Outras formas de enviar informações:

        . ViewBag

            . Tipo dinâmico, um wrapper para o viewdata, é automaticamente excluído após a rendererização da view.

        . ViewData

            . Criado informando uma string, no modelo chave/valor, é automaticamente excluído após a rendererização da view

        . TempData

            . Criado informando uma string, no modelo chave/valor, é automaticamente excluído após a segunda requisição.

        . Session

            . Criado informando uma string, no modelo chave/valor, permanece no servidor por um tempo determinado pelo desenvolvedor.

    . Cuidados com Session

        . Não escala.

        . Pode acumular lixo no servidor

        . É fracamente tipada.

        . Manipula na tela tudo que ocê precisar.

    . Inclua o método abaixo na classe "TesteController":

        ...
        public ViewResult Dados( int id)
        {
            return View( id );
        }
        ...

    . Dê um clique direito sobre a Action, sobre o nome do método "Dados"  e escolha a opção "Add View..."

    . Acione o botão "Ok" da tela seguinte.

    . Acesse o componenete Dados.cshtml e insira o código abaixo:

        @model int
        @{
            ViewBag.Title = "Dados";
        }

        <h2>Dados da @Model</h2>

    . Acesse o navegador e execute a URL abaixo:

        http://localhost:52147/Teste/Dados/1

    
    . Altere o método "Dados" do "TesteController" como abaixo:

        ...
        public ViewResult Dados( int id)
        {
            return View( "" );  // Alterado o id pelo ""
        }
        ...

    . Acesse o navegador e execute a URL abaixo:

        http://localhost:52147/Teste/Dados/1

        . Observe que dará erro porque durante a conversação do parâmetro não foi possivel transformar para inteiro.

    . Repita a mesma operação, porém utilizado um parâmetro data.

        ...
        public ViewResult Dados( int id)
        {
            return View( DateTime.Now );  // Alterado o id pelo DateTime.Now
        }
        ...

    . Altere o metodo "Dados" pelo conteúdo abaixo:

        ...
        public ViewResult Dados( int Id )
        {
            var autor = new Autor{
                Id = 1,
                Nome = "Marco"
            };

            return View(autor);
        }
        ...

    . Acesse o componenete Dados.cshtml e insira o código abaixo:

        @model BookStore.Domain.Autor
        @{
            ViewBag.Title = "Dados";
        }

        <h2>Dados da @Model.Nome</h2>

    . Acesse o navegador e execute a URL abaixo:

        http://localhost:52147/Teste/Dados/1


    . Altere o metodo "Dados" pelo conteúdo abaixo:

        ...
        public ViewResult Dados( int Id )
        {
            var autor = new Autor{
                Id = 1,
                Nome = "Marco"
            };

            ViewBag.Categoria = "Produtos de Limpeza";
            ViewData["Categoria"] = "Produtos de Informática";
            TempData["Categoria"] = "Produtos de Escritória";
            Session["Categoria"] = "Móveis";


            return View(autor);
        }
        ...

    . Acesse o componenete Dados.cshtml e insira o código abaixo:

        @model BookStore.Domain.Autor
        @{
            ViewBag.Title = "Dados";
        }

        <h2>Dados da @Model.Nome</h2>

        <ul>
            <li>ViewBag: @ViewBag.Categoria</li>
            <li>ViewData: @ViewData["Categoria"]</li>
            <li>TempData: @TempData["Categoria"]</li>
            <li>Session: @Session["Categoria"]</li>
        </ul>

    . Acesse o navegador e execute a URL abaixo:

        http://localhost:52147/Teste/Dados/1

    . Evite de usar ViewBag, ViewData, TempData e Session. Utilize o viewModel "@Model" que acaba sendo muito mais eficiente.



Rotas
-----

Aula 5. Criando rotas customizadas
----------------------------------

    . Qunado a rota padrão não atende:

        . Podemos criar rotas customizadas no ASP.NET MVC habilitando a opção no arquivo RouteConfig.cs:

            routes.MapMvcAttributeRoutes();

        . Os mapamentos devem ser feitos antes da rota padrão, ou seja, esta configuração deve ficar antes do "ROUTES.MAPROUTE" padrão.

        . Feito isto, basta decorara os controllers com o atributo routing

            [Route("produto/{id?}")]

        . Com isto, conseguimos manter a escrita do código em inglês e as rotas em português.

    . Podemos colocar as rotas dentro do arquivo "App_Start/RouteConfig.cs". Conteúdo inicial deste arquivo seria:

        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Web;
        using System.Web.Mvc;
        using System.Web.Routing;

        namespace BookStore
        {
            public class RouteConfig
            {
                public static void RegisterRoutes(RouteCollection routes)
                {
                    routes.IgnoreRoute("{resource}.axd/{*pathInfo}");

                    routes.MapRoute(
                        name: "Default",
                        url: "{controller}/{action}/{id}",
                        defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
                    );
                }
            }
        }

        . Atentar para o detalhe que as rotas identificadas dentro do método "RegisterRoutes" segui a sequência de declarações, 
            a primeira que for encontrada será executada.

    . Mapeamento

        . Basicamente, o qur escrito no atributo será capturado via URL, ou seja, se decorar uma ação com o atributo:

            [Route("loja/promocoes/produto/{id?})]        

        . Sua URL ficará:

            http://localhost:[porta]/loja/promocoes/produto/1

        . A captura de parâmetros na URL é feita pelo nome do mesmo entre chaves, e no caso de parâmetros nullable, adiciona-se um 
            sinal de interrogação ao final do mesmo.

        . Caso queria definir um valor padrão para o parâmetro, basta adicionar "=valor"

    . Parâmetro padrão:

        . Parâmetro padrão:

            [Route("loja/promocoes/prodto/{id}")]
        
        . Parâmetro nullable

            [Route("loja/promocoes/prodto/{id?}")]

        . Parâmetro com valor padrão

            [Route("loja/promocoes/prodto/{id}=1")]

        . Parâmetro tipado com valor padrão

            [Route("loja/promocoes/prodto/{id:int=1}")]


    . Acesse o arquivo "RouteConfig.cs" e insirá a linha "routes.MapMvcAttributeRoutes()":

        ...
        public static void RegisterRoutes(RouteCollection routes)
        {
            routes.IgnoreRoute("{resource}.axd/{*pathInfo}");

            routes.MapMvcAttributeRoutes();     // Linha inserida

            routes.MapRoute(
                name: "Default",
                url: "{controller}/{action}/{id}",
                defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
            );
        }

        . Serve para ativar o roteamento baseado em atributo no ASP.NET MVC 5

    . Acesse a classe "TesteController.cs" e implemente o método abaixo:

        ... 
        [Route("minharota")]
        public string MinhaAction()
        {
            return "Ok! Cheguei na rota";
        }
        ...

        . Nesse caso a URL ficará somente http://localhost:[porta]/minharota

    . Insira o parâmetro "id" na rota e na assinatura do método:

        ... 
        [Route("minharota/{id}")]
        public string MinhaAction(int id)
        {
            return "Ok! Cheguei na rota";
        }
        ...

        . Execute a URL  http://localhost:[porta]/minharota/1

        . Neste caso o parâmetro é Obrigatório, caso não for fornecido um "id" na url obteremos o statuscode 404. 

        . Para não deixar obrigatório o parâmetro precisamos colocar o "?" nos parâmetros da URL e da assinatura do método

            ... 
            [Route("minharota/{id?}")]
            public string MinhaAction(int? id)
            {
                return "Ok! Cheguei na rota";
            }
            ...

        . Execute a URL  http://localhost:[porta]/minharota/

        . Para deixar obrigatório o parâmetro como um inteiro precisamos definir o tipo na rota

            ... 
            [Route("minharota/{id:int}")]
            public string MinhaAction(int id)
            {
                return "Ok! Cheguei na rota";
            }
            ...

        . Execute a URL  http://localhost:[porta]/minharota/banana para dar erro

        . Execute a URL  http://localhost:[porta]/minharota/1

    . Prefixo de rota

        . Cria um prefixo antes de uma, ou mais rotas de controller

        . Otimiza seu tempo na escrita de rotas personalizadas

        . Utiliza o atributo routePrefix para realização do mesmo

        . Basta decorar um controller com RoutPrefix para utilizar

        . Requer que o mapamento de rotas esteja habilitado.


    . Prefixo de rota

        . Toda rota para este controller deve iniciar com loja

            [RoutePrefix("loja")]

        . Rota com parâmetro não obrigatório:

            [Route("produto/{id?})]

            http://localhost:[porta]/loja/produto/1

            ou

            http://localhost:[porta]/loja/produto/

        . Para ignorar o RoutPrefix em uma action exclusivamente, utilize "~" antes da rota

            [Route("~/produto/detalhes/{id?})]

            http://localhost:[porta]/produto/detalhes/1     // Sem loja como prefixo.


    . Acesse a classe "TesteController.cs" e acrescente o decorator [RoutePrefix("teste")]    

        ...
        [RoutePrefix("teste")]
        public class TesteController: Controller
        {
            ...
        }
        ...

        . A partir desse momento toda chamada a essa api deverá vir acrescida no pathname a constante "teste", exemplo:

            http://localhost:[porta]/teste/minharota/1

        . Para ignorar o prefixo "teste" podemos utilizar o "~" na definição da rota do método.

            ... 
            [Route("~/minharota/{id:int}")]
            public string MinhaAction(int id)
            {
                return "Ok! Cheguei na rota";
            }
            ...

            . Execute o projeto com a URL http://localhost:[porta]/minharota/1

    . Clique com o botão direito do mouse sobre a pasta "Controllers", escolha "Add/New Controller..." e escolha 
        "Controller MVC 5 Empty"

    . Dê o nome de "AuthorController"

    . Acesse a classe "AuthorController" e implemente o código abaixo:

        ...
        namespace BookStore.Controllers
        {

            [RoutePrefix("autores")]
            public class AuthorController: Controller
            {
                [Route("listar")]
                public ActionResult Index()
                {
                    return View();
                }

                [Route("criar")]
                public ActionResult Create()
                {
                    return View();
                }

                [Route("editar/{id:int}")]
                public ActionResult Edit(int id)
                {
                    return View();
                }

                [Route("excluir/{id:int}")]
                public ActionResult Delete(int id)
                {
                    return View();
                }

            }
        }

    . Clique com o botão direito sobre o nome do método "Index, Create, Edit e Delete", escolha "Add/New Action..."

    . Execute as URLs abaixo:

        http://localhost:[porta]/autores/listar

        http://localhost:[porta]/autores/criar

        http://localhost:[porta]/autores/editar/1

        http://localhost:[porta]/autores/excluir/1


Aula 6. Restringindo Rotas
--------------------------

    . Tipos de parâmetros das rotas:

        Constraint              Descrição                                                               Exemplo
        ----------              ---------                                                               -------
        alpha                   Matches uppercase or lowercase latin alphabet characters (a-z, A-Z)     {x:alpha}
        bool                    Matches a boolean value                                                 {x:bool}
        datetime                                                                                        {x:datetime}
        double                  64 bit floating-point                                                   {x:double}
        float                   32 bit                                                                  {x:float}
        guid                                                                                            {x:guid}
        int                                                                                             {x:int}
        length                                                                                          {x:length(6)} {x:length(1,20)}
        long                    64 bit integer                                                          {x:long}
        max                     Matches an integer with a maximum value                                 {x:max(10)}
        min                     Matches an integer with a minimum value                                 {x:min(10)}                                                                                   
        minlength               String with a minumum length                                            {x:minlength(10)}
        range                                                                                           {x:range(10,50)}
        regex                                                                                           {x:regex(^\d{3}-\d{3}-\d{4}$)}

    . Restrições nas rotas

        . O atributo route permite a plicaão de restrições nas rotas

        . O atributo abaixo etá restrito a receber apenas parâmetros inteiros:

            [Route("produto/detalhes/{id:int}")]

        . Estas restrições interferem em como as rotas são chamadas.

        . Por exemplo, se houverem duas rotas:

            [Route("produto/detalhes/{id:int}")]

            [Route("produto/detalhes/{name}")]

        . Caso um inteiro seja informado, a primeira rota será executada, caso contrário, a segunda.

        . As restrições nas rotas podem ser cumulativas:

            [Route("produto/{id:int:min(1)}")]

            [Route("produtos/{categoria:maxlength(3)?}")]
    
    . Acesse a classe "TesteController.cs" e implemente o código abaixo:

        ...
        [Route("rota/{caegoria:minlength(3)}")]
        public string MinhaAction3( string categoria){
            return "MinhaAction3 " + caegoria;
        }
        ...

        . Execute no navegador a URL abaixo:

            . Para testar com erro:

            http://localhost:[porta]/teste/rota/ab
        
            . Para testar sem erro:

            http://localhost:[porta]/teste/rota/abc

        . Altere o datatype do parametro, colocando "alpha":

            ...
            [Route("rota/{caegoria:alpha:minlength(3)}")]
            public string MinhaAction3( string categoria){
                return "MinhaAction3 " + caegoria;
            }
            ...

        . Execute no navegador a URL abaixo:

            . Para testar com erro:

            http://localhost:[porta]/teste/rota/123
        
            . Para testar sem erro:

            http://localhost:[porta]/teste/rota/abc

    . Customizando as restrições

        . Podemos criar nossa própria restrição para  rota

        . Basta criar uma class e implemntar a interface [RoutConstraint]

        . Muito útil qdo trabalhamos com enumeradores por exemplo

        . Dada a classe contrída, é necssário adicionar a restrição a lista de restrições padrão:

            var constraintResolver = new DefaultInlineConstraintResolver();

            ConstraintResolver.ConstraintMap.Add("tipoProduto", typeOf(tipoProdutoConstraint));

    . Clique com o botão direito sobre o projeto BookStore, escolha "Add/New Folder" e dê o nome de "RoutesConstraints".

    . Clique com o botão direito sobre a pasta "RoutesConstraints", "Add/New Class" e dê o nome de "ValuesConstraint.cs".



ATENÇÃO: A demo abaixo não ocorreu com sucesso. Fazer pesquisa para ver se consegue corrigir
--------------------------------------------------------------------------------------------

    . Implemente o código abaixo na classe criada:
16:07
        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Web;
        using System.Web.Routing;

        namespace BookStore.RoutesConstraints
        {

            public class ValuesConstraint: IRouteConstraint
            {
                private readonly string[] validOptions;
                
                public ValuesConstraint( string options )
                {
                    validOptions = options.Split('|');
                }

                public bool Match( HttpContextBase httpContxt, 
                                    Route route, string parameterName, 
                                    RouteValueDictionary values, 
                                    RouteDirection routeDirection )
                {
                    object value;

                    if (values.TryGetValue( parameterName, out value ) &&  value!= null)
                    {
                        return validOptions.Contains( value.ToString(), StringComparer.OrdinalIgnoreCase );
                    }

                    return false;
                }
            }
        }

https://www.c-sharpcorner.com/UploadFile/ff2f08/custom-route-constraints-in-Asp-Net-mvc-5/

    . Acesse a classe RouteConfig.cs e insira o código abaixo:

        ...
        public static void RegisterRoutes(RouteCollection routes)
        {
            routes.IgnoreRoute("{resource}.axd/{*pathInfo}");

            /* Valores Inseridos */
            var constraintsResolver = new DefaultInlineConstraintResolver();
            
            constraintsResolver.ConstraintMap.Add("values", typeof( ValuesConstraint ));
            /* */

            routes.MapMvcAttributeRoutes( constraintsResolver );     // Linha Alterada

            routes.MapRoute(
                name: "Default",
                url: "{controller}/{action}/{id}",
                defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
            );

            /* Valores Inseridos */
            routes.MapRoute(name: "newRoute",
                    url: "api/rota/estacao/{estacao:values(primavera|verao|outono|inverno)}",
                    defaults: new { controller = "Teste", action = "MinhaAction4" },
                    constraints: new { name = new ValuesConstraint("primavera|verao|outono|inverno") }
            );
            /* */
        }

    . Implemente o método abaixo na classe "TesteController.cs":

        ...
        [Route("rota/estacao/{estacao:Values(primavera|outono|verao|inverno)}")]
        public string MinhaAction4(string estacao)
        {
            return "Olá, estamos no " + estacao;
        }

Aula 7. Action Filters
----------------------
 
    . Filtros

        . Action Filter é um atributo que você pode aplicar a uma action ou um controller.

        . Uma action/controller pode conter vários filtros.

        . Existem 4 tipos de filtros

            . Authorization filters - Implementam autorização

            . Action filters - Genéricos, implementao de IActionFilter

            . Result filters - Formatam os resultados, implementam IResultFilter

            . Exception Filters - Tratam exceções, implementa IExceptionFilter.

    . Os filtros possuem uma ordem de execução:

        . Authorization Filters.

        . Action Filters

        . Result Filters

        . Exception Filters.

    . O filtro padrão, que implementa o IActionFilterAttribute possui os seguintes métodos:

        . OnActionExceuting

            . Executado antes da chamado da action

        . OnActionExecuted

            . Executado depois da chamada a action

        . OnResultExecuting

            . Executado antes do retorno do resultado da action

        . OnResultExecuted

            . Executado depois do retorno do resultado da action.

    . Clique com o botão direito sobre o projeto BookStore, escolha "Add/New Folder" e dê o nome de "Filters".

    . Clique com o botão direito sobre a pasta "Filters", "Add/New Class" e dê o nome de "LogActionFilter.cs".

    . Implemente o código abaixo na classe recém criada:

        using System;
        using System.Diagnostics;
        using System.Web.Mvc;
        using System.Web.Routing;

        namespace BookStore.Filters
        {
            public class LogActionFilter : ActionFilterAttribute
            {
                public override void OnActionExecuting(ActionExecutingContext filterContext)
                {
                    Log("OnActonExecuting", filterContext.RouteData);
                }

                public override void OnActionExecuted(ActionExecutedContext filterContext)
                {
                    Log("OnActionExecuted", filterContext.RouteData);
                }



                public override void OnResultExecuting(ResultExecutingContext filterContext)
                {
                    Log("OnResultExceuting", filterContext.RouteData);
                }

                public override void OnResultExecuted(ResultExecutedContext filterContext)
                {
                    Log("OnResultExecuted", filterContext.RouteData);
                }

                private void Log(string methodName, RouteData routeData)
                {
                    var controllerName = routeData.Values["controller"];
                    var actionName = routeData.Values["action"];
                    var message = String.Format("{0} controller: {1} action: {2}", methodName, controllerName, actionName);

                    Debug.WriteLine(message, "ACtion Filter Log");
                }

            }
        }
        
        
    . Acesse a classe AuthorController e insira [LogActionFilter()] como abaixo:

        ...
        namespace BookStore.Controllers
        {
            [RoutePrefix("autores")]
            [LogActionFilter()]
            public class AuthorController: Controller
            {
                ...
            }
        }

    . Coloque "BreakPoints" na classe LogActionFilter, dentro de cada método sobreescrito e execute o projeto.

    . O decorator [LogActionFilter()] pode ser colocado em um método especifico 


Aula 8. Global Filters
----------------------

    . Filtros globais

        . Os filtros criados podem ser implementados globalmente

        . Evita a necessidade de decorar as actions ou controllers

        . Não tem perigo de esquecer 

        . Com o filtro criado, é só registrá-lo no global.asax

            . Globalfilters, filters, add( new myActionFilterAttribute());

            . RegisterGlobalFilter(GlobalFilters.filters)

    . Acesse a classe AuthorController e comente todas as linhas com o decoration "[LogActionFilter]"

    . Acesse o arquivo Global.asax e implemente as linhas abaixo:

        ...
        namespace BookStore
        {
            public class MvcApplication: System.Web.HttpApplication
            {
                /* Linhas inseridas */
                GlobalFilters.Filters.Add( new LogActionFilter());
                /* */

                ...
            }
        }

    . Execute a aplicação e verifique se os "BreakPoints" do filter continua funcionando.

    . IMPORTANTE: Tomar cuidado com o consumo de recurso que os filtros podem tomar da aplicação. Como é um filtro 
                    global, ou seja, executado para todos os controllers, ele executará todos os métodos disponíveis
                    na classe filter. Dependendo do que for feito nesses métodos o tempo de resposta ficará alto, impactando
                    na performance da aplicação.


Aula 9. Entendendo o Repository Pattern
---------------------------------------

    . Sobre Design Patterns

        . São padrões de desenvolvimento de softwares

        . Pregam boas práticas na escrita e arquitetura de softwares.

        . É mais importante saber quando, do que como utilizar.

    . Sobre o uso de interfaces

        . Interface é um contrato

        . Define quais métodos e propriedades um objeto deve expor

        . O ideal é sempre depender do contrato (interface) e nunca da implementação.

        . Um contrato pode ter várias implementações.

    . Um pouco mais sobre EF

        . Data Context

            . É a representação do banco de dados em memória.

            . Podemos adicionar, atualizar e excluir objetos em memória

            . Só persiste no banco quando chamamos o saveChanges()

            . Podemos ter vários data Contexts.

        . CRUD

            . Sigla para create, read, update, delete.

            . São as operações básicas.

        . Migration

            . Como abstraimos o banco de dados, o migrations se encarrga de atualiá-lo sempre que nosso
                modelo (domínio) mudar.

    . Sobre o repository pattern

        . Padrão para desaboplamento do acesso à dados da sua aplicação web.

        . Cria uma unidade de acesso à dados para cda entidade do modelo

        . Cada qual é responsável pela leitura e persistência das informações referentes a entidade.

        . Caso precise alterar alguma fonte de dados um dia, sua aplicação continua a mesma.

    . Sobre os repositórios genéricos

        . É possível criar um repositório genérico, mas...

        . Estude com cuidado cada query que o EF executa

        . Querendo ou não, o banco de dados é algo importante para a aplicação.

        . É muito importante otimizar a leitura e escrita nele.

    . Clique com o botão direito sobre o projeto BookStore, escolha "Add/New Folder" e dê o nome de "Repositories".

    . Clique com o botão direito sobre a pasta recém criada, escolha "Add/New Folder" e dê o nome de "Contracts".

    . Clique com o botão direito sobre a pasta "Contracts", "Add/New Class" e dê o nome de "IAuthorRepository.cs".

    . Dentro da classe IAuthorRepository insira o código abaixo, detalhe: esse objeto não é uma classe e sim uma INTERFACE.

        using BookStore.Domain;
        using System;
        using System.Collections.Generic;

        namespace BookStore.Repositories.Contracts
        {
            // 1. Identificação que o objeto é uma interface
            // 2. IDisposable - Para implementar os métodos de inicialização e finalização, para criar as conexões e destruição da 
            //                  conexão com o banco.
            public interface IAuthorRepository: IDisposable
            {
                List<Autor> Get();

                Autor Get( int id);

                List<Autor> GetByName( string name );

                bool Create( Autor autor);

                bool Update( Autor autor);

                void Delete( int id );
            }
        }

    . Clique com o botão direito sobre a pasta "Repository", "Add/New Class" e dê o nome de "AuthorRepository.cs".

    . Dentro da classe AuthorRepository insira o código abaixo.

        using BookStore.Doamain;
        using BookStore.Repositories.Contracts;
        using Sytem.Collections.Generic;

        using BookStore.Context;
        using BookStore.Domain;
        using BookStore.Repositories.Contracts;
        using System;
        using System.Linq;
        using System.Collections.Generic;
        using System.Data.Entity;

        namespace BookStore.Repositories
        {
            public class AuthorRepository: IAuthorRepository
            {

                private BookStoreDataContext _db = new BookStoreDataContext();

                public List<Autor> Get()
                {
                    return _db.Autores.ToList();   
                }

                public Autor Get( int id)
                {
                    return _db.Autores.Find(id);
                    
                }


                public List<Autor> GetByName( string name )
                {
                    return _db.Autores.Where( x => x.Nome.Contains( name ) ).ToList();
                }


                public bool Create( Autor autor)
                {
                    try
                    {
                        _db.Autores.Add( autor );
                        _db.SaveChanges();

                        return true;
                    }
                    catch
                    {
                        return false;
                    }
                }


                public bool Update( Autor autor)
                {
                    try
                    {
                        _db.Entry<Autor>(autor).State = EntityState.Modified;
                        _db.SaveChanges();

                        return true;
                    }
                    catch
                    {
                        return false;
                    }
                    
                }


                public void Delete( int id )
                {
                    var autor = _db.Autores.Find(id);

                    _db.Autores.Remove( autor );
                    _db.SaveChanges();
                }

                public void Dispose()
                {
                    _db.Dispose();
                }

            }
        }

    . Acesse a classe AuthorController e implemente as linhas abaixo:

        ...
        namespace BookStore.Controllers
        {
            [RoutePrefix("autores")]
            public class AuthorController: Controller
            {
                private IAuthorRepository repository;       // Incluido

                public AuthorController(){
                    repository = new AuthorRepository();    // Incluido
                }

                [Route("listar")]
                public ActionResult Index()
                {
                    var autores = respository.Get();    // Incluido

                    return View(autores);               // Alterado
                }

                [Route("criar")]
                public ActionResult Create()
                {
                    return View();
                }

                                                        /* Método novo */
                [Route("criar")]
                [HttpPost]                              // Incluido
                public ActionResult Create(Autor autor) // Alterado
                {
                    if (repository.Create(autor))          // Incluido
                        return RedirectToAction("Index");   // Incluido

                    return View(autor);                 // Alterado
                }

                [Route("editar/{id:int}")]
                public ActionResult Edit(int id)
                {
                    var autor = repository.Get(id);     // Incluido

                    return View(autor);
                }

                                                        /* Método criado */
                [Route("editar/{id:int}")]
                [HttpPost]
                public ActionResult Edit(Autor autor)
                {
                    if (repository.Update(autor))          // Incluido
                        return RedirectToAction("Index");   // Incluido

                    return View(autor);                 // Alterado
                }

                [Route("excluir/{id:int}")]
                public ActionResult Delete(int id)
                {
                    var autor = repository.Get(id);     // Incluido
                    
                    return View(autor);
                }

                                                        /* Método criado */
                [Route("excluir/{id:int}")]
                [HttpPost]
                [ActionName("Delete")]
                public ActionResult DeletConfirme(int id)
                {
                    repository.Delete(id);

                    return RedirectToAction("Index");
                }

            }
        }


Aula 9. Definindo os contratos dos repositórios (Desafio Criar repositorio para Livro e Categoria)
--------------------------------------------------------------------------------------------------


Aula 10. Injetando os repositórios no controller
-----------------------------------------------

    . Sobre injeção de dependência

        . Em inglês. Dependecy Injection ou DI

        . é mais simples do que você imagina

        . Você tem uma class A, que para funcionar, depende da classe B

        . Esta classe B depende da classe C e assim port diante.

        . Neste momento, você tem um problema... Como resolver todas estas dependências?

    . Sua classe sempre deve depender de um cotrato da qual sua dependência possui.

    . Sendo assim, proque não...

        1. Ter um local onde dado um contrato, é retornada a instância da classe.

        2. Resolve as dependências em cascata, de form automática.

    . Unity

        . A Microsoft tem isto pronto em um pacote chamado Unity.

        . Basta instalar e criar um "container" que ficará responsável por resolver as dependências.

        . Feito isto, basta inicializar seu container sempre que sua aplicação iniciar.

    . Repopsitórios nos controlllers

        . A regra para uso dos repositórios nos controllers é a mesma...

            . Dependemos da interface e não da implementação.

        . Feito isto, temos os controllers desacoplados da fonte de dados.

    . Acesse a classe AuthoRepository para deixar o objeto BookStoreDataContext com Injeção de dependência.

        ...
        private BookStoreDataContext _db;       // Eliminado a instanciação do objeto.

        public AuthorRepository( BookStoreDataContext context)      // Incluido o construtor
        {
            _db = context;
        }

    . Acesse o componente AuthorController e proceda as alterações abaixo:

        ... 
        private IAuthorRepository _repository   // Mudança do nome 

        public AuthorController( IAuthorRepository _repository ){   // Alterado a assinatura do construtor
            _repository = new AuthorRepository();                   // Modificado o nome do componente.
        }

        public AuthorController(IAuthorRepository repository)   // Alterado a assinatura do construtor
        {
            _repository = repository;                           // Eliminado a instanciação e inserido no lugar o objeto da assinatura
        }


        // Alterar o nome do ojeto repository por _repository nos métodos abaixo

        ...

    . Acesse o Package Manager e execute o código abaixo:

        Install-Package Unity.Mvc5

    . Dentro da pasta "App_Start" acesse o arquivo "UnityConfig.cs" e inclua a linha abaixo:

        container.RegisterType<IAuthorRepository, AuthorRepository>();
        container.RegisterType<BokStoreDataContext, BookStoreDataContext>();

    . Acesse o arquivo Globa.asax.cs e insira o código abaixo:

        ... 
        protected void Application_Star()
        {
            ...
            UnityConfig.RegisterComponents()
        }


    . Execute o projeto, cuidado porque na video aula deu problema na classe de log, comente o código desta classe.



Aula 11. Razor View Engine
--------------------------

    . Aulas 11, 12, 13 e 14

        . Razor View Engine

        . Entendendo o @Html

        . Criando funçoes com Razor Helper

        . Trabalhando com PartialViews

    . View Engines

        . São mecanismos para interagir com funções C# no HTML

        . Fornecem recursos adiocionais ao HTML

        . O mais famoso é o Razor

        . São identificados por partes diferentes no HTML:

            <a href="@url.action('index', 'home')">Voltar</a>


    . Razor View Engine

        . É o mecanismo mais utilizado no desenvolvimento ASP.NET MVC.

        . Poderoso

        . Incorpora muitas funções do C# como:

            . if, while, for, foreach

            . Podemos criar funções próprias

            . @Html e @Url (Helpers)

            . Podemos cria nossos próprios helpers.


Aula 12. Enendendo o @Html
--------------------------

    . Sobre o Helper @Html

        . São utilitários para construção de componentes do HTML

        . No final gera um código Html mesmo

        . Podem ser criados sem referência de uma propriedade.

            @Html.Display("Name")

        . Ou referenciando uma propriedade:

            @Html.DisplayFor( x => x.Name )

    . Os principais Helpers são:

        . Formulários

            . @Html.BeginForm

        . Componentes

            . Editor

            . TextArea

            . Label

            . Display

            . CheckBox

            . DropDownList

    . Dê clique direito sobre a pasta Controllers e escolha "Add/New Controller", selecione um "Empty Controller" e dê o nome de "LivroController"

    . Insira o código abaixo na classe recém criada:

        ...
        namespace BookStore.Controllers
        {
            [RoutePrefix("livro")]
            public class LivroController: Controller
            {
                [Route("criar")]
                public ActionResult Create()
                {
                    return View();
                }

            }
        }


    . Clique com o botão direito do mouse sobre o nome do método "Create" e escolha "Add View".

    . Execute o projeto e no navegador execute a url abaixo:

        http://localhost:[porta]/livro/criar

    . Dê clique direito sobre a pasta "ViewModules" e escolha "Add/New Class" e dê o nome de "CreateBookViewModel"

    . Insira o código abaixo na classe recém criada:

        ...
        namespace BookStore.ViewModels
        {
            public class CreateBookViewModel
            {
                [Required( ErrorMessage="*")]
                public string Nome { get; set; }

                [Required( ErrorMessage="*")]
                public string ISBN { get; set; }

                [Required( ErrorMessage="*")]
                public DateTime DataLancamento { get; set; }

                [Required( ErrorMessage="*")]
                public int CategoriaId { get; set; }


            }
        }

    . Execute o projeto e no navegador execute a url abaixo:

        http://localhost:[porta]/livro/criar

    
    . Acesse a view "Create.cshtml" e implemente o código abaixo:

        @{
            ViewBag.Title = "Criando um novo livro..."
        }

        <h2>Novo Livro</h2>

        <form>
            <div class="form-group">
                <label for="nome">Nome</label>
                <input type="text" class="form-control" id="nome" placeholder="Nome">
            </div>

            <button type="submit" class="btn btn-default">Submit</button>
        </form>

    . Acesse o componente LivroController e implemente o método abaixo:

        ...
        [Route("criar")]
        [HttpPost]
        public ActionResult Create( CreateBookViewModel model )
        {
            return View();
        }


    . Execute o projeto e no navegador execute a url abaixo:

        http://localhost:[porta]/livro/criar


    . Na view "Create.cshtml" substitua a tag label pelo código abaixo:

        @model BookStore.ViewModels.CreateBookViewModel

        <form>
            <div class="form-group">

                <!-- Substituido 

                <label for="nome">Nome</label>

                -->

                @Html.LabelFor(model => model.Nome )
                <input type="text" class="form-control" id="nome" placeholder="Nome">
            </div>

            <button type="submit" class="btn btn-default">Submit</button>
        </form>

        @section Scripts { 
            @Scripts.Render("~/bundles/jqueryval")
        }

    . Execute o projeto, no navegador execute a url abaixo e verifique se o conteúdo @Html.LabelFor foi criado com sucesso.

        http://localhost:[porta]/livro/criar

    . Acesse o componente "CreateBookViewModel" e insira o decorator abaixo na propriedade "Nome"

        ..
        public class CreateBookViewModel
            {
                [Required( ErrorMessage="*")]
                [Display("Nome do Livro")]
                public string Nome { get; set; }
                
                ...

    . Execute o projeto, no navegador execute a url abaixo e verifique se o conteúdo do decorator [Display( Name = "Nome do Livro")] foi 
        renderizado com sucesso.

        http://localhost:[porta]/livro/criar

    . Na view "Create.cshtml" substitua a tag "email" pelo código abaixo:

        <form>
            <div class="form-group">

                <!-- Substituido 

                <label for="nome">NOme</label>

                -->

                @Html.LabelFor(model => model.Nome )

                <!-- Substituido 

                <input type="text" class="form-control" id="nome" placeholder="Nome">

                -->

                @Html.EditorFor(model => model.Nome, new { htmlAttributes = new { @class = "form-control", placeholder="Nome" } })
            </div>

            <button type="submit" class="btn btn-default">Submit</button>
        </form>

        @section Scripts { 
            @Scripts.Render("~/bundles/jqueryval")
        }

    . Execute o projeto, no navegador execute a url abaixo e verifique se o conteúdo do @Html.EditorFor foi renderizado com sucesso.

        http://localhost:[porta]/livro/criar

    . Acesse a view "Create.cshtml" e insira o código abaixo:

        ...
        <form>
            <div class="form-group">
                ...

                <!-- Código inserido -->

                @Html.LabelFor(model => model.ISBN )
                @Html.EditorFor(model => model.ISBN, new { htmlAttributes = new { @class = "form-control", placeholder = "ISBN" } })
            </div>

            <div class="form-group">
                @Html.LabelFor(model => model.DataLancamento )
                @Html.EditorFor(model => model.DataLancamento, new { htmlAttributes = new { @class = "form-control" } })
            </div>
        </form>

        @section Scripts { 
            @Scripts.Render("~/bundles/jqueryval")
        }

    . Acesse o componente "CreateBookViewModel" e insira o decorator abaixo na propriedade "DataLancamento"

        ..
        public class CreateBookViewModel
            {
                [Required( ErrorMessage="*")]
                [Display( Name= "Data de Lançamento" )]
                [DataType( DataType.Date)]
                public DateTime DataLancamento { get; set; }
                
                ...

        . O decorator [DataType( DataType.Date)] além de outras coisas faz com que a mascara da data (dd/mm/yyyy) seja colocada automaticamente no campo
            da view.

    . Execute o projeto, no navegador execute a url abaixo e verifique se o conteúdo do @Html.EditorFor foi renderizado com sucesso.

        http://localhost:[porta]/livro/criar


    . Acesse o componente "CreateBookViewModel" e insira o código abaixo:

        public SelectList CategoriaOptions { get; set; }

    . Acesse o componente LivroController e insira o código abaixo:

        ...
        namespace BookStore.Controllers
        {
            BookStoreDataContext _db = new BookStoreDataContext();  // Linha inserida.

            [RoutePrefix("livro")]
            public class LivroController: Controller
            {
                [Route("criar")]
                public ActionResult Create()
                {
                    var categorias = _db.Categorias.ToList();       // Linha inserida

                    var model = new CreateBookViewModel             // Linhas inseridas
                    {
                        Nome = "",
                        ISBN = "",
                        CategoriaId = 0,
                        CategoriaOptions = new SelectList( categorias, "Id", "Nome" )
                    };

                    return View( model );
                }

                ...
            }
        }

    . Acesse a view "Create.cshtml" e insira o código abaixo:

        ...
        balta<form>
            <div class="form-group">
                ...
                @Html.LabelFor( model => model.CategoriaId )
                @Html.DropDownListFor( m => m.CategoriaId,
                                        Model.CategoriaOptions,
                                        "Selecione uma opção...",
                                        new {  @class = "form-control" } )

    . Acesse o SQLServer e insira algumas categorias.

    . Execute o projeto, no navegador execute a url abaixo e verifique se o conteúdo do @Html.DropDownListFor foi renderizado com sucesso.

        http://localhost:[porta]/livro/criar



Aula 13. Criando funções com Razor Helper
-----------------------------------------

    . Razor Helper

        . É possível criar funções no razor

        . É interessante deixar estas funções no topo do arquivo

        . Feita a função, basta invocá-la, coo um método qualquer.


    . Acesse a view "Create.cshtml" e insira o código abaixo:

        @model BookStore.ViewModels.CreateBookViewModel

        @{
            ViewBag.Title = "Criando um novo livro...
        }

        @helper MinhaFuncao( string nome ){     // Linhas inseridas
            <text>O nome informado é @nome</text>
        }

        ...

        <form>
            ...
        </form>

        <p>
            @MinhaFuncao("Marco")
        </p>

        @section Scripts { 
            @Scripts.Render("~/bundles/jqueryval")
        }


Aula 14. Trabalhando com PartialViews
--------------------------------------        

    . Partial Views

        . São pedaços de uma view

        . Podem ser retornadas do controller

        . Pode ser chamadas a partir de outra view ou partial view.

    . Acesse a classe CreateBookViewModel e renomei a classe

        ...                                 // Mudança do nome de CreateBookViewModel para EditorBookViewMOdel
        public class EditorBookViewModel    // Dê Ctrl + . para fazer o rename em todo o projeto
        {
            public int Id { get; set; }     // Linha incluida
            ...                            
        }
        ...

        . Acesse a arquivo da solution, encontre o arquivo CreateBookViewModel e dê o rename para "EditorBookViewModel"

    . Acesse a pasta "Views/Livro" e crie um folder com o nome "Partials".

    . Na pasta recém criada dê um "Add/New view" e dê o nome de "EditorBookPartial" (Marque ele como PartialView).

    . Na PartialView recém criada insira o código abaixo:

        @model BookStore.ViewModels.EditorBookViewModel

        <div class="form-group">
            @Html.LabelFor(model => model.Nome)
            @Html.EditorFor(model => model.Nome, new { htmlAttributes = new { @class = "form-control", placeholder="Nome" } })
        </div>

        <div class="form-group">
            @Html.LabelFor(model => model.ISBN)
            @Html.EditorFor(model => model.ISBN, new { htmlAttributes = new { @class = "form-control", placeholder="ISBN" } })
        </div>

        <div class="form-group">
            @Html.LabelFor(model => model.DataLancamento)
            @Html.EditorFor(model => model.DataLancamento, new { htmlAttributes = new { @class = "form-control", placeholder="Data Lançamento" } })
        </div>

        <div class="form-group">
            @Html.LabelFor(model => model.CategoriaId)
            @Html.DropDownListFor(m => m.CategoriaId,
                                            Model.CategoriaOptions,
                                            "Selecione uma opção...",
                                            new { @class = "form-control" })
        </div>


    . Acesse a view Views/Livro/Create.cshtml e substitua todo o conteúdo da tag <form> pelo conteúdo abaixo:

        @model BookStore.ViewModels.EditorBookViewModel

        @{
            ViewBag.Title = "Criando um novo livro..."
        }

        @helper.MinhaFuncao(string nome)
        {
            <text>O nome informado é @nome</text>
        }

        <p>
            @MinhaFuncao("Marco")
        </p>

        <h2>Novo Livro</h2>

<!--         <form> -->
        @using (Html.BeginForm())
        {
            @Html.Partial("Partials/EditorBookPartial", Model)

            <button type="submit" class="btn btn-default">Criar</button>
        }
<!--        </form> -->

        @section Scripts { 
            @Scripts.Render("~/bundles/jqueryval")
        }
    
    . Execute o projeto e verifique se a renderização da página continua funcionando corretamente:

        localhost:[porta]/livros/criar

    . Clique com o botão direito sobre a pasta "Views/Livro", dê um "Add/New View...", renomei a view para "Edit", desmarque o item "Create a partial view"

    . Implemente o código abaixo na view recém criada.

        @model BookStore.ViewModels.EditorBookViewModel

        @{
            ViewBag.Title = "Editando um novo livro...";
        }

        <h2>Novo Livro</h2>

        @using (Html.BeginForm())
        {
            @Html.HiddenFor(model => model.Id)
            @Html.Partial("Partials/EditorBookPartial", Model)

            <button type="submit" class="btn btn-default">Salvar</button>
        }

        @section Scripts {
            @Scripts.Render("~/bundles/jqueryval")
        }

    . Acesse o componente "LivroController" e insira os métodos abaixo:

        [Route("listar")]
        public ActionResult Index()
        {
            return View( _db.Livros.ToList());
        }



        [Route("editar")]
        public ActionResult Edit( int id)
        {
            var categorias = _db.Categorias.ToList();

            var livro = _db.Livro.Find(id);

            var model = new EditorBookViewModel
            {
                Nome = livro.Nome,
                ISBN = livro.ISBN,
                CategoriaId = livro.CategoriaId,
                CategoriaOptions = new SelectList( categorias, "Id", "Nome")
            };

            return View(model);
        }

    . Clique o botão direito sobre o nome do método "Index", dê "Add new View" e informe os seguintes parâmetros na próxima tela:
    
        "View name: "Index"
        "Template": "List"
        "Model Class": "Livro (BookStore.Domain)"

    . Acesse o componente LivroController e altere o método abaixo. ATENÇÃO: pegue o método com a assinatura abaixo:

        ...
        [Route("criar")]
        [HttpPost]
        public ActionResult Create( CreateBookViewModel model )
        {
            var livro = new Livro();

            livro.Nome = model.Nome;
            livro.ISBN = model.ISBN;
            livro.DataLancamento = model.DataLancamento;
            livro.CategoriaId = model.CategoriaId;

            _db.Livros.Add( livro );
            _db.SaveChanges();

//            return View();

            return RedirectToAction("Index");
        }
    
    . Acesse o componente "LivroController" e insira os métodos abaixo:

        [Route("editar")]
        [HttpPost]
        public ActionResult Edit(EditorBookViewModel model)
        {
            Livro livro = _db.Livros.Find(model.Id);

            livro.Nome = model.Nome;
            livro.ISBN = model.ISBN;
            livro.DataLancamento = model.DataLancamento;
            livro.CategoriaId = model.CategoriaId;

            _db.Entry<Livro>(livro).State = System.Data.Entity.EntityState.Modified;
            _db.SaveChanges();

            return RedirectToAction("Index");
        }

    . Execute o projeto e teste o create e o edit:

        localhost:[porta]/livro/listar


    . Acesse a view Index.cshtml do controller "LivroController", retire o conteúdo da tag "<table class="table">", mantenha esse conteúdo
        para copiá-lo numa outra "PartialView".

        @model IEnumarable<BookStore.Domain.Livro>

        @{
            ViewBag.Title = "Index";
        }

        <h2>Index</h2>

        <p>
            @Html.ActionLink("Create New", "Create")
        </p>

    . Clique com o botão direito sobre a pasta "Livro/Partials", dê um "Add/New View" e informe os seguintes parâmetros:

        "View Name": "ListBookPartial"
        "Template": "Empty (without model)"
        "Create a Partial view": True

    . Quando abrir a view, cole o conteúdo copiado da view anterior.
    
    . Altere o model do Edit.cshtml como abaixo:

        @model BookStore.ViewModels.EditorBookViewModel

    . Na view Index.cshtml coloque na última linha o código abaixo:

        @Html.Partial("Partials/LIstBookPartial", Model)



Aula 15. Entendendo o _Layout e Layouts Master
----------------------------------------------

    . Layout Master

        . Entendendo o _Layout e Layouts Master

        . Trabalhando com sections

    . _Layout

        . Funciona como o slide mestre do power point

        . Você define um padrão que será utilizado por toda a aplicação.

        . Toda a página permance, mudando apensas o "miolo"

        . A regição que irá mudar é identificada pelo @Renderbody()

        . Podemos ter vários layouts

            . Um para login

            . Um para setor administrativo

            . Um para a loja.

    . Acessando a pasta "Views/Shared" encontramos o arquivo _Layout.cshtml.

        . Ele possui um menu. Acrescente um um item no menu como abaixo:

            <div class="navbar navbar-inverse navbar-fixed-top">
                <div class="container">
                    <div class="navbar-header">
                        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </button>
                        @Html.ActionLink("Application name", "Index", "Home", new { area = "" }, new { @class = "navbar-brand" })
                    </div>
                    <div class="navbar-collapse collapse">
                        <ul class="nav navbar-nav">
                            <li>@Html.ActionLink("Home", "Index", "Home")</li>

                            <!-- Acrescente a linha abaixo, onde o método ActionLink recebe três parâmetros (Nome no menu, Action e o controller ) -->
                            <li>@Html.ActionLink("Livros", "Index", "Livro")</li>

                            <li>@Html.ActionLink("About", "About", "Home")</li>
                            <li>@Html.ActionLink("Contact", "Contact", "Home")</li>
                        </ul>
                    </div>
                </div>
            </div>

        . Ele possui o miolo da página:

            <div class="container body-content">
                @RenderBody()
                <hr />
                <footer>
                    <p>&copy; @DateTime.Now.Year - My ASP.NET Application</p>
                </footer>
            </div>

            . O @RenderBody() é o responsável pela montagem da página.

    . Clique com o botão direito sobre a pasta "Views/Shared", acione "Add/View" e na tela que aparecer insira os parâmetros abaixo:

        View Name: _LayoutNovo,
        TEmplate: Empty (without model),
        Create as a partial view: False,
        Use a layout page: False

    . Na view criada insira o código abaixo:

        <!DOCTYPE html>

        <html>
        <head>
            <meta name="viewport" content="width=devide-width" />
            <title>_LayoutNOvo</title>

            <!-- Site de templates para o Bootstrap https://bootswatch.com/help/ -->
            <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" 
                    rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" 
                    crossorigin="anonymous">

        </head>

        <body>
            <div class="col-md-4">
                <h3<Menu</div>
        
                @RenderSection("menu", false)

            </div>
            <div class="container well col-md-4">
                @RenderSection("menu", true)
            </div>
        </body>
        </html>

        . O decorate  @RenderSection("menu", false) quando é informado o último parâmetro como "false" se caso não houver a seção do 
            primeiro parâmetro "menu" deixa de ser obrigatório. Caso fique como "true" e não existir essa section em algum lugar dará erro.


    . Acesse a view "Views/Livro/Index.cshtml" e acrescente a linha abaixo:

        @model IEnumerable<BookStore.Domain.Livro>

        @{
            ViewBag.Title = "Index";
            Layout = "~/Views/Shared/_LayoutNovo.cshtml";                // Linha incluida 
        }

        ...

        . Detalhe, na pasta "Views" existe um arquivo como nome _ViewStart.cshtml. Nele podemos definir o layout padrão para todas as páginas do projeto.
            Se quisermos deixar isso individual, basta na view desejada configurar o layout como acima.

    . Acesse o navegador e execute a URL abaixo:

        localhost:[porta]/livros/listar

    . Acesse a view "Views/Livro/Index.cshtml" e acrescente as linhas no final da dela como abaixo:

        ...
        @section menu{
            <div>
                Olá vc está na página principal
            </div>
        }

    . Acesse a view "Views/Livro/Create.cshtml" e acrescente as linhas no final da dela como abaixo:


        @model IEnumerable<BookStore.ViewModels.EditorBookViewModel>

        @{
            ViewBag.Title = "Criando um novo livro...";
            Layout = "~/Views/Shared/_LayoutNovo.cshtml";                // Linha incluida 
        }

        ...
        @section menu{
            <div>
                Olá vc está na página criação
                <p>
                    <a href="@Url.Action("Index")">Voltar</a>
                </p>
            </div>
        }

        @section Scripts{
            @Scripts.Render("~/bundles/jqueryval")
        }

    . Acesse o navegador e execute a URL abaixo:

        localhost:[porta]/livros/listar
        localhost:[porta]/livros/criar

    . Uma configuração possível no layout:

        . Acesse o _LayoutNovo.cshtml e coloque a redenrização do menu dentro de um "@if" como abaixo:

            ...
            <body>
                @if (IsSectionDefined("menu"))
                {
                    <div class="col-md-4">
                        <h3>Menu</h3>
                        @RenderSection("menu", false)   // Alterado para false
                    </div>
                }

                <div class="container well">            <!-- Foi retirado a class  col-md-8 -->
                    @RenderBody()
                </div>
...

        . Acesse a view "Views/Livro/Index.cshtml" e retire o "@section menu" para deixar opcional a renderização acima.

        . Acesse o navegador e execute a URL abaixo:

            // Deixou de aparecer o menu
            localhost:[porta]/livros/listar

            // Continua aparecendo
            localhost:[porta]/livros/criar


Aula 16. Trabalhando com Sections
---------------------------------

    . Sections

        . São espaços reservados nos layouts

        . Podemos definir uma section em qualquer lugar do layout

        . Podemos renderizar qualquer contuéudo em uma section.


Aula 17. Entendendo o ValidationMessage
---------------------------------------

    . O ASP.NET MVC possui um mecanismo de envio de mensagens de erro para tela.

    . Isto é chamado de modelState.

    . Ele serve tanto para saber se podemos prosseguir na execução de um código 

        . Caso o modelState seja válido, está tudo ok.

    . Qaunto para enviar alguma mensagem customizada para tela.

    . Está estritamente ligado com o metadados gerado pelos dataAnnotations

    . JQuery validation auxilia na geração de erros no cliente

    . Evita ficar postando apágina para receber os erros (é assíncrono)

    . Se baseia nos metadados gerados pelos dataAnnotation para criação de validações no cliente.


    . ValidationMessages

        . São as famosas mensagens de erro

        . Pode ser utilizada assincronamente

            . Dependem do JQuery validation

        . Pode ser aplicadas diretamente nos campos ou sumarizada

        . Podem ser genéricas

            . @html.validationmessagefor( x => x.name)

        . Cappturam os erros do modelstate.

    . Acesse o arquivo "Views/Livro/Index.cshtml" e comente a linha do do "Layout" como abaixo:

        @model IEnumerable<BookStore.Domain.Livro>

        @{
            ViewBag.Title = "Index";
            // Layout = "~/Views/Shared/_LayoutNovo.cshtml";                // Linha incluida 
        }

        ...

    . Acesse o arquivo "Views/Livro/Create.cshtml" e comente a linha do do "Layout" como abaixo:

        @model IEnumerable<BookStore.ViewModels.EditorBookViewModel>

        @{
            ViewBag.Title = "Criando um novo livro...";
            // Layout = "~/Views/Shared/_LayoutNovo.cshtml";                // Linha incluida 
        }

        ...


        . Remova a section menu

            @*
            ...
            @section menu{
                <div>
                    Olá vc está na página criação
                    <p>
                        <a href="@Utl.Action("Index")">Voltar</a>
                    </p>
                </div>
            }
            ...
            *@
        
    . Execute a URL abaixo:

        localhost:[porta]/livros/criar

    . Acesse o arquivo "Views/Livro/Create.cshtml" e implemente a linha de código abaixo:

        ...
        @using (Html.BeginForm())
        {
            @Html.ValidationSummary( true, "", new { htmlAttributes = new { @class = "text-danger" } } )  // Linha Inserida

            <div class="alert alert-danger">                // Linha inserida
                @Html.ValidationMessage("Mensagem")         // Linha inserida
            </div>                                          // Linha inserida

            @Html.Partial("Partials/EditorBookPartial", Model)
        }
        ...

        . O primeiro parâmetro do ValidationSummary indica se as msgs serão exibidas nos próprios campos, ou se haverá 
            uma área especifica para isso.
    
    . Acesse o componente LivroController e implemente as linhas de código abaixo:

        ...
        [Route("criar")]
        public ActionResult Create()
        {
            ModelState.AddModelError("Mensagem", "Algum erro ocorreu");     // Linha inserida

            var categorias = _db.Categorias.ToList();
            ...
        }
        ...

    . Execute a URL abaixo:

        localhost:[porta]/livros/criar

    . Acesse o arquivo "Views/Livro/Create.cshtml" e altere o parâmetro do ValidationSummary para "false"

        ...
        @using (Html.BeginForm())
        {
            @Html.ValidationSummary( true, "", new { htmlAttributes = new { @class = "text-danger" } } )  // Linha Alterada
        ...

        . Com o false, os erros ficaram em lista.

    . Execute a URL abaixo:

        localhost:[porta]/livros/criar


    . Acesse o componente LivroController e elimine o ModelState

        ...
        [Route("criar")]
        public ActionResult Create()
        {
            // ModelState.AddModelError("Mensagem", "Algum erro ocorreu");     // Linha apagada

            var categorias = _db.Categorias.ToList();
            ...
        }
        ...

    . Acesse o método LivroController.Create( EditorBookViewModel ) e implemente as linhas abaixo:

        [Route("criar")]
        [HttpPost]
        public ActionResult Create( EditorBookViewModel model)
        {
            if (!ModelState.IsValid)
            {

                var categorias = _db.Categorias.ToList();
                model.CategoriaOptions = new SelectList(categorias, "Id", "Nome");

                return View(model);
            };

            ...

            try
            {
                throw new Exception("Falha no banco"); // ATENÇÃO, está linha é somente para testar o catch abaixo. Depois ela tem que sair.

                _db.SaveChanges();
            }
            catch (Exception ex)
            {
                ModelState.AddModelError("Mensagem", ex.Message);

                var categorias = _db.Categorias.ToList();
                model.CategoriaOptions = new SelectList(categorias, "Id", "Nome");

                return View(model);
            }
            ....

    . Execute a URL abaixo:

        localhost:[porta]/livros/criar

        . Entre com um novo livro e verifique o comportamento.


    . Altere os decorate de validação do componente "EditorBookViewModel", retirando os "*" dos validadores e colocando uma descrição de erro condizente.



Aula 18. Criando Validações customizadas.
-----------------------------------------

    . Quando o padrão não atende

        . Em alguns casos, as validações padrões não vão te atender.

        . É possível criar validações (escritas em C#) e utiliza-las para decorar uma propriedade.

        , Feito isto, automaticamente será adicionada a validação no lado do servidor.

        . Ainda é possível realizar esta operação assíncrona, mapeando a valiação com o JQuery Validation.

    . Clique com o botão direito sobre o projeto "BookStore", dê um "Add/New Class" e dê o nome "CheckAgeValidator".

    . Implemente o código abaixo na classe recém criada:


        using System;
        using System.ComponentModel.Validators;

        namespace BookStore.Validators
        {

            public class CheckAgeValidator: ValidationAttribuite
            {
                protected override ValidationResult IsValid( object value, ValidationContext validateionContext )
                {
                    DateTime date = (DateTime)value;

                    if ((date.Year - 18) > 0 )
                        return new ValidateionResult("Somente maiores de 18 anos");

                    return ValidationResult.Success;
                }
            }
        }

    . Acesse o componente "EditorBookViewModel.cs" e implemente o método abaixo:

        ...
        namespace BookStore.ViewModels
        {
            public class EditorBookViewModel
            {
                ...

                [CheckAgeValidator]
                public DateTime Age { get; set; }
                ...
            }
        }

    . Acesse o componente "EditorBookPartial.cshtml" e implemente as linhas abaixo:

        ...

        <div class="form-group">
            @Html.EdirotFor( x => x.Age)                
            @Html.ValidatinMessageFor( x => x.Age)     
        </div>

    . Acesse a URL abaixo para fazer o teste:

        localhost:[porta]/livros/criar


Aula 18. Trabalhado com Bundle
------------------------------

    . Emapacotar para otimizar

        . O browser suporta apensa seis requisições concorrentes.

        . Bundle nada mais é do que compilar vários arquivos em apensa um.

        . Se ao invés de fazer 18 requisições para arquivos javascript, fizermos apensa um para um arquivo maior, ela será otimizada.

        . Funciona como a cópia de arquivos no windows.

    . Acesse o arquivo "App_Start/BundleConfig.cs".

    . Dentro do "BundleConfig.cs" ocorre o registro de vários arquivo "*.js, *.css" para a aplicaçãop, como o exemplo abaixo:

        ...
        public static void RegisterBundles(BundleCollection bundles)
        {
            bundles.Add(new ScriptBundle("~/bundles/jquery").Include(
                        "~/Scripts/jquery-{version}.js"));

            bundles.Add(new ScriptBundle("~/bundles/jqueryval").Include(
                        "~/Scripts/jquery.validate*"));

            bundles.Add(new ScriptBundle("~/bundles/modernizr").Include(
                        "~/Scripts/modernizr-*"));

            bundles.Add(new ScriptBundle("~/bundles/bootstrap").Include(
                      "~/Scripts/bootstrap.js",
                      "~/Scripts/respond.js"));

            bundles.Add(new StyleBundle("~/Content/css").Include(
                      "~/Content/bootstrap.css",
                      "~/Content/site.css"));
        }
        ...

        . Observe os coringas "*-{version}" e "*" no parâmetro do método ".include". Em algum lugar podemos definiar a versão que queremos desses arquivos.

    . Ao invés de colocarmos nos arquivos de layouts (_Layout.cshtml, _LayoutNovo.cshtml) a especificação desses arquivos "*.js", podemos fazer isso diretamente
        no BundleConfig.cs.

    . No _Layout.cshtml temos:

        ...
        <head>
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>@ViewBag.Title - My ASP.NET Application</title>
            @Styles.Render("~/Content/css")
            @Scripts.Render("~/bundles/modernizr")
        </head>
        ...

        . Observe o @Style.Render e o @Scripts.Render, eles fazem relação como o que foi registrado pelo Bundle para fazer uso destes arquivos.

    . A lógica seria a seguinte:

        . Primeiro faz o registro do pacote no bundle, com o nome do pacote "~/Content/css" e o include dos arquivo "include("~/Content/bootstrap.css")"

            bundles.Add(new StyleBundle("~/Content/css").Include(
                      "~/Content/bootstrap.css",
                      "~/Content/site.css"));

        . Nas páginas de layout fazemos a inserção, renderiza os arquivos associado ao bundle registrado:

            ...
            <html>
            <head>
                <meta charset="utf-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>@ViewBag.Title - My ASP.NET Application</title>
                @Styles.Render("~/Content/css")
                @Scripts.Render("~/bundles/modernizr")
            </head>
            ...
            <body>
                ...
                @Scripts.Render("~/bundles/jquery")
                @Scripts.Render("~/bundles/bootstrap")
                @RenderSection("scripts", required: false)
            </body>
            </html>


Aula 19. Trabalhando com Minification
--------------------------------------

    . Minificação:

        . O browser não precisa de quebra de linha, espaços extras e comentários

        . Ele se baseia no ";" para isto

        . Toda a identação do código é apenas para o humano ver melhor

        . Se pudéssemos retirar todos estes espaços, salvaríamos vários KBS.


Aula 20. Introdução ao Identity
-------------------------------

    . O que é o Identity?

        . Uma plataforma completa de autenticação/Autorização
        
        . Simples, leve e extensível

        . Uma evolução do Membership

        . Provê acesso via usuários e perfis.

        . Pode ser utilizado tanto com ASP.NET MVC quanto Web Forms.

        . Prove o controle sobre o esquema de usuários e perfis.

        . Utiliza Entity Framework para persistir os dados no banco.

        . FAcilmente alterado para utilizar ad, ou outro método de autenticação.

        . Pode ser desacoplado, é fácil de testar 

        . Suporta autenticações eternas, como facebook e twitter

        . Utiliza Owin como base

        . Distribuido via Nuget.

Aula 21. Utilizando autenticações internas
------------------------------------------        

    . Utilizando o Identity

        . Autenticação interna serve quando você precisa do controle do usuário

        . Você será responsável por armazená-los.


    . Abra um novo projeto no Visual Studio "File/New/Project", informe como "ASP.NET Web Application", informe o nome do projeto como "IdentitySample"

    . Selecione:

        . MVC

        . Change Authetication: Individual User Accounts

    . Esse novo tipo de projeto criou novos arquivos que não vinhas trabalhando:

        Pasta App_Start

            IdentityConfig.cs
            Startup.Auth.cs

        Pasta Controller

            AccountController.cs
            ManageController.cs

        Pasta Models

            AccountViewModels.cs
            IdentityModels.cs
            ManageViewModels.cs
    
    . Execute o projeto, faça o registro de um novo usuário, login e logout

    . Acesse o arquivo "App_Start/Startup.Auth.cs". Nele é possível configurar várias formas de autenticação, basta descomentar as linhas
        com autenticação através do facebook, twitter, etc.


    . Acesse o arquivo "Web.config" e localize a tag <connectionStrigs>. Aqui é configurado a conexão de acesso ao banco de dados. Nesse tipo de projeto
        já vem configurado uma conexão "Default", porém podemos alterar de acordo com a nossa necessidade.

    . Acesse a view "Views/Home/Index.cshtml" e substitua o código dela pelo abaixo:

        @{
            ViewBag.Title = "Home Page";
        }

        <h1>
            Você está autenticado como @User.Identity.Name
        </h1>

    . Execute a URL abaixo:

        localhost:[porta]/Home/Index

    . Faça o login

    . Acesse o arqquivo "WebConfig.cs"

        . Apague de dentro da tag <connectionStrings> a tag <add name="DefaultConnection"...

        . Acrescente a tag abaixo dentro da tag <connectionStrings>

            <connectionStrings>
                <add    name="DefaultConnection"
                        connectionString="Server=.\sqlexpress;Database=idsample;User ID=sa;Password=Joao3.16"
                        providerName="System.DAta.SqlClient" />
            </connectionStrings>
             
    . Execute a URL abaixo:

        localhost:[porta]/Home/Index

    . Faça o registro de um novo login

    . Acesse o SQLServer e verifique se foi criado com sucesso o database "idsample", execute as DMLs abaixo:

        INSERT INTO AspNetRoles( id, name) VALUES( NEWID(), 'Admin')
        INSERT INTO AspNetRoles( id, name) VALUES( NEWID(), 'User')

    . Execute a URL abaixo:

        localhost:[porta]/Home/Index

    . Faça o registro de um novo login com o nome de "batman@live.com". Depois faça o login com esse novo usuário.

    . Acesse o SQLServer execute as DMLs abaixo:

        INSERT INTO AspNetUserRoles( userId, roleId ) VALUES({pegue o ID do usuário Admin}, {Role do Admin})
        INSERT INTO AspNetUserRoles( userId, roleId ) VALUES({pegue o ID do usuário User}, {Role do User})

    . Acesse o component "HomeController" e insira os decorate de "Authorize" como abaixo:

        namespace IdentitySample.Controllers
        {
            public class HomeController: Controller
            {
                [Authorize]
                public ActionResult Index()
                {
                    ...
                }

                [Authorize( Roles = "Admin, User" )]
                public ActionResult About()
                {
                    ...
                }

                [Authorize( Roles = "Admin")]
                public ActionResult Contact()
                {
                    ...
                }
            }
        }

    . Faça o login com os usuários Admin e User  e Execute a URL abaixo:

        localhost:[porta]/Home/Index

        . Verifique o comportamento dos links da página.


Aula 22. Utilizando autenticações externas
------------------------------------------

    . O identity permite utilizar autenticações já existentes, dentre elas...

        . Facebook

        . Twitter

        . Google

        . Microsoft

    . Isto é feito porque estas plataformas utilizam OAuth como base.

    . Basta acessar o arquivo Startup.Auth.cs e descomentar os vários tipos de autenticação.


TODO: Continuar daqui
Aula 23. Customizando o Identity
--------------------------------

    . Por padrão, o identity nos fornece um usuário padrão.

    . É plenamente possível alterar este usuário, adicionando ou removendo campos.

    . Acesse o arquivo "Views/Account/Register.cshtml":

        . Observe que o model dele é o IdetitySample.Models.RegisterViewModel
        
        . De um clique direito sobre o nome "RegisterViewModel" e escolha
            a opção "Go to definition".

        . Crie uma nova propriedade:

            ...
            public class RegisterViewModel
            {
                [Required]
                [Display( Name = "Name")]
                public string Name { get; set; }
                
                ...
            }

    . Retorne ao arquivo "Register.cshtml" e implemente o código abaixo:

        ...
        @Html.AntiFogeryToken()
        <h4>Create a new account.</h4>
        <hr>
        @Html.ValidationSummary( "", new { htmlAttributes = new { @class = "text-danger" } } )  

        <!-- Linhas inseridas -->

        <div class="form-group">
            @Html.LabelFor( m => m.Name, new { htmlAttributes = new { @class = "col-md-2 control-label" } } )

            <div class="col-md-10">
                @Html.TextBoxFor( m => m.Name, { htmlAttributes = new { @class = "form-control" } })
            </div>
        </div>

    . Acesse a classe "Models/IdentityModel" e insira a propriedade abaixo:

        public class ApplicationUser: IdentityUser
        {
            public string Name { get; set; }    // Linha inserida
            ...
        }



    . Acesse o arquivo "Controllers/AccountController.cs", acesse o método abaixo:

        ... 
        [HttpPost]
        [AllowAnonymous]
        [ValidateAntiForgeryToken]
        public async Task<ActionResult> Register( RegisterViewModel model)
        {
            if ( Models.Stat.IsValid)
            {
                var user = new ApplicationUser { ... }
                ...
            }
            ...
        }
        
    . Insira o parâmetro "Name" nos atributos da classe:

        var user = new ApplicationUser { Name = model.Name, ... }

    . Acesse o SQLServer e apague o database referente ao projeto identity "idsample"

    . Execute a URL abaixo e verifique se o nome apareceu com sucesso:

        localhost:[porta]/Account/Register

    . Acesse o SQLServer e verifique se foi criado o campo "Name" na tabela "AspNetUsers"




