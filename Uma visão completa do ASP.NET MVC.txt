Uma visão completa do ASP.NET MVC
---------------------------------

Fundamentos
-----------

Aula 1. Instalação
------------------

    . Como funciona a Web?

        . Para uma aplicação funcionar é necessário o conjunto abaixo:

            . HTTP - Protocolo utilizado para transferência de informações

            . REQUEST - Requisição feita ao servidor

            . RESPONSE - Resposta que o servidor ofrerece em relação a um Requisição

            . POST - Envio de informações

            . GET - Obtenção de informações

        . Os envolvidos nesse ambiente:

            . Client

                . Cliente: O Browser (Menos seguro)

                . Server: Azure, UOL, HOST, ETC. ( Mais seguro )

        . As linguagens:

            . HTML

            . CSS        

            . Javascript

            . ASP.NET

            . C#

            . Razor - Interações C# em um arquivo HTML

    
    . Sequência de eventos num ambiente ASP.NET:

        . Toda comunicação entre o Cliente e o Servidor ocorre através do protocolo HTTP.

        . O cliente faz uma Requisição (REQUEST) ao servidor, por POST ( FORM/URLENCODE ) por exemplo.

        . O servidor faz o processamento, utilizando ASP.NET, C#, RAZOR.

        . O servidor responde (RESPONSE) ao cliente (GET - HTML, CSS, JS) 

    . Padrão MVC

        . O que significa a sigla MVC:

            . Model - Classes, objetos, representação do seu BD

            . View - Html por exemplo.

            . Controllers - Interage com o model para preparar as informações para as views.

        . Normalmente usado para o desenvolvimento de interfaces de usuário que divide uma aplicação em partes (camadas/componentes) interconectadas. 
            Isto é feito para separar representações de informação internas dos modos como a informação é apresentada para e aceita pelo usuário,
            levando ao desenvolvimento paralelo de maneira eficiente.

        . Vantagens

            . Alto desacoplamento

            . Altamente testável

            . Maior organização

            . Boa divisão  de responsabilidades

    . Como funciona o ASP.NET MVC

        . Implementação do padrão MVC sobre o ASP.NET

        . Utiliza toda base do ASP.NET

            . Pipeline

            . Autenticação

            . Acesso a dados 

        . Modelo MVC dentro do ASP.NET:

            . Model - Representado pelas classes C#, exemplo: Produto.cs, Categoria.cs.

            . View - Arquivos CSHTML (RAZOR)

            . Controller
            
                . Classes que herdam de controller

                . Action - Um método do controller que executa algum código e retorna uma view

                . Route - Rotas para alcançar um controller/action via url

        . Sequência de eventos num ambiente ASP.NET MVC

            . O Cliente faz uma requisição HTTP ( HTTP Request );

            . A request passar pelas rotas (Roteamento);

            . O roteamento encontra a rota e instância o controller (Criação do controller);

            . O controller criado é feito a Autenticação/Autorização. Se o cliente não tem direito a rota é retornado uma request
                com statuscode 404.

            . De para (Model Binding). É o processo pelo qual o ASP.NET Core MVC recebe uma solicitação HTTP e "liga" partes dessa solicitação, 
                bem como outras fontes de dados, a entradas (por exemplo, parâmetros) em uma Action do controlador.  
                
                Por exemplo, vamos ver um URL simples: http://www.meusite.com/blog/posts/5

                Sabemos que esse URL está tentando recuperar a postagem do blog com o ID 5 da seção /blog do meusite.com. Mas o ASP.NET não 
                tem como saber quais são as nossas intenções e, portanto, usa a vinculação de modelo para analisar a URL. Por padrão, 
                o ASP.NET Core MVC usa a seguinte rota para mapear URLs de entrada: {controller}/{action}/{id?}
        
            . Execução da Action

            . Execução do resultado (view, file, etc).

            . Http Response.

        . Criando uma aplicação

            . Acesse o Visual Studio

            . Acesse File / New Project 

            . Na tela que abrirá escolha o "framework 4.2"; ASP.NET Web Application; informe o "Name:", "Location: " e o "Solution Name:"; 
                e pressione o botão OK.

            . Na próxima tela  de templates, escolha a opção "MVC"; Na parte de "Change Authentication", escolha "No Authentication"; 
                pressione o botão OK.

            . Ao final da criação, podemos notar que na estrutura do projeto foi criado as pastas: Models, Views e Controllers.

            . Clique com o botão direito sobre a pasta "Models", acione "Add/Class...". Dê o nome de Product.cs.

            . Na classe criada, implemente as propriedades abaixo:

                ...
                public class Product
                {
                    public int Id{ get; set; }
                    public string Title {get; set;}
                }
                ...

            . Acesse a opção "Build/Rebuild Solution"

            . Clique com o botão direito sobre a pasta "Controllers"; Escolha "Add new Controller"; Escolha a opção 
                "MVC5 Controller with views, using Entity framework"; acione o botão "Add".

            . Na tela seguinte informe os parâmetros abaixo:

                Model Class: Product
                Data Context class: "Acesse o botão de +; informe o conteúdo [Nome da aplicação].Models.AppDataContext"; Acione o "Add".

                . Pressione o botão "Add".

            . Dê um "run" na aplicação;

            . No navegador acione a url: localhost:51773/Products e testes a operações de CRUD da página.


Introdução ao ASP.NET
---------------------

Aula 2. Criando o Modelo
------------------------

    . Sobre o Model

        . É o coração do sistema

        . Também chamado de domínio.

        . Se possível de ser criado um projeto web separado

        . Quanto mais puro, melhor.

        . Cada item da sua composição pode ser chamado de entidade (produto, categoria, empregado)

    
    . Criando uma aplicação

        . Acesse o Visual Studio

        . Acesse File / New Project 

        . Na tela que abrirá escolha o "framework 4.2"; ASP.NET Web Application; informe o "Name:" como "BookStore", "Location: " e o "Solution Name:"; 
            e pressione o botão OK.

        . Na próxima tela  de templates, escolha a opção "MVC"; Na parte de "Change Authentication", escolha "No Authentication"; 
            pressione o botão OK.

        . Ao final da criação, podemos notar que na estrutura do projeto foi criado as pastas: Models, Views e Controllers.

        . Clique com o botão direito sobre a pasta "Models", acione "Add/Class...". Dê o nome de Categoria.cs.

        . Clique com o botão direito sobre a pasta "Models", acione "Add/Class...". Dê o nome de Livro.cs.

        . Clique com o botão direito sobre a pasta "Models", acione "Add/Class...". Dê o nome de Autor.cs.

        . Na classe criada, implemente as propriedades abaixo:

            ...
            public class Categoria
            {
                public int Id{ get; set; }
                public string Nome {get; set;}

                public ICollection<Livro> Livros{ get; set; }

                public Categoria()
                {
                    this.Livros = new List<Livro>();
                }
            }
            ...

            . Sempre que tiver uma collection num model faça a inicialização dela dentro do construtor.

            ...
            public class Livro
            {
                public int Id{ get; set; }
                public string Nome {get; set;}
                public string ISBN {get; set;}
                public DateTime DataLancamento {get; set;}

                public int CategoriaId { get; set; }
                public Categoria Categoria{ get; set; }

                public ICollection<Autor> Autores{ get; set; }

                public Livro()
                {
                    this.Autores = new List<Autor>();
                }

            }
            ...


            . Através do CategoriaId será feito o relacionamento com a classe Categoria.


            ...
            public class Autor
            {
                public int Id{ get; set; }
                public string Nome {get; set;}

                public ICollection<Livro> Livros { get; set; }

                public Autor()
                {
                    this.Livros = new List<Livro>();
                }


            }
            ...

            . IMPORTANTE: Quando for implementar as propriedades, se for digitado "prop" + Tab + Tab ocorre o autocomplete 

                            "public int MyProperty { get; set; }"

                          Outra forma de fazer isso seria com o comando "propfull"

                          Para realizar o autocomplete do Constructor digite "ctor"

    . Decorando as entidades

        . Uma entidade pode ser decorada (Required, stringlength, datatype)

        . Isto ger um metada que é utilizado pela view nas validações de formulários e pelo Entity Franework na geração do banco de dados.

        . Data Annotations.


    . Domínios e bancod de dados

        . Frameworks ORM abstraem nossa responsabilidade sobre o banco de dados.

        . Entity Framework é o ORM da Microsoft.

        . Instalado via NuGet
        
        . Precisa apenas de uma classe para trabalhar.


    . Decorando as entidades

        . Acesse a opção de menu "Project / Add Reference"

        . Localize a referência "System.ComponentModel.DataAnnotations"     
        
        . Acesse a classe Categoria e faça o decoration [Key] na propriedade Id que representa a chave da tabela e o [Required], 
            [StringLength] na propriedade Nome.

            ...
            public class Categoria
            {
                [Key]
                public int Id{ get; set; }

                [Required(ErrorMessage = "Campo Obrigatório")]
                [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")]
                public string Nome {get; set;}

            ...

    . Classe Livro

        using System;
        using System.Collections.Generic;
        using System.ComponentModel.DataAnnotations;    

        public class Livro
        {
            [Key]            
            public int Id{ get; set; }

            [Required(ErrorMessage = "Campo Obrigatório")]
            [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")]
            public string Nome {get; set;}

            [Required(ErrorMessage = "Campo Obrigatório")]
            [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")]
            public string ISBN {get; set;}

            [Required(ErrorMessage = "Campo Obrigatório")]
            [DataType(Datatype.Date)]
            public DateTime DataLancamento {get; set;}

            public int CategoriaId { get; set; }
            public Categoria Categoria{ get; set; }

            public ICollection<Autor> Autores{ get; set; }

            public Livro()
            {
                this.Autores = new List<Autor>();
            }

        }
        ...

    . Classe Autor

        ...
        public class Autor
        {
            [Key]
            public int Id{ get; set; }

            [Required(ErrorMessage = "Campo Obrigatório")]
            [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")]
            public string Nome {get; set;}

            public ICollection<Livro> Livros { get; set; }

            public Autor()
            {
                this.Livros = new List<Livro>();
            }


        }
        ...


    . Acesse a opção "Build/Rebuild"

    . Com click direito sobre o nó principal do projeto "BookStore", escolha a opção "Manage NuGet Packages...", localize a referência 
        entityframework e faça a instalação.

    . Outra forma de fazer isso é via pacote (dê preferência a essa forma), acesse "View/Other Windows/Package Manager Console", sugirá no rodapé do IDE a aba 
        "Package Manager Console". Acesse essa aba e digite o comando abaixo:

            install-package entityframework

    . Acesse o arquivo "package.config" e verifique as dependências criadas.

    . Acesse o nó principal do projeto "BookStore" com o botão direito, escolha "Add/New Folder..." e nomeie com "Context".

    . Clique com o botão direito sobre a pasta "Context", Escolha "Add/Class" e coloque o nome da classe como "BookStoreDataContext".

    . Acesse a classe "BookStoreDataContext" e implemente o código abaixo:

        ...
        namespace BookStore.Context
        {
            public class BookStoreDataContext : DbContext
            {
                public BookStoreDataContext()
                    :base("BookStoreConnectionString")
                {

                }

                public DbSet<Autor> Autores{ get; set; }
                public DbSet<Categoria> Categorias{ get; set; }
                public DbSet<Livro> Livros{ get; set; }
            }
        }

    . Acesse o arquivo Web.Config e digite o trecho abaixo dentro da tag <configuration>:

        <configuration>
            ...
            <connectionStrings>
                <add name="BookStoreConnectionString" 
                        connectionString="Server=.\sqlexpress;Database=bookstore;User ID=sa;Password=sqlexpress"
                        providerName="System.Data.SqlClient"/>
            </connectionStrings>
            ...
        </configuration>            

        . A senha do sa no banco local ficou "Joao3.16"

    . Acione "Build/Clean" e "Build/Rebuild".

    . Acesse "Package Manager Console" no rodapé da IDE e digite o comando abaixo:

        enable-migrations

        . Esse comando criará uma classe "Configuration.cs" dentro da pasta "Migrations".

    . Digite na "Package Manager Console" o comando abaixo:

        add-migration v1

    . Digite também:

        update-database

    . Acesse o SQL Server e verifique se foi criado as classes com sucesso.

    . Reutlizando os models:

        . O domínio é o coração do seu sistema, ele pode ser reutilizado em vários pontos.

        . Manter o domínio separado da aplicação web poder ser uma boa escolha.

        . Evitar uso de pacotes adicionais na criação do domínio.

    Separando o domínio do projeto Web
    ----------------------------------

    . Clique com o botão direito do mouse sobre a solução, escolha "Add/New project", escolha "Windows/Class Library", 
        informe o nome do projeto "BookStore.Domain.

    . Selecione as Classes "Model" (Autor, Categoria, Livro) e mova elas para o projeto "BookStore.Domain".

    . Acesse a classe Livro.cs e elimine tudo que se refere ao decorator "DataAnnotations":


        using System;
        using System.Collections.Generic;
        // using System.ComponentModel.DataAnnotations;     // Eliminar

        namespace BookStore.Domain          // Inclua o Domain no namespace
        {
            public class Livro
            {
                // [Key]                                        // Eliminar
                public int Id{ get; set; }

                // [Required(ErrorMessage = "Campo Obrigatório")]       // Eliminar
                // [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")] // Eliminar
                public string Nome {get; set;}

                // [Required(ErrorMessage = "Campo Obrigatório")]       // Eliminar
                // [StringLength(30, MinumumLength = 3, ErrorMessage="Tamanho do campo entre 3 a 30 digitos")] // Eliminar
                public string ISBN {get; set;}

                // [Required(ErrorMessage = "Campo Obrigatório")]       // Eliminar
                // [DataType(Datatype.Date)]                            // Eliminar
                public DateTime DataLancamento {get; set;}

                public int CategoriaId { get; set; }
                public Categoria Categoria{ get; set; }

                public ICollection<Autor> Autores{ get; set; }

                public Livro()
                {
                    this.Autores = new List<Autor>();
                }

            }
        }
        ...

    . Faça o mesmo procedimento acima para as demais classes Model.

    . Acesso o projeto "BookStore" com o clique direito do mouse, selecione a opção "References Manager", vá em "Projects" e escolha o projeto
        "BookStore.Domain".

    . Retorne ao projeto "BookStore", acesse a classe "BookStoreDataContext.cs", faça a importação dos models com "Ctrl + .".

    . Acesse o projeto "BookStore" com o botão direito do mouse, escolha "Add/New Folder" e renomeie ela para "ViewModels".

    . Dê um clique direito sobre a pasta "ViewModels", escolha "Add/Class Diagram", dê o nome a ela de "VincularLivroAutorViewModel".

    . Implemente o código abaixo na classe "VincularLivroAutorViewModel":

        using System.ComponentModel.DataAnnotations;

        namespace BookStore.ViewModels
        {
            public class VincularLivroAutorViewModel
            {
                [Required(ErrorMessage="*")]
                public int AutorId { get; set; }

                [Required(ErrorMessage="*")]
                public int LivroId { get; set; }
            }
        }

    . Acesse o SQL Server e apague o banco de dados "BookStore".

    . Acesse a pasta "Migrations", apague o arquivo com a terminação "*_v1.cs".

    . Acesse o "Package Manager Console" no rodapé e digite os comandos abaixo:

        add-migration v1

        update-database

    . Acesse o SQL Server e veja:

        . A criação da tabela de relacionamento "LivroAutors".

        . As especificações de tamanho de campo, campos requeridos, etc. Observe que agora não existe mais nenhuma definição porque retiramos
            todos os decoration dos models.

    . Acesse o SQL Server e apague o banco de dados "BookStore".
    
    . Acesse a pasta "Migrations", apague o arquivo com a terminação "*_v1.cs".


    Forma diferente de mapear os models para o banco de dados
    ---------------------------------------------------------

    . Acesse o projeto "BookStore" com o botão direito do mouse, escolha "Add/New Folder" e renomeie ela para "Mappings".

    . Dê um clique direito sobre a pasta "Mapping", escolha "Add/Class Diagram", dê o nome a ela de "CategoriaMap".

    . Implemente o código abaixo na classe "CategoriaMap":

        using BookStore.Domain;
        using System.Data.Entity.ModelConfiguration;

        namespace BookStore.Mapping
        {
            public class CategoriaMap : EntityTypeConfiguration<Categoria>
            {
                public CategoriaMap()
                {
                    ToTable("Categoria");

                    HasKey( x => x.Id);
                    Property( x => x.Nome ).HasMaxLength(30).IsRequered();

                    HasMany( x=> x.Livros).WithRequired( x => x.Categoria);
                }
            }
        }

        . Dessa forma podemos ter mais flexibilidade para configurar as nossas classes entity. Verifique as propriedades disponíveis
            nos métodos do "Property()." e "HasMany()."

        
    . Dê um clique direito sobre a pasta "Mapping", escolha "Add/Class Diagram", dê o nome a ela de "AutorMap".

    . Implemente o código abaixo na classe "AutorMap":

        using BookStore.Domain;
        using System.Data.Entity.ModelConfiguration;

        namespace BookStore.Mapping
        {
            public class AutorMap : EntityTypeConfiguration<Autor>
            {

                public AutorMap()
                {
                    ToTable("Autor");

                    HasKey( x => x.Id);
                    Property( x => x.Nome ).HasMaxLength(60).IsRequered();

                    HasMany( x=> x.Livros)
                        .WithMany( x => x.Autores)
                        .Map( x => x.ToTable("LivroAutor"));
                }
            }
        }

    . Dê um clique direito sobre a pasta "Mapping", escolha "Add/Class Diagram", dê o nome a ela de "LivroMap".

    . Implemente o código abaixo na classe "LivroMap":

        using BookStore.Domain;
        using System.Data.Entity.ModelConfiguration;

        namespace BookStore.Mapping
        {
            public class LivroMap : EntityTypeConfiguration<Livro>
            {
                public LivroMap()
                {
                    ToTable("Livro");

                    HasKey( x => x.Id);
                    Property( x => x.Nome ).HasMaxLength(60).IsRequered();
                    Property( x => x.ISBN ).HasMaxLength(32).IsRequered();
                    Property( x => x.DataLancamento ).IsRequered();
                }
            }
        }
        
    . Retorne a classe "BookStoreDataContext" e implemente o método abaixo na classe:

        ...
        protected override void OnModelCreating( DbModelBuilder modelBuilder)
        {
            modelBuilder.Configurations.Add( new AutorMap() );
            modelBuilder.Configurations.Add( new CategoriaMap() );
            modelBuilder.Configurations.Add( new LivroMap() );
        }

    . Acesse o "Package Manager Console" no rodapé e digite os comandos abaixo:

        add-migration v1

        update-database

    . Acesse o SQL Server e veja:

        . A criação da tabela de relacionamento "LivroAutor".

        . As especificações de tamanho de campo, campos requeridos, etc. Observe que agora não existe mais nenhuma definição porque retiramos
            todos os decoration dos models.


3. Criando um Controller
------------------------

    . Um pouco mais sobre o controller...

        . Nada mais é do que uma classe que herda de uma classe base.

        . Possui métodos públicos acessíveis via URL.

        . Ficam armazenados na pasta controllers da aplicação.

    . Abra a classe HomeController.cs e observe herança da classe "Controller".

    . Métodos "public" no controller serão acessíveis via URL.

    . Actions:

        . São métodos públicos dentro de controllers.

        . Retornam views (cshtml), arquivos, strings, json, inteiros, etc. Baseados no action result.

        . Podem ser interrompidas antes ou depois de sua execução.

        . Pode ter um retorno genérico (actionresult) ou um retorno específico (viewresult, fileresult...).

    . Existem vários tipos de retornos de um métodos controller ( ActionResult, ViewResult, etc) :

        ...
        public ActionResult Index()     // No lugar do retorno ActionResult poderiamos retornar uma ViewResult neste caso.
        {                               // ActionResult é o mais generico de todos os results
            return View();
        }


    . Action Results

        . São os resultados da execução de uma action

        . Possuem classes espcíficas para otimizar o retorno.

    . De um clique direito sobre a pasta "Controllers", acione "Add/Class..."; porém o correto seria "Add/Controller..."

    . Informe o nome da classe "TesteController.cs"

    . Implemente o código abaixo na classe "TesteController.cs":

        using System.Web.Mvc;

        namespace Bookstore.Controllers
        {
            public class TesteController: Controller
            {
                public string Teste()
                {
                    return "Testado";
                }
            }
        }

    . Execute o projeto, vá no navegador e acione a url abaixo:

        localhost:[porta]/Teste/Teste

    . Altere o código da classe TesteController como abaixo:

        using System.Web.Mvc;

        namespace Bookstore.Controllers
        {
            public class TesteController: Controller
            {
                public JsonResult Teste()
                {
                    var autor = new Autor{
                        Id=1,
                        Nome="Marco Antonio"
                    };

                    return Json( autor, JsonRequestBehavior.AllowGet);
                }
            }
        }

    . Execute o projeto, vá no navegador e acione a url abaixo:

        localhost:[porta]/Teste/Teste

    . Recebendo parâmetros:

        . Podemos receber parâmetros via query string.

        . Podemos receber parâmetros via post.

        . Podemos receber objetos complexos.

    . Uma requisição é coposta por um cabeçalho (Header) e um corpo (body).

    . O cabeçalho contém uma lista (chave/valor) informando vários parâmetros como tipo de dados do corpo, token de segurança e afins.

    . O corpo em sí contém as informações que devem ser serializadas de acordo com o parâmetro "contenttype" presente no cabeçalho.

    . Model Binder:

        . Faz a atribuição dos parâmetros recebidos no corpo da requisição.

        . Consegue instanciar objetos complexos.

        . Tenta obrigatoriamente mapear todos os parâmetros não nulos da requisição.


Aula 3 - Entendendo as URL amigáveis.
-------------------------------------        

    . Sobre a rota padrão do MVC

        . http://localhost:2030/

            . localhost - Representa seu domínio, ou seja, localhost significa rodando localmente.

            . :2030 - Representa a porta na qual o site está respondendo.

        . Se nda for informado após a porta do domínio, o ASP.NET MVC interpreta a rota padrão:

            . http://dominio:porta/controller/action/parâmetros

                . O controller padrão é o homeController

                . A action padrão é sempre a index.

    . Sobre a rota padrão do MVC

        . Um controller no MVC sempre possui o sufixo "controller" que é ignorado na URL:

            . http://localhost:2030/home/sobre
            . http://localhost:2030/home/empresa
            . http://localhost:2030/home/contato
            

        . Caso nenhuma action seja informada, o ASP.NET MVC tentará mapear uma action chamada "index" no controller

            . http://localhost:3020/cliente - busca automaticamente uma action chamada "index" no controller "clienteController"

    . Acesse a classe TesteController e altere o nome da propriedade "Teste" para "UmaAction".

        ...
        public JsonResult UmaAction()
        {
            var autor = new Autor{
                Id=1,
                Nome="Marco Antonio"
            };

            return Json( autor, JsonRequestBehavior.AllowGet);
        }
        ...


    . Execute o projeto e no navegador execute a URL abaixo:

        http://localhost:52147/Teste/UmaAction
                                |       |
                                |       |
                                |       +----> Irá chamar o método "public Autor UmaAction()"
                                |
                                +---> irá chamar a classe controller "public class TesteController: Controller"

    . Execute a URL http://localhost:52147/Index e veja o resultado:

        . Dará erro porque a classe TesteController não tem o método/action com o nome "index".

        . Acrescente o método abaixo e execute novamente a url "http://localhost:52147/Index"

            ... 
            public string Index()
            {
                return "Index";
            }
            ...

    . Sobre a rota padrão do MVC

        . Uma action pode ser decorada com um atributo actionName, para trocar seu nome.

        . Por padrão, uma parâmetro do tipo inteiro, opcional, é esperado no final da rota.

        . Caso este parâmetro seja informado ele é automaticamente mapeado para um parâmetro "id" da action:

            http://localhost:2030/produto/detalhes/23

    . Altere o método "Index" da classe "TesteController" acrescentando o parâmetro "Id":

        ... 
        public string Index( int Id )
        {
            return "Index " + Id.ToString();
        }
        ...

    . Execute o projeto e no navegador execute a URL abaixo:

        http://localhost:52147/Teste/Index/1

    
    . Sobre a rota padrão do MVC

        . Em resumo, podemos definir a rota padrão do ASP.NET MVC como:

            . http://{dominio}:{porta}/{controller}/{action}/{id?}

            . Onde "id" é um parâmetro opcional, o "?" seria para representar essa definição.

        . Sendo assim, se temos um controller chamado {LivroController}, com uma action chamada {detalhes}, recebendo um {id}
            do livro a ser exibido como {parâmetro}, teriamos a seguinte URL:

          http://localhost:2030/livro/detalhes/32


        . Parâmetros adicionais podem ser passados para a rota via query string:

            . http://localhost:2030/livro/listar?categoria=2

            . Lista todos os livros da categoria 2

        . Neste caso, a action deve esperar um parâmetro chamado "categoria" do tipo inteiro

        . Em caso de parâmetros adionais deve-se utilizaro "&"

            . http://localhost:2030/livro/listar?categoria=2&autor=1

            . Lista todos os livros da categoria 2 cujo "id" do autor é 1

        . Existe um limite de 1024 caracteres para uma URL

        . Em caso de muitos parâmetros, realize um POST.

    . Acesse a classe TesteController e altere o método "UmaAction" conforme abaixo:

        ...
        public Autor UmaAction( int id, string nome)
        {
            var autor = new Autor{
                Id= id,
                Nome=nome
            };

            return Json( autor, JsonRequestBehavior.AllowGet);
        }
        ...

    . Execute o projeto e no navegador execute a URL abaixo:

        http://localhost:52147/Teste/UmaAction

        . A URL acima dará erro porque não foram informado os parâmetros da URL.

    . Execute o projeto e no navegador execute a URL abaixo com os parâmetros necessários:

        http://localhost:52147/Teste/UmaAction?id=1&nome=MARCO

    . O parâmetro "nome" por ser uma "string" ele é opcional, porém o "id" que é um "int" este é Obrigatório. Para deixar o parâmetro
        opcional devemos utilizar o caracter "?" no tipo do parâmetro.

    . Altere a assinatura do método "UmaAction" como abaixo:


        ...
        public Autor UmaAction( int? id, string nome)   // Alterado int?. Neste caso deve-se colocar um valor default 0
        {
            var autor = new Autor{
                Id= 0,
                Nome=nome
            };

            return Json( autor, JsonRequestBehavior.AllowGet);
        }
        ...

    . Execute o projeto e no navegador execute a URL abaixo:

        http://localhost:52147/Teste/UmaAction

        . Agora não dará mais erro porque o parâmetro "id" agora é opcional.

    . O recurso de querystring somente é interessante qdo estamos trabalhando com paginação:

        http://localhost:52147/Teste/UmaAction?listar=10&pagina=5

    . Evitar o uso de querystring devido a limitação de 1024 byte de tamanho da querystring

    . Acrescente o método "ActionDois" na classe "TesteController" como abaixo:

        ...
        [HttpPost]
        public JsonResult ActionDois( Autor autor)
        {
            return Json( autor );
        }
        ...

    . Acesse o Postman, crie uma nova URL como:

        method: POST
        url: http://localhost:52147/Teste/ActionDois
        body: [
            raw
            type: JSON
            parameters: { 
                        "Id": "1",
                        "Nome": "Marco"
            }
        ]

    . Coloque um "BreakPoint" na linha com "return Json( autor )" na classe "TesteController" e execute a URL no Postman.

    . Outra forma para executar a URL "ActionDois" com parâmetros dentro do Postman seria fazendo uso do "form-data".

        . Dentro da aba "Body", escolha o tipo "form-data".

        . Insira os parâmetros abaixo:

            . Id: 1
            . Nome: "Marco"

        . Execute a URL no Postman.

    . Insira a decoration "ActionName" no método "ActionDois" como abaixo:

        ...
        [HttpPost]
        [ActionName("Autor")]
        public JsonResult ActionDois( Autor autor)
        {
            return Json( autor );
        }
        ...

    . No Postman altere a chamada da URL como abaixo:

        url: http://localhost:52147/Teste/Autor


    . Route Table

        . Existe uma ordem na execução das rotas no ASP.NET MVC.

        . A rota padrão pode ser alterada.

        . Caso a rota não seja encontrada, a padrão é acionada.

        . Caso a rota padrão seja incompatível, o erro 404 será lançado.


Aula 4 - Travegando informações para a View
------------------------------------------- 

    . Um pouco mais sobre as Views

        . São HTML, CSS e Javascript.

        . Podem executar funções do C# com Razor (View Engine).

        . Podem interagir com objetos enviados a ela.

        . São processadas no servidor e enviadas para o cliente.

        . As Views podem receber parâmetros como variáveis ou tipos complexos.

        . Estes parâmetros são recebidos através da sintaxe @Model

        . Se um parâmetro diferente do esperado for enviado a view, causará um erro.

            . Este erro só ocorrerá em tempo de execução.

        . Além dados fisos, a view pode receber dados de outras formas.

    . Outras formas de enviar informações:

        . ViewBag

            . Tipo dinâmico, um wrapper para o viewdata, é automaticamente excluído após a rendererização da view.

        . ViewData

            . Criado informando uma string, no modelo chave/valor, é automaticamente excluído após a rendererização da view

        . TempData

            . Criado informando uma string, no modelo chave/valor, é automaticamente excluído após a segunda requisição.

        . Session

            . Criado informando uma string, no modelo chave/valor, permanece no servidor por um tempo determinado pelo desenvolvedor.

    . Cuidados com Session

        . Não escala.

        . Pode acumular lixo no servidor

        . É fracamente tipada.

        . Manipula na tela tudo que ocê precisar.

    . Inclua o método abaixo na classe "TesteController":

        ...
        public ViewResult Dados( int id)
        {
            return View( id );
        }
        ...

    . Dê um clique direito sobre a Action, sobre o nome do método "Dados"  e escolha a opção "Add View..."

    . Acione o botão "Ok" da tela seguinte.

    . Acesse o componenete Dados.cshtml e insira o código abaixo:

        @model int
        @{
            ViewBag.Title = "Dados";
        }

        <h2>Dados da @Model</h2>

    . Acesse o navegador e execute a URL abaixo:

        http://localhost:52147/Teste/Dados/1

    
    . Altere o método "Dados" do "TesteController" como abaixo:

        ...
        public ViewResult Dados( int id)
        {
            return View( "" );  // Alterado o id pelo ""
        }
        ...

    . Acesse o navegador e execute a URL abaixo:

        http://localhost:52147/Teste/Dados/1

        . Observe que dará erro porque durante a conversação do parâmetro não foi possivel transformar para inteiro.

    . Repita a mesma operação, porém utilizado um parâmetro data.

        ...
        public ViewResult Dados( int id)
        {
            return View( DateTime.Now );  // Alterado o id pelo DateTime.Now
        }
        ...

    . Altere o metodo "Dados" pelo conteúdo abaixo:

        ...
        public ViewResult Dados( int Id )
        {
            var autor = new Autor{
                Id = 1,
                Nome = "Marco"
            };

            return View(autor);
        }
        ...

    . Acesse o componenete Dados.cshtml e insira o código abaixo:

        @model BookStore.Domain.Autor
        @{
            ViewBag.Title = "Dados";
        }

        <h2>Dados da @Model.Nome</h2>

    . Acesse o navegador e execute a URL abaixo:

        http://localhost:52147/Teste/Dados/1


    . Altere o metodo "Dados" pelo conteúdo abaixo:

        ...
        public ViewResult Dados( int Id )
        {
            var autor = new Autor{
                Id = 1,
                Nome = "Marco"
            };

            ViewBag.Categoria = "Produtos de Limpeza";
            ViewData["Categoria"] = "Produtos de Informática";
            TempData["Categoria"] = "Produtos de Escritória";
            Session["Categoria"] = "Móveis";


            return View(autor);
        }
        ...

    . Acesse o componenete Dados.cshtml e insira o código abaixo:

        @model BookStore.Domain.Autor
        @{
            ViewBag.Title = "Dados";
        }

        <h2>Dados da @Model.Nome</h2>

        <ul>
            <li>ViewBag: @ViewBag.Categoria</li>
            <li>ViewData: @ViewData["Categoria"]</li>
            <li>TempData: @TempData["Categoria"]</li>
            <li>Session: @Session["Categoria"]</li>
        </ul>

    . Acesse o navegador e execute a URL abaixo:

        http://localhost:52147/Teste/Dados/1

    . Evite de usar ViewBag, ViewData, TempData e Session. Utilize o viewModel "@Model" que acaba sendo muito mais eficiente.



Rotas
-----

Aula 5. Criando rotas customizadas
----------------------------------

    . Qunado a rota padrão não atende:

        . Podemos criar rotas customizadas no ASP.NET MVC habilitando a opção no arquivo RouteConfig.cs:

            routes.MapMvcAttributeRoutes();

        . Os mapamentos devem ser feitos antes da rota padrão, ou seja, esta configuração deve ficar antes do "ROUTES.MAPROUTE" padrão.

        . Feito isto, basta decorara os controllers com o atributo routing

            [Route("produto/{id?}")]

        . Com isto, conseguimos manter a escrita do código em inglês e as rotas em português.

    . Podemos colocar as rotas dentro do arquivo "App_Start/RouteConfig.cs". Conteúdo inicial deste arquivo seria:

        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Web;
        using System.Web.Mvc;
        using System.Web.Routing;

        namespace BookStore
        {
            public class RouteConfig
            {
                public static void RegisterRoutes(RouteCollection routes)
                {
                    routes.IgnoreRoute("{resource}.axd/{*pathInfo}");

                    routes.MapRoute(
                        name: "Default",
                        url: "{controller}/{action}/{id}",
                        defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
                    );
                }
            }
        }

        . Atentar para o detalhe que as rotas identificadas dentro do método "RegisterRoutes" segui a sequência de declarações, 
            a primeira que for encontrada será executada.

    . Mapeamento

        . Basicamente, o qur escrito no atributo será capturado via URL, ou seja, se decorar uma ação com o atributo:

            [Route("loja/promocoes/produto/{id?})]        

        . Sua URL ficará:

            http://localhost:[porta]/loja/promocoes/produto/1

        . A captura de parâmetros na URL é feita pelo nome do mesmo entre chaves, e no caso de parâmetros nullable, adiciona-se um 
            sinal de interrogação ao final do mesmo.

        . Caso queria definir um valor padrão para o parâmetro, basta adicionar "=valor"

    . Parâmetro padrão:

        . Parâmetro padrão:

            [Route("loja/promocoes/prodto/{id}")]
        
        . Parâmetro nullable

            [Route("loja/promocoes/prodto/{id?}")]

        . Parâmetro com valor padrão

            [Route("loja/promocoes/prodto/{id}=1")]

        . Parâmetro tipado com valor padrão

            [Route("loja/promocoes/prodto/{id:int=1}")]


    . Acesse o arquivo "RouteConfig.cs" e insirá a linha "routes.MapMvcAttributeRoutes()":

        ...
        public static void RegisterRoutes(RouteCollection routes)
        {
            routes.IgnoreRoute("{resource}.axd/{*pathInfo}");

            routes.MapMvcAttributeRoutes();     // Linha inserida

            routes.MapRoute(
                name: "Default",
                url: "{controller}/{action}/{id}",
                defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
            );
        }

        . Serve para ativar o roteamento baseado em atributo no ASP.NET MVC 5

    . Acesse a classe "TesteController.cs" e implemente o método abaixo:

        ... 
        [Route("minharota")]
        public string MinhaAction()
        {
            return "Ok! Cheguei na rota";
        }
        ...

        . Nesse caso a URL ficará somente http://localhost:[porta]/minharota

    . Insira o parâmetro "id" na rota e na assinatura do método:

        ... 
        [Route("minharota/{id}")]
        public string MinhaAction(int id)
        {
            return "Ok! Cheguei na rota";
        }
        ...

        . Execute a URL  http://localhost:[porta]/minharota/1

        . Neste caso o parâmetro é Obrigatório, caso não for fornecido um "id" na url obteremos o statuscode 404. 

        . Para não deixar obrigatório o parâmetro precisamos colocar o "?" nos parâmetros da URL e da assinatura do método

            ... 
            [Route("minharota/{id?}")]
            public string MinhaAction(int? id)
            {
                return "Ok! Cheguei na rota";
            }
            ...

        . Execute a URL  http://localhost:[porta]/minharota/

        . Para deixar obrigatório o parâmetro como um inteiro precisamos definir o tipo na rota

            ... 
            [Route("minharota/{id:int}")]
            public string MinhaAction(int id)
            {
                return "Ok! Cheguei na rota";
            }
            ...

        . Execute a URL  http://localhost:[porta]/minharota/banana para dar erro

        . Execute a URL  http://localhost:[porta]/minharota/1

    . Prefixo de rota

        . Cria um prefixo antes de uma, ou mais rotas de controller

        . Otimiza seu tempo na escrita de rotas personalizadas

        . Utiliza o atributo routePrefix para realização do mesmo

        . Basta decorar um controller com RoutPrefix para utilizar

        . Requer que o mapamento de rotas esteja habilitado.


    . Prefixo de rota

        . Toda rota para este controller deve iniciar com loja

            [RoutePrefix("loja")]

        . Rota com parâmetro não obrigatório:

            [Route("produto/{id?})]

            http://localhost:[porta]/loja/produto/1

            ou

            http://localhost:[porta]/loja/produto/

        . Para ignorar o RoutPrefix em uma action exclusivamente, utilize "~" antes da rota

            [Route("~/produto/detalhes/{id?})]

            http://localhost:[porta]/produto/detalhes/1     // Sem loja como prefixo.


    . Acesse a classe "TesteController.cs" e acrescente o decorator [RoutePrefix("teste")]    

        ...
        [RoutePrefix("teste")]
        public class TesteController: Controller
        {
            ...
        }
        ...

        . A partir desse momento toda chamada a essa api deverá vir acrescida no pathname a constante "teste", exemplo:

            http://localhost:[porta]/teste/minharota/1

        . Para ignorar o prefixo "teste" podemos utilizar o "~" na definição da rota do método.

            ... 
            [Route("~/minharota/{id:int}")]
            public string MinhaAction(int id)
            {
                return "Ok! Cheguei na rota";
            }
            ...

            . Execute o projeto com a URL http://localhost:[porta]/minharota/1

    . Clique com o botão direito do mouse sobre a pasta "Controllers", escolha "Add/New Controller..." e escolha 
        "Controller MVC 5 Empty"

    . Dê o nome de "AuthorController"

    . Acesse a classe "AuthorController" e implemente o código abaixo:

        ...
        namespace BookStore.Controllers
        {

            [RoutePrefix("autores")]
            public class AuthorController: Controller
            {
                [Route("listar")]
                public ActionResult Index()
                {
                    return View();
                }

                [Route("criar")]
                public ActionResult Create()
                {
                    return View();
                }

                [Route("editar/{id:int}")]
                public ActionResult Edit(int id)
                {
                    return View();
                }

                [Route("excluir/{id:int}")]
                public ActionResult Delete(int id)
                {
                    return View();
                }

            }
        }

    . Clique com o botão direito sobre o nome do método "Index, Create, Edit e Delete", escolha "Add/New Action..."

    . Execute as URLs abaixo:

        http://localhost:[porta]/autores/listar

        http://localhost:[porta]/autores/criar

        http://localhost:[porta]/autores/editar/1

        http://localhost:[porta]/autores/excluir/1


Aula 6. Restringindo Rotas
--------------------------

    . Tipos de parâmetros das rotas:

        Constraint              Descrição                                                               Exemplo
        ----------              ---------                                                               -------
        alpha                   Matches uppercase or lowercase latin alphabet characters (a-z, A-Z)     {x:alpha}
        bool                    Matches a boolean value                                                 {x:bool}
        datetime                                                                                        {x:datetime}
        double                  64 bit floating-point                                                   {x:double}
        float                   32 bit                                                                  {x:float}
        guid                                                                                            {x:guid}
        int                                                                                             {x:int}
        length                                                                                          {x:length(6)} {x:length(1,20)}
        long                    64 bit integer                                                          {x:long}
        max                     Matches an integer with a maximum value                                 {x:max(10)}
        min                     Matches an integer with a minimum value                                 {x:min(10)}                                                                                   
        minlength               String with a minumum length                                            {x:minlength(10)}
        range                                                                                           {x:range(10,50)}
        regex                                                                                           {x:regex(^\d{3}-\d{3}-\d{4}$)}

    . Restrições nas rotas

        . O atributo route permite a plicaão de restrições nas rotas

        . O atributo abaixo etá restrito a receber apenas parâmetros inteiros:

            [Route("produto/detalhes/{id:int}")]

        . Estas restrições interferem em como as rotas são chamadas.

        . Por exemplo, se houverem duas rotas:

            [Route("produto/detalhes/{id:int}")]

            [Route("produto/detalhes/{name}")]

        . Caso um inteiro seja informado, a primeira rota será executada, caso contrário, a segunda.

        . As restrições nas rotas podem ser cumulativas:

            [Route("produto/{id:int:min(1)}")]

            [Route("produtos/{categoria:maxlength(3)?}")]
    
    . Acesse a classe "TesteController.cs" e implemente o código abaixo:

        ...
        [Route("rota/{caegoria:minlength(3)}")]
        public string MinhaAction3( string categoria){
            return "MinhaAction3 " + caegoria;
        }
        ...

        . Execute no navegador a URL abaixo:

            . Para testar com erro:

            http://localhost:[porta]/teste/rota/ab
        
            . Para testar sem erro:

            http://localhost:[porta]/teste/rota/abc

        . Altere o datatype do parametro, colocando "alpha":

            ...
            [Route("rota/{caegoria:alpha:minlength(3)}")]
            public string MinhaAction3( string categoria){
                return "MinhaAction3 " + caegoria;
            }
            ...

        . Execute no navegador a URL abaixo:

            . Para testar com erro:

            http://localhost:[porta]/teste/rota/123
        
            . Para testar sem erro:

            http://localhost:[porta]/teste/rota/abc

    . Customizando as restrições

        . Podemos criar nossa própria restrição para  rota

        . Basta criar uma class e implemntar a interface [RoutConstraint]

        . Muito útil qdo trabalhamos com enumeradores por exemplo

        . Dada a classe contrída, é necssário adicionar a restrição a lista de restrições padrão:

            var constraintResolver = new DefaultInlineConstraintResolver();

            ConstraintResolver.ConstraintMap.Add("tipoProduto", typeOf(tipoProdutoConstraint));

    . Clique com o botão direito sobre o projeto BookStore, escolha "Add/New Folder" e dê o nome de "RoutesConstraints".

    . Clique com o botão direito sobre a pasta "RoutesConstraints", "Add/New Class" e dê o nome de "ValuesConstraint.cs".



ATENÇÃO: A demo abaixo não ocorreu com sucesso. Fazer pesquisa para ver se consegue corrigir
--------------------------------------------------------------------------------------------

    . Implemente o código abaixo na classe criada:
16:07
        using System;
        using System.Collections.Generic;
        using System.Linq;
        using System.Web;
        using System.Web.Routing;

        namespace BookStore.RoutesConstraints
        {

            public class ValuesConstraint: IRouteConstraint
            {
                private readonly string[] validOptions;
                
                public ValuesConstraint( string options )
                {
                    validOptions = options.Split('|');
                }

                public bool Match( HttpContextBase httpContxt, 
                                    Route route, string parameterName, 
                                    RouteValueDictionary values, 
                                    RouteDirection routeDirection )
                {
                    object value;

                    if (values.TryGetValue( parameterName, out value ) &&  value!= null)
                    {
                        return validOptions.Contains( value.ToString(), StringComparer.OrdinalIgnoreCase );
                    }

                    return false;
                }
            }
        }

https://www.c-sharpcorner.com/UploadFile/ff2f08/custom-route-constraints-in-Asp-Net-mvc-5/

    . Acesse a classe RouteConfig.cs e insira o código abaixo:

        ...
        public static void RegisterRoutes(RouteCollection routes)
        {
            routes.IgnoreRoute("{resource}.axd/{*pathInfo}");

            /* Valores Inseridos */
            var constraintsResolver = new DefaultInlineConstraintResolver();
            
            constraintsResolver.ConstraintMap.Add("values", typeof( ValuesConstraint ));
            /* */

            routes.MapMvcAttributeRoutes( constraintsResolver );     // Linha Alterada

            routes.MapRoute(
                name: "Default",
                url: "{controller}/{action}/{id}",
                defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
            );

            /* Valores Inseridos */
            routes.MapRoute(name: "newRoute",
                    url: "api/rota/estacao/{estacao:values(primavera|verao|outono|inverno)}",
                    defaults: new { controller = "Teste", action = "MinhaAction4" },
                    constraints: new { name = new ValuesConstraint("primavera|verao|outono|inverno") }
            );
            /* */
        }

    . Implemente o método abaixo na classe "TesteController.cs":

        ...
        [Route("rota/estacao/{estacao:Values(primavera|outono|verao|inverno)}")]
        public string MinhaAction4(string estacao)
        {
            return "Olá, estamos no " + estacao;
        }

TODO: Continuar daqui
Aula 7. Action Filters
----------------------
 
    . Filtros

        . Action Filter é um atributo que você pode aplicar a uma action ou um controller.

        . Uma action/controller pode conter vários filtros.

        . Existem 4 tipos de filtros

            . Authorization filters - Implementam autorização

            . Action filters - Genéricos, implementao de IActionFilter

            . Result filters - Formatam os resultados, implementam IResultFilter

            . Exception Filters - Tratam exceções, implementa IExceptionFilter.

    . Os filtros possuem uma ordem de execução:

        . Authorization Filters.

        . Action Filters

        . Result Filters

        . Exception Filters.

    . O filtro padrão, que implementa o IActionFilterAttribute possui os seguintes métodos:

        . OnActionExceuting

            . Executado antes da chamado da action

        . OnActionExecuted

            . Executado depois da chamada a action

        . OnResultExecuting

            . Executado antes do retorno do resultado da action

        . OnResultExecuted

            . Executado depois do retorno do resultado da action.

    . Clique com o botão direito sobre o projeto BookStore, escolha "Add/New Folder" e dê o nome de "Filters".

    . Clique com o botão direito sobre a pasta "Filters", "Add/New Class" e dê o nome de "LogActionFilter.cs".

    . Implemente o código abaixo na classe recém criada:

        using System;
        using System.Diagnostics;
        using System.Web.Mvc;
        using System.Web.Routing;

        namespace BookStore.Filters
        {
            public class LogActionFilter: ActionFilterAttribute
            {
                public override voi OnActionExecuting( ActionExecutingContext filterContext )
                {
                    Log("OnActonExecuting", filterContext.RouteData);
                }

                public override void OnActionExecuted( ActionExecutedContext filterContext )
                {
                    Log("OnActionExecuted", filterContext.RouteData);
                }

                public override void OnResultExecution( ResultExecutingContext filterContext )
                {
                    Log("OnResultExceuting", filterContext.RouteData);
                }

                public override void OnResultExecuted( ResultExecutingContext filterContext )
                {
                    Log("OnResultExecuted", filterContext.RouteData);
                }

                private void Log( string methodName, RouteData routeData )
                {
                    var controllerName = routeData.Values["controller"];
                    var actionName = routeData.VAlues["action"];
                    var message = String.Format("{0} controller: {1} action: {2}", methodName, controllerName, actionName );

                    Debug.WriteLine( message, "ACtion Filter Log");
                }

            }
        }
        
        
    . Acesse a classe AuthorController e insira [LogActionFilter()] como abaixo:

        ...
        namespace BookStore.Controllers
        {
            [RoutePrefix("autores")]
            [LogActionFilter()]
            public class AuthorController: Controller
            {
                ...
            }
        }

    . Coloque "BreakPoints" na classe LogActionFilter, dentro de cada método sobreescrito e execute o projeto.

    . O decorator [LogActionFilter()] pode ser colocado em um método especifico 