Curso .NETCore 3.1 ou NET5.0 - CSharp API Arquitetura DDD na Prática - UDEMY
----------------------------------------------------------------------------

Aula 6 - Download linux Peppermint OS 9
---------------------------------------

    . Acessar a URL https://www.osboxes.org/virtualbox-images/ para baixar a imagem pronta da 
        distribuição Peppermint

    . Acesse o Virtualbox, crie uma vm com o nome Peppermint.

    . Após download descompacte a vm em ~/Virtualbox VMs/Peppermint

    . Importe a VM baixada.


Aula 8. Alterar Algumas Configurações do Linux Peppermint OS 9    
--------------------------------------------------------------

    . Inicie e acesse a VM. O usuário e senha são osboxes.org / osboxes.org

    . Altere o layout do teclado para Português Brasil

    . Altere o fuso horário

    . Acesse o terminal e execute os comandos abaixo:

        sudo apt-get update && sudo apt-get upgrade

        sudo apt-get install virtualbox-guest-utils virtualbox-guest-x11 virtualbox-guest-dkms -y


Aula 9. Alterar Senha OsBoxes.org
---------------------------------

    passwd 


Aula 11. Instalar AspNetCore 3.1
--------------------------------

    . Acesse o link abaixo para baixar o .NET Core 3.1

        https://dotnet.microsoft.com/download

    . Acesse o download "All .NET Core downloads" e baixe a versão 3.1

    . Acesse o link "Package manager instructions" 

    . Localize a versão do Ubuntu que está sendo utilizado, copie e execute os comandos no 
        terminal:

        wget https://packages.microsoft.com/config/ubuntu/20.10/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
        sudo dpkg -i packages-microsoft-prod.deb
        sudo apt-get update;   sudo apt-get install -y apt-transport-https &&   sudo apt-get update &&   sudo apt-get install -y dotnet-sdk-5.0
        sudo apt-get update;   sudo apt-get install -y apt-transport-https &&   sudo apt-get update &&   sudo apt-get install -y aspnetcore-runtime-5.0

    . Para testar a instalação execute os comandos abaixo:

        dotnet --version
        dotnet --help
        dotnet --list
        dotnet --list-runtimes
        dotnet --list-sdks

Aula 12. Instalar MySQL e WorkBench
------------------------------

    . Abra o terminal e execute os comandos abaixo:

            sudo apt update 
            sudo apt upgrade

            # No passo abaixo use <Tab> para mover entre as opções e dê <OK> para finalizar a escolha
            wget http://repo.mysql.com/mysql-apt-config_0.8.13-1_all.deb

            sudo dpkg -i mysql-apt-config_0.8.13-1_all.deb
            sudo apt update 
            sudo apt install mysql-server
            sudo systemctl restart mysql

            # Passo opcional caso queira melhorar o nivel de segurança do banco
            # sudo mysql_secure_installation

            create user 'marco'@'localhost' identified by 'brasil2';

            GRANT ALL PRIVILEGES ON *.* to 'marco'@'localhost' WITH GRANT OPTION;


            mysql -u marco -p

    . Acesse o site https://dev.mysql.com/downloads/workbench/ e realize o download do mysql-workdbenck

    . Acesse o local do download e execute os comandos abaixo:

        sudo dpkg -i mysql-workbench-community_8.0.23-1ubuntu20.10_amd64.deb 
        sudo apt-get install -f
        sudo dpkg -i mysql-workbench-community_8.0.23-1ubuntu20.10_amd64.deb 

    . Acesse o mysql-workbench e altere a conexão que está com o usuário root pelo marco.


Aula 13. Instalar Visual Studio Code
------------------------------------

    . Acesse o site do Visual Studio, faça o download e a instalação

    . Instale as extensions abaixo:

        C#
        C# Extensions
        C# XML Documentation Comments
        vscode-icons (Opcional)
        

Aula 19. Documentação do C# e o que eu posso fazer com C#
---------------------------------------------------------

    . A documentação da Microsoft encontra-se no link abaixo:

        https://docs.microsoft.com/pt-br/dotnet/csharp


Aula 20. Criar uma Solution
---------------------------

    . Crie uma pasta com o nome CSharpBasico

    . Digite o comando abaixo para verificar as opções do compilador dotnet:

        dotnet new

    . Dentro da pasta CSharpBasico digite o comando abaixo:

        dotnet new sln --name CSharpBasico

    . Para acessar a solução com o VisualStudio Code digite o comando abaixo:

        code .

    . Dentro da "Solution" criaremos um projeto, do tipo console:

        dotnet new console -n HelloWorld -o helloWorld
        
        -n : name da aplicação (Nome do projeto HelloWorld.csproj )
        -o : output (nome da pasta que será criado para criar as classes)

    . A estrutura de pastas ficará:

        CSharpBasico
            |
            +----------- obj
            |
            +----------- helloWorld
            |               +----   HelloWorld.csproj
            |               +----   Program.cs
            CSharpBasico.sln

    . Agora precisamos associar o projeto a solution

        dotnet sln add helloWorld/

    . Digite o comando abaixo para verificar os projetos que compoem a solution:

        dotnet sln list

    . O arquivo Program.cs possui um método main. Para executarmos a classe Program.cs digite os
        comandos abaixo:

        cd CSharpBasico/helloWorld

        dotnet run


Aula 21. O que é uma Namespace
------------------------------

    . Namespace tem a mesma lógica de packages do java. Obedecendo critérios de imports das classes.


Aula 24. Tipos Primitivos
-------------------------

    . As variáveis value type contém dentro delas um valor, enquanto as reference type contém uma referência. Isso significa 
        que se copiar uma variável do tipo value type para dentro de outra o valor é copiado e, se o mesmo for feito com uma 
        do tipo reference type será copiado apenas a referência do objeto.

    . Value Type existem duas categorias: struct e enum.

        . Struct: é dividida em tipos numéricos, bool e estruturas personalizadas pelo usuário.
    
            Os tipos numéricos:

                Tipo de dados	Intervalo
                -------------   ---------
                byte	        0 ..255
                sbyte	        -128 ..127
                short	        -32,768 ..32,767
                ushort	        0 ..65,535
                int	            -2,147,483,648 ..2,147,483,647
                uint	        0 ..4,294,967,295
                long	        -9,223,372,036,854,775,808..9,223,372,036,854,775,807
                ulong	        0 ..18,446,744,073,709,551,615
                float	        -3.402823e38 ..3.402823e38
                double	        -1.79769313486232e308 ..1.79769313486232e308
                decimal	        -79228162514264337593543950335..79228162514264337593543950335
                char	        U+0000 .. U+ffff
                string
                bool

            Exemplos:

                int myNum = 5;
                long myNum = 15000000000L;
                double myDoubleNum = 5.99D;
                float myNum = 5.75F;
                char myLetter = 'D';
                bool myBool = true;
                string myText = "Hello";            

        . Enum:  permite criar um tipo que é formado por várias constante

            . Exemplo 1:

                class Pedido
                {
                    enum Situacao
                    {
                        Aberto,
                        Faturado,
                        Cancelado
                    }

                    public int numero;
                    public DateTime dataHora;
                    public int situacao;

                }            

                class Program
                {
                    static void Main(string[] args)
                    {
                        Pedido pedido = new Pedido();

                        pedido.numero = 1;
                        pedido.dataHora = DateTime.Now;

                        // A propriedade situacao recebe o valor via cast 
                        // porque o tipo dela é int
                        pedido.situacao = (int) Situacao.Faturado;

                        Console.WriteLine("Número do pedido: "
                        + pedido.numero.ToString());
                        Console.WriteLine("Número do pedido: "
                        + pedido.dataHora.ToString());
                        Console.WriteLine("Número do pedido: "
                        + pedido.situacao.ToString());

                    }
                }


            . Exemplo 2: Mudando o enum para public e colocando o valor da propriedade
                            Pedido.situacao diretamento o conteúdo do enum
                            Situacao.Faturado

                class Pedido
                {
                    public enum Situacao
                    {
                        Aberto,
                        Faturado,
                        Cancelado
                    }

                    public int numero;
                    public DateTime dataHora;
                    public int situacao;

                }            

                class Program
                {
                    static void Main(string[] args)
                    {
                        Pedido pedido = new Pedido();

                        pedido.numero = 1;
                        pedido.dataHora = DateTime.Now;

                        pedido.situacao = Situacao.Faturado;

                        Console.WriteLine("Número do pedido: " + pedido.numero.ToString());
                        Console.WriteLine("Número do pedido: " + pedido.dataHora.ToString());
                        Console.WriteLine("Número do pedido: " + pedido.situacao );

                    }
                }

    . Reference Types - armazenam apenas a referência do objeto. 
        Os tipos de referência são: class, interface, delegate, object, string e Array.

        . Tipo object: todos os tipos são derivados da classe Object, sendo assim é possível 
            converter qualquer tipo para object.

        . Tipo string: é utilizado para se armazenar caracteres e uma string deve estar entre aspas

        Exemplos:

            string nome = "DevMedia";
            tipo[] nomeDoArray = {item, item, item};

            string[] array = {"Quadrado", "Círculo", "Triângulo", "Retângulo"};
            string forma =  array[2];

    . Constantes:

        Exemplo: const double medida = 10.5;

    . Ao invés de declarar o tipo da variável é possivel declarar com o tipo "var", onde o tipo da variável
        será determinado pelo seu conteúdo:

        var nome = "Marco";
        var idade = 54;
        var casado = true;

    . Quando for utilizar variáveis em classes deve obedecer os modificadores de acesso como abaixo:

        Modificador	            Funcionamento
        -----------             -------------
        public	                O acesso não é restrito.
        protected	            O acesso é limitado às classes ou tipos derivados daclasse que a variável está.
        Internal	            O acesso é limitado ao conjunto de módulos(assembly) corrente.
        protected internal	    O acesso é limitado ao conjunto corrente ou tipos derivados da classe recipiente.
        private	                O acesso é limitado à classe que a variável está.


Aula 26. Operadores Aritméticos
-------------------------------

    Operador Aritmético	    Descrição
    -------------------     ---------
        +	                Adição
        -	                Subtração
        *	                Multiplicação
        /	                Divisão
        %	                Módulo (resto da divisão)

    Exemplos:

        int a = 5, b = 10, c = 15, d = 20; // declaramos quatro variáveis do tipo int
        Console.WriteLine(a + d); // operação de soma
        Console.WriteLine(c - a); // operação de subtração
        Console.WriteLine(b * c); // operação de multiplicação
        Console.WriteLine(d / b); // operação de divisão
        Console.WriteLine(c % b); // operação de módulo (resto de divisão)
        Console.ReadKey();

    . Operadores Aritméticos de Atribuição Reduzida

        Operador Aritmético	    Descrição
        -------------------     ---------
            + =	                mais igual
            - =	                menos igual
            * =	                vezes igual
            / =	                dividido igual
            % =	                módulo igual

        Exemplos:

            int x = 5;
            x += 5; // é a mesma coisa que x = x + 5
            Console.WriteLine("Valor do x = " + x);
            Console.ReadKey();

    . Operadores incrementais e decrementais

        (++)    Incremento
        (--)    Decremento

        Exemplo:

            Console.WriteLine("Pré-Incremento:\n");

            int x = 0;
            Console.WriteLine("x = " + x);

            Console.WriteLine("\n++x +20 = \n");
            Console.WriteLine(++x +20 + "\n");

            Console.WriteLine("\nPós-Incremento:\n");
            x = 0;

            Console.WriteLine("\nx++ +20 = \n");
            Console.WriteLine(x++ + 20 + "\n");

            Console.WriteLine("\nPré-Decremento:\n");
            x = 0;

            Console.WriteLine("x = " + x);

            Console.WriteLine("\n--x +20 = \n");
            Console.WriteLine(--x + 20 + "\n");

            Console.WriteLine("\nPós-Decremento:\n");
            x = 0;

            Console.WriteLine("\nx-- +20 = \n");
            Console.WriteLine(x-- + 20 + "\n");

            Console.ReadKey();

    . Operadores Relacionais

        Operador Relacional	        Descrição
        -------------------         ---------
                ==	                Igual a
                !=	                Diferente de
                >	                Maior que
                <	                Menor que
                >=	                Maior do que ou igual a
                <=	                Menor do que ou igual a

        Exemplo:

            int a = 10, b = 25, c = 50, d = 100; // declaramos quatro variáveis de tipo int

            Console.WriteLine(a == d); // avaliamos a igualdade entre a e d
            Console.WriteLine(b != c);  // avaliamos a desigualdade entre b e c
            Console.WriteLine(a > b); // avaliamos se a é maior que b
            Console.WriteLine(c < d);  // avaliamos se c é menor que d
            Console.WriteLine(c >= a); // avaliamos se c é maior ou igual que a
            Console.WriteLine(d <= b); // avaliamos se d é menor ou igual que b

            Console.ReadKey();


    . Operadores Lógicos

        Operador Lógico	        Descrição
        ---------------         ---------
        &&	                    AND = E
        ||	                    OR = Ou
        !	                    NOT = Não

        Exemplo:

            int a = 5, b = 10, c = 15, d = 20; // declaramos quatro variáveis do tipo int

            Console.WriteLine(a == 5 && d == 10); // avaliamos se a é igual a 5 e se d é igual a 10
            Console.WriteLine(c < b || d == 20); // avaliamos se c é menor que b ou se d é igual a 20
            Console.WriteLine(! (b > a)); // negamos que b é maior que a

            Console.ReadKey();

    . Operadores Ternários

        . O operador ternário é composto por três operandos separados pelos sinais ? e : e tem o 
            objetivo de atribuir o valor a uma variável de acordo com o resultado de um teste lógico. 
            A sintaxe dele é: teste lógico ? valor se verdadeiro : valor se falso;

        . Exemplo

            int x = 5, y = 10; // declaradas duas variáveis de tipo int

            Console.WriteLine(x < y ? "sim" : "não"); // expressão x < y é avaliada
            // se for verdadeira exibe "sim"
            // se não for verdadeira exibe "não"
            Console.ReadKey();


Aula 30. If/Else (Se/Senão)
---------------------------

    Exemplo 1

        double media = 8;
        if (media >= 7)
        {
            Console.WriteLine("Aluno aprovado!");
        }
        else if (media < 7 && media >=5)
        {
            Console.WriteLine("Aluno em recuperação!");
        }
        else
        {
            Console.WriteLine("Aluno reprovado!");
        }

    Exemplo 2

        double media = 8;
        string resultado = "Olá aluno, você foi ";
        resultado += media >= 7 ? "aprovado." : "reprovado.";
        Console.WriteLine(resultado);


Aula 31. For (Para Cada)
------------------------

    Exemplo 1

        for (int contador = 0; contador < 5; contador++)
        {
            Console.WriteLine(contador);
        }

    Exemplo 2

        string[] nomes = { “André”, “Bruna”, “Carla”, “Daniel” };

        foreach (string nome in nomes)
        {
            Console.WriteLine(nome);
        }


Aula 32. While...Continue...Break (Enquanto)
--------------------------------------------

    Exemplo 1

       int a = 10;
         
         /* do loop execution */
         do {
            Console.WriteLine("value of a: {0}", a);
            a = a + 1;
         } 
         while (a < 20);

         Console.ReadLine();

    Exemplo 2: while / break

        int i = 1;
        while (i < 10)
        {
            if(i == 5)
                break;
                
            Console.WriteLine(i);
            i++;
        }

    Exemplo 3: while / continue

        int i = 0;
        while(i < 10){
            i++;
            
            if(i %2 == 0)
                continue;
            
            Console.WriteLine(i);
        }


Aula 33. Switch...Case (Caso)
-----------------------------

    Exemplo

        switch (mes)
        {
            case "Janeiro":
            case "Março":
            case "Maio":
            case "Julho":
            case "Agosto":
            case "Outubro":
            case "Dezembro":
                                Console.WriteLine("Este mês tem 31 dias");
                                break;
            case "Fevereiro":
                                Console.WriteLine("Este mês tem 28 ou 29 dias");
                                break;
            default:
                                Console.WriteLine("Este mês tem 30 dias");
                                break;
        }


Aula 35. Configurar Visual Studio Code para .NETCore
----------------------------------------------------

    . Acesse File / Preferences / Settings

    . Digite C#

    . Acesse "C# Configuration / CSharp Format Enabled" e habilite a configuração

    . Digite "Format on save" e habilite a configuração

    . Digite "Final" e habilite a configuração "Files: Insert final newline" e habilite a configuração


Aula 36. .NET Core Command-Line Interface (CLI)    
-----------------------------------------------

    . Digite no terminal "dotnet --info" para apresentar informações variadas da instação do dotnet

    . Digite no terminal "dotnet new" irá apresentar as várias possibilidades de criar diversos projetos, exemplo:

        dotnet new mvc

        dotnet run

        #Acesse o navegador e digite a URL: https://localhost:5001/ para ver o resultado do projeto criado.

    . Ctrl + C no terminal acaba com a execução do projeto:

https://www.infoq.com/br/articles/netcore-cli/    



Aula 37. Instalar pacotes através do Nuget.org
----------------------------------------------

    . Ao ser compilada, uma biblioteca gera um arquivo DLL. Será esta DLL que os outros projetos irão utilizar. 
        O NuGet aproveita desta característica da plataforma para definir seus pacotes.

    . Na prática, um pacote NuGet é um arquivo compactado com a extensão .nupkg que contém um código compilado (DLL), 
        outros arquivos relacionados a este código (como imagens, etc.) e um arquivo de configuração que contém 
        informações sobre o pacote, como: número de versão, criador, etc.

    . Estes pacotes .nupkg podem ser publicados em repositórios públicos ou privados, onde os desenvolvedores podem 
        consumi-los, adicionando-os em seus projetos e utilizando no código as funcionalidades que fornecerem.

    . Em se tratando de projeto, como se fosse as dependências de bibliotecas.

    . Acesse o site nuget.org, digite "Microsoft Entity Framework Core" e faça a pesquisa.

    . Acesse o item Microsoft.EntityFrameworkCore.

    . Acesse uma das versões, atualmente 5.0.5.
    
    . Acesse a aba .NetCli.

    . Copie o comando sugerido por esse caminho:

        dotnet add package Microsoft.EntityFrameworkCore --version 5.0.5

    . Acesse o terminal, vá na pasta do projeto e execute o comando acima. Cuidado é necessário acessar a pasta do projeto
        e não da solução, exemplo: ~/workspace-two/CSharpBasico/helloWorld.


    . Após a execução, no terminal, execute um dos comandos abaixo:

        dotnet restore

        ou

        dotnet build

    . Acesse o Visual Studio Code "code ." para entrar no projeto e acesse o arquivo com extensão "*.csproj". Podemos verificar 
        que agora temos o pacote dentro da aplicação:

        <ItemGroup>
            <PackageReference Include="Microsoft.EntityFrameworkCore" Version="5.0.5" />
        </ItemGroup>

    . Retorne ao Home do site nuget.org e digite "Pomelo Entity Framework core" e acesse o link do MySQL.

    . Acesse a aba "PackageReference" e copie o comando sugerido:

    . Acesse novamente o arquivo com a extensão *.csproj e insira a dependência copiada dentro do nó "ItemGroup":

        <ItemGroup>
            <PackageReference Include="Microsoft.EntityFrameworkCore" Version="5.0.5" />
            <PackageReference Include="Pomelo.EntityFrameworkCore.MySql" Version="5.0.0-alpha.2" />    
        </ItemGroup>

    . Salve o conteúdo do arquivo, o VsCode irá pedir para dar o "Restore", confirme o restore.

    . Se quiser podemos dar o "dotnet restore", ou o "dotnet build", no terminal.

    . Caso haja a necessidade de retirar alguma dependência do nó "ItemGroup", acesse o terminal, e execute os comandos abaixo:

        dotnet clean
        dotnet restore


Aula 39. Entity Framework Core
------------------------------

    . Entity Framework Core - EF é um ORM (Mapeador de Objeto Relacional), permite que os desenvolvedores trabalhem com um banco 
        de dados usando objetos em .Net, eliminando uma grande parte de código de acesso aos dados, como:

        SELECT, INSERT, UPDATE e DELETE
        WHERE 
        ORDER BY

Aula 40. API e Micro Service
---------------------------

    . API - Quando você desenvolve um sistema completo utilizando o mesmo banco de dados. Exemplo: Faturamento, estoque, vendas, etc.
        tudo no mesmo projeto. Você irá subir esta aplicação em uma instância e consegue escalar aumentando recursos. 

        . De uma perspectiva técnica, as APIs geralmente enviam dados por meio de solicitações HTTP. Estas retornam um arquivo de texto, 
            normalmente no formato JSON, que os desenvolvedores podem usar como quiserem. Os tipos de estilos de design da API incluem REST, 
            SOAP, GraphQL, gRPC e outros. Muitos usam formatos de especificação como OpenAPI, RAML ou AsyncAPI para definir interações de 
            API amigáveis para máquinas e humanos.

    . Micro Service - Quando você desenvolve um sistema distribuido utilizando vários banco de dados. Exemplo: 

        Faturamento, podemos criar um microservice e um banco de dados.
        Estoque, idem

        Neste caso conseguimos colocar cada microservice em instâncias difrentes e até mesmo escrever em linguagens diferentes e bancos
        diferentes.

        Caso precisemos que as aplicações se comuniquem, criaremos um orquestrador.

Aula 41. Rotas / REST / RESTfull
--------------------------------

    REST

        . Arquitetura REST propõe basicamente a padronização de rotas de API na comunicação cliente/servidor.

        . Requisições HTTP enviadas: http://site.com.br/objeto/ação e retornos de texto puro, ou dados, estruturados e serializados como JSON e XML.

    RESTfull

        . Sistemas API arquitetado com vistas a acessos REST e uso semântico dos métodos HTTP GET, POST, PUT, PATCH, DELETE são chamados RESTFUL.

        . RESTFUL endereça nomes de recursos junto a métodos HTTP para realizar operações.

    Principais métodos do protocolo HTTP

        . GET - Obter os dados de um recurso.

        . POST - Criar um novo recurso.

        . PUT - Alterar dados de um determinado recurso.

        . PATCH - Atualizar parcialmente um determinado rcurso.

        . DELETE - Excluir um determinado recurso.

    Exemplo de rotas:

        http://site.com.br/clientes (GET, POST)
        http://site.com.br/clientes/57 (GET, DELETE)


Aula 42. DDD - Domain Driven Design
-----------------------------------

    DDD (Domain-Driven Design) é uma abordagem de desenvolvimento de software em que o design é orientado pelo domínio, ou seja, pela área de conhecimento 
        à qual o software se aplica. Outra forma de dizer é: em DDD, o design da solução é orientado pelas regras de negócio.

        . Alinhamento do código com o negócio: o contato dos desenvolvedores com os especialista do domínio é algo essencial se faz DDD

        . Favorecer reutilização: os blocos de construção que facilitam aproveitar um mesmo conceito de domínio ou um mesmo código em vários lugares.

        . Mínimo de acoplamento: Com um modelo bem feito, organizado, as várias partes de um sistema interagem sem que haja muita dependência entre módulos 
            ou classes de objetos de conceitos distintos.

        . Independência da Tecnologia: DDD não foca em tecnologia, mas sim em entender as regras de negócio e como elas devem estar refletidas no código e
            no modelo de domínio. Não que a tecnologia usada não seja importante, mas essa não é uma preocupação de DDD.

Aula 43. Repositório do Curso no GitHub
---------------------------------------


    https://www.github.com/mfrinfo/curso_aspnetcore_api

    . Acessar "Switch branches or tags" para escolher a branch do curso, inicialmente iremos acesso a branch "PrimeiraFaseSemJWT".

    
Aula 44. Dica de como alterar a versão do AspNetCore em um novo Projeto
-----------------------------------------------------------------------

    . As configurações abaixo só funcionarão se houver mais de um SDK instalado no sistema operacional.

    . Acesse nosso diretório de projetos e crie as pastas abaixo:

        mkdir curso_api_netcore
        mkdir curso_api_netcore/src
        cd curso_api_netcore

    . No terminal digite o comando abaixo para verificar a versão dos SDKs disponível

        dotnet --list-sdks

    . Acesse o code e dentro da pasta curso_api_netcore/src crie o arquivo global.json

    . Coloque o conteúdo abaixo no arquivo global.json:

        {
            "sdk" : {
                "version" : "3.1.408"
            }     

        }

    . Acesse o terminal novamente, acesse a pasta curso_api_netcore/src e verifique a versão do SDK:

        dotnet --version

    . Acesse qualquer outra pasta e verifique novamente a versão

        dotnet --version

    . Se tudo der certo, teremos um SDK na pasta src diferente das outras pastas

    . Acesse a pasta src e digite o comando abaixo:

        dotnet new -n teste -o teste

    . Acesse a pasta do projeto teste dentro do VSCode e verifique o conteúdo do arquivo teste.csproj

        <Project Sdk="Microsoft.NET.Sdk.Web">

        <PropertyGroup>
            <TargetFramework>netcoreapp3.1</TargetFramework>
        </PropertyGroup>

        </Project>

    . Veja que o <TargetFramework> está configurado automaticamente para o SDK 3.1

    
Aula 45. Criar a Solution
-------------------------

    . Solução Asp.NET Core

        . SLN (Solution File)

        . A solução é apenas um container de um ou mais projetos relacionados, juntamente com informações
            de build.

            dotnet new --name <<nome>>

Aula 46. Aplicação (Application) - Criar e Adicionar uma Aplicação Web API
--------------------------------------------------------------------------

    . Acesse nosso diretório de projetos e crie as pastas abaixo:

        mkdir curso_api_netcore
        mkdir curso_api_netcore/src
        cd curso_api_netcore/src

    . Dentro da pasta curso_api_netcore/src crie a solução como abaixo:

        dotnet new sln --name API


    . Acesse o code e dentro da pasta curso_api_netcore/src crie o arquivo global.json

    . Coloque o conteúdo abaixo no arquivo global.json:

        {
            "sdk" : {
                "version" : "3.1.408"
            }     

        }


    . Dentro da pasta curso_api_netcore/src crie a solution:

        dotnet new webapi -n application -o Api.Application --no-https

    . Adicinar o projeto criado no passo anterior a solution:

        . Acesse a pasta curso_api_netcore/src

        . Digite o comando abaixo para realizar a associação:

            dotnet sln add Api.Application

    . Na pasta curso_api_netcore/src faça um build:

        dotnet build

    . Dentro da pasta src acesse o VSCode, ao entrar ele irá fazer uma pergunta para colocar o build e o debug no projeto,
        responda "Yes"

        code .

        . Ao responder "Yes", o VSCode ira criar uma pasta do projeto .vscode. Dentro desta pasta teremos dois arquivos
            ( launch.json e tasks.json). Esses arquivos criados automaticamente tem as configurações para depuração.

        . Podemos acessar a execução do projeto do icone com triângulo na barra vertical do VSCode, que surgira a "Side Bar".
            Neste ponto surgirá os botões de execução do projeto. 

        . Execute o projeto e no navegador execute a URL abaixo:

            http://localhost:5000/WeatherForecast

    
    . Pare a aplicação, e elimine os arquivos abaixo do projeto:

        /WeatherForecast.cs
        Controllers/WeatherForecastController.cs
        
    . No VSCode acesse a opção Terminal / Run Task... e escolha a opção "build"



Aula 47. Domínio (Domain) - Criar e Adicionar na Solution
---------------------------------------------------------

    . Acesse a pasta /src do seu projeto

    . Digite o comanda abaixo para verificar as opções do comando "classlib":

        dotnet new classlib --help

    . Digite o comando abaixo para criar a classlib:

        dotnet new classlib -n Domain -o Api.Domain -f netcoreapp3.1

    . Dentro da pasta "src" digite o comando abaixo para adicionar a pasta "Api.Domain" a solution:

        dotnet sln add ./Api.Domain/

        dotnet restore

    . Acesse a pasta Api.Domain e apague a classe Classe1.cs

    . Digite o comando abaixo:

        dotnet build

    . Opções para o comando abaixo "Ctrl+Shift+B", ou acesse a opção "Terminal / Run Build Task"



Aula 48. Infra Estrutura (Cross Cutting) - Criar e Adicionar na Solution     
------------------------------------------------------------------------

    . Cross Cutting é uma parte do projeto para conter bibliotecas de classes utilitárias 
        comum ao projeto para que possam ser reutilizadas em todo o projeto, exemplo: segurança,
        logging, caching, Authorization, Error handling and Auditing.

    . Acesse a pasta source e digite o comando abaixo:

        dotnet new classlib -n CrossCutting -f netcoreapp3.1 -o Api.CrossCutting

    . Dentro da pasta "src" adicone a pasta CrossCutting a solution:

        dotnet sln add ./Api.CrossCutting/

        dotnet build

    . Acesse a pasta Api.CrossCutting e apague a classe Classe1

    
Aula 49. Infra Estrutura (Data) - Criar e Adicionar na Solution
----------------------------------------------------------------

    . Acessar a pasta src e digitar o comando abaixo:

        dotnet new classlib -n Data -f netcoreapp3.1 -o Api.Data

    . Dentro da pasta "src" adicone a pasta CrossCutting a solution:

        dotnet sln add ./Api.Data/

    . Acesse a pasta Api.Data e apague a classe Classe1

    . Digite o comando abaixo:

        dotnet build


Aula 50. Serviço (Service) - Criar e Adicionar na Solution
----------------------------------------------------------

    . Acessar a pasta src e digitar o comando abaixo:

        dotnet new classlib -n Service -f netcoreapp3.1 -o Api.Service

    . Dentro da pasta "src" adicone a pasta CrossCutting a solution:

        dotnet sln add ./Api.Service/

    . Acesse a pasta Api.Service e apague a classe Classe1

    . Digite o comando abaixo:

        dotnet build


Aula 51. Overview da Arquitetura
--------------------------------

    . Através da classe Startup.cs do projeto Api.Application que a execução do projeto 
        começa.

    . Todos os projetos estão associados a solution, no arquivo API.sln



Aula 52. Api.Domain - Implementação BaseEntity
----------------------------------------------

    . No VSCode, clique com o botão direito sobre a pasta Api.Domain e crie as folder abaixo:

        Entities
        Interfaces

    . No VSCode, clique com o botão direito sobre a pasta Api.Domain.Entities e crie uma nova classe
        com o nome de "BaseEntity".

    . Dentro das chave da classe "BaseEntity" digite "prop" e tecle tab para criar uma propriedade.

        public Guid id { get; set; }

    . ABaixo da propriedade criada acima digite "propfull" e crie a propriedade abaixo:

        private DateTime? _createAt;
        public DateTime? CreateAt
        {       
            get { return _createAt;_} 
            set { _createAt  =  (value == null? DateTime.Utc : value); }
        }

        // O símbolo de interrogação é para dizer que a propriedade pode aceite null

    . ABaixo da propriedade criada acima digite "prop" e crie a propriedade abaixo:

        public DateTime? UpdateAt { get; set; }

    . Na propriedade Id coloque a annotation [Key]:

        [Key]
        public Guid Id { get; set; }

    . Deixe a classe BaseEntity como abstract:

        public abstract class BaseEntity
        {

    . No final a classe deverá ficar como abaixo:

        using System;
        using System.ComponentModel.DataAnnotations;

        namespace Api.Domain.Entities
        {
            public abstract class BaseEntity
            {
                [Key]
                public Guid Id { get; set; }

                private DateTime? _createAt;
                public DateTime? CreateAt
                {       
                    get { return _createAt; } 
                    set { _createAt  =  (value == null? DateTime.UtcNow : value); }
                }
                
                public DateTime? UpdateAt { get; set; }

            }
        }


Aula 53. Api.Domain - Implementação UserEntity
----------------------------------------------

    . Acesse a pasta Api.Domain.Entities e crie a classe UserEntity.cs como abaixo:

        namespace Api.Domain.Entities
        {
            public class UserEntity : BaseEntity
            {

                public string Nome { get; set; }

                public string Email { get; set; }
                
            }
        }



Aula 54. Api.Data - Instalação dos Pacotes (NuGet) para o Entity FrameWorkCore
------------------------------------------------------------------------------

    . Acesse a página https://www.nuget.org 

    . Pesquise as libraries abaixo e acesse o link de cada pesquisa. Para cada pesquisa, acesse a 
        aba PackageReference, copie a instrução de referência e cole-a dentro do arquivo Api.Data.Data.csproj
        
        . Importante selecione sempre a última versão da 3.x

        . Importante, adicione dentro do arquivo Data.csproj a tag abaixo para inserir as referências.

            <ItemGroup>
                ...
            </ItemGroup>

        . Pesquisa das libraries:

            Pesquisa : EntityFrameworkCore.SqlServer
            link : Microsoft.EntityFrameworkCore.SqlServer 
            reference : <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="3.1.14" />

            Pesquisa : Pomelo.EntityFrameworkCore.MySql
            link : Pomelo.EntityFrameworkCore.MySql 
            reference : <PackageReference Include="Pomelo.EntityFrameworkCore.MySql" Version="3.1.2" />

            Pesquisa : Microsoft.EntityFrameworkCore.Tools
            link : Microsoft.EntityFrameworkCore.Tools
            reference : 
                        <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="3.1.14">
                            <PrivateAssets>all</PrivateAssets>
                            <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
                        </PackageReference>
            observacao : SELECIONE DE PREFERENCIA SEMPRE A MESMA VERSION DA REFERENCIA SQLSERVER

            Pesquisa : Microsoft.EntityFrameworkCore.Design
            link : Microsoft.EntityFrameworkCore.Design
            reference : 
                        <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="3.1.14">
                            <PrivateAssets>all</PrivateAssets>
                            <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
                        </PackageReference>
    
    . Acesse a pasta /src/Api.Data e execute os comandos abaixo:

        dotnet restore

        dotnet tool install --global dotnet-ef

        dotnet ef  # Verificação se a ferramenta foi instalada com sucesso

    . Digite os comandos abaixo:

        dotnet restore

        dotnet build

    . Verifique se depois do "build" a aplicação compilou com zero erro.



Aula 55. Api.Data - Criar MyContext e Referenciar Api.Data com Api.Domain
-------------------------------------------------------------------------

    . Dentro da pasta Api.Data crie as pastas abaixo:

        Content
        Mapping
        Repository

    . No terminal e na pasta src faça a referência da pasta Api.Domain para a pasta Api.Data.

        dotnet add ./Api.Data/ reference ./Api.Domain/

        . Verifique no arquivo ./Api.Data/Data.csproj se existe uma referência ao projeto Api.Domain

    . Crie a classe MyContext.cs dentro da pasta ./Api.Data/Context como abaixo. O contexto que fará a conexão
        com o banco de dados.

        using Api.Domain.Entities;
        using Microsoft.EntityFrameworkCore;

        namespace Api.Data.Content
        {
            public class MyContext : DbContext
            {

            public DbSet<UserEntity> Users { get; set; }

                public MyContext(DbContext<MyContext> options) : base(options){  }

                protected override void OnModelCreating(ModelBuilder modelBuilder){
                    base.OnModelCreating(modelBuilder);
                }
            }
        }

Aula 56. Api.Data - Criar ContextFactory
----------------------------------------


. Criar a classe ContextFactory como abaixo:

    using Microsoft.EntityFrameworkCore.Design;
    using Microsoft.EntityFrameworkCore;

    namespace Api.Data.Content
    {
        public class ContextFactory : IDesignTimeDbContextFactory<MyContext>
        {
            
            public MyContext CreateDbContext( string[] args ){
                var connectionString = "Server=localhost;Port=3306;Database=desenv;Uid=marco;Pwd=brasil2";
                var optionBuilder = new DbContextOptionsBuilder<MyContext>();

                optionBuilder.UseMySql( connectionString );


                return new MyContext(optionBuilder.Options);
            }


        }
    }



Aula 57. Api.Data - Criar UserMap
---------------------------------

     Crie na pasta "mapping" a classe "UserMap" como abaixo:

        using Api.Domain.Entities;
        using Microsoft.EntityFrameworkCore;
        using Microsoft.EntityFrameworkCore.Metadata.Builders;

        namespace Api.Data.Mapping
        {
            public class UserMap : IEntityTypeConfiguration<UserEntity>
            {
                public void Configure(EntityTypeBuilder<UserEntity> builder)
                {

                    builder.ToTable("User");

                    builder.HasKey( u => u.Id );

                    builder.HasIndex( u => u.Email )
                        .IsUnique();

                    builder.Property( u => u.Name )
                            .IsRequered()
                            .HasMaxLength(60);

                    builder.Property( u => u.Email )
                            .HasMaxLength(100);




                }
            }
        }


    . Acesse a classe Api.Data.Content.MyContext.cs e altere o método "OnModelCreating" como abaixo:

        . Inclua a criação da tabela com o comando abaixo:

            modelBuilder.Entity<UserEntity>( new UserMap().Configure );

        . O método ficará da seguinte forma:

            protected override void OnModelCreating(ModelBuilder modelBuilder){
                base.OnModelCreating(modelBuilder);

                modelBuilder.Entity<UserEntity>( new UserMap().Configure );
            }



Aula 58. Api.Data - Criar Migrações e Atualização no Banco de Dados
-------------------------------------------------------------------


    . Resumo do funcionamento do Entity Framework:

        . O plugin "EF" responsável pelo ORM do .NET Core está registrado dentro do projeto Api.Data. 
        
        . Para saber a versão do "EF" do projeto digito o comando abaixo:

            dotnet ef --version

            # Para saber mais detalhes do comando dotnet ef digite o comando abaixo
            dotnet ef --help

        . Sequência de execução do ORM .NET Core:

            1. Criamos a classe Entity "UserEntity" que extende a classe BaseEntity. Quando formos criar a 
                tabela no banco de dados ela será criada com os mesmos campos das propriedades dessas classes.

                namespace Api.Domain.Entities
                {
                    public class UserEntity : BaseEntity
                    {

                        public string Nome { get; set; }

                        public string Email { get; set; }
                        
                    }
                }

                ....

                using System;
                using System.ComponentModel.DataAnnotations;

                namespace Api.Domain.Entities
                {
                    public abstract class BaseEntity
                    {
                        [Key]
                        public Guid Id { get; set; }

                        private DateTime? _createAt;
                        public DateTime? CreateAt
                        {
                            get { return _createAt; }
                            set { _createAt = (value == null ? DateTime.UtcNow : value); }
                        }

                        public DateTime? UpdateAt { get; set; }

                    }
                }

            2. Dentro da classe MyContext.cs adicionamos a propriedade abaixo fazendo referência a classe Entity

                public class MyContext : DbContext{

                    public DbSet<UserEntity> Users{ get; set }

                    ...
                }

            3. Dentro da mesma classe é feito a criação da tabela pela classe através do modelBuilder:

                public class MyContext : DbContext{

                    ...

                    protected override void OnModelCreating( ModelBuilder modelBuilder){

                        base.OnModelCreating(modelBuilder);

                        modelBuilder.Entity<UserEntity>(new UserMap().Configure);

                    }
                }

            4. A classe map auxilia ainda mais a configuração da classe Entity definindo tamanho do campo, obrigatoriedade, 
                indice, etc.

                using Api.Domain.Entities;
                using Microsoft.EntityFrameworkCore;
                using Microsoft.EntityFrameworkCore.Metadata.Builders;

                namespace Api.Data.Mapping
                {
                    public class UserMap : IEntityTypeConfiguration<UserEntity>
                    {
                        public void Configure(EntityTypeBuilder<UserEntity> builder)
                        {

                            builder.ToTable("User");

                            builder.HasKey(u => u.Id);

                            builder.HasIndex(u => u.Email)
                                    .IsUnique();

                            builder.Property(u => u.Nome)
                                    .IsRequired()
                                    .HasMaxLength(60);

                            builder.Property(u => u.Email)
                                    .HasMaxLength(100);
                        }
                    }
                }

            5. A classe ContextFactory faz a conexão com o banco:

                using Microsoft.EntityFrameworkCore.Design;
                using Microsoft.EntityFrameworkCore;

                namespace Api.Data.Content
                {
                    public class ContextFactory : IDesignTimeDbContextFactory<MyContext>
                    {
                        
                        public MyContext CreateDbContext( string[] args ){
                            var connectionString = "Server=localhost;Port=3306;Database=desenv;Uid=marco;Pwd=brasil2";
                            var optionBuilder = new DbContextOptionsBuilder<MyContext>();

                            optionBuilder.UseMySql( connectionString );


                            throw new System.NotImplementedException();
                        }


                    }
                }

    . Para que todas essas classes funcionem em conjunto e crie a tabela no banco temos que criar as classes "migration" com o
        comando abaixo. Isto na pasta raiz Api.Data:

        # UserMigrations é o nome que é data para a migração
        dotnet ef migrations add UserMigration

    . Para criar as novas tabelas no banco utilizaremos o comando abaixo, que usará as classes migrations para isso:

        donet ef database update



Aula 59. Api.Domain - Criar a Interface de Repository (IRepository)    
-------------------------------------------------------------------

    . Crie a interface abaixo em Api.Domain.Interfaces

        using System;
        using System.Collections.Generic;
        using System.Threading.Tasks;
        using Api.Domain.Entities;

        namespace Api.Domain.Interfaces
        {
            public interface IRepository<T> where T : BaseEntity
            {
                Task<T> InsertAsync( T item);

                Task<T> UpdateAsync( T item);

                Task<bool> DeleteAsync(Guid id);

                Task<T> SelectAsync( Guid id);

                Task<IEnumerable<T>> SelectAsync();
                    
            }
        }


Aula 60. Api.Data - Repositório Genérico Método InsertAsync
-----------------------------------------------------------

    . Crie dentro da pasta Api.Data.Repository a classe BaseRepository como abaixo:

        using System;
        using System.Collections.Generic;
        using System.Threading.Tasks;
        using Api.Data.Content;
        using Api.Domain.Entities;
        using Api.Domain.Interfaces;
        using Microsoft.EntityFrameworkCore;

        namespace Api.Data.Repository
        {
            public class BaseRepository<T> : IRepository<T> where T : BaseEntity
            {
                protected readonly MyContext _context;

                private DbSet<T> _dataSet;

                public BaseRepository(MyContext context)
                {
                    _context = context;
                    _dataSet = _context.Set<T>();

                }



                public Task<bool> DeletAsync(Guid id)
                {
                    throw new NotImplementedException();
                }

                public async Task<T> InsertAsync(T item)
                {
                    try
                    {
                        if (item.Id == Guid.Empty)
                        {
                            item.Id = Guid.NewGuid();
                        }

                        item.CreateAt = DateTime.UtcNow;

                        _dataSet.Add( item );

                        await _context.SaveChangesAsync();

                    }
                    catch (Exception ex)
                    {
                        
                        throw ex;
                    }

                    return item;

                }

                public Task<T> SelectAsync(Guid id)
                {
                    throw new NotImplementedException();
                }

                public Task<IEnumerable<T>> SelectAsync()
                {
                    throw new NotImplementedException();
                }

                public Task<T> UpdateAsync(T item)
                {
                    throw new NotImplementedException();
                }
            }
        }


Aula 61. Api.Data - Repositório Genérico Método UpdateAsync
-----------------------------------------------------------

    . Altere o método UpdateAsync como abaixo:


        ...
        public async Task<T> UpdateAsync(T item)
        {

            try
            {
                var result = await _dataSet.SingleOrDefaultAsync( p => p.Id.Equals(item.Id));

                if (result == null)
                    return null;

                item.UpdateAt = DateTime.UtcNow;
                item.CreateAt = result.CreateAt;

                _context.Entry(result).CurrentValues.SetValues(item);

                await _context.SaveChangesAsync();

            }
            catch( Exception ex)
            {
                throw ex;
            }

            return item;
        }
        ...


Aula 62. Api.Data - Repositório Genérico Método DeleteAsync
-----------------------------------------------------------

    . Altere o método DeleteAsync como abaixo:

        ...
        public async Task<bool> DeleteAsync(Guid id)
        {
            try
            {
                var result = await _dataSet.SingleOrDefaultAsync( p => p.Id.Equals(id));

                if (result == null)
                    return false;

                _dataSet.Remove(result);

                await _context.SaveChangesAsync();

                return true;
            }
            catch( Exception ex)
            {
                throw ex;
            }
        }
        ..
