Fundamentos ASP.NET 6 - Balta
-----------------------------

https://dotnettutorials.net/course/asp-net-core-web-api-tutorials/


Introdução e Minimal APIs
-------------------------

Aula 2. Rodando sua primeira App
--------------------------------

    . Acesse a pasta raiz de projetos e execute o comando abaixo:

        dotnet new web -o minhaApp -n MinhaApp -f net6.0

    . Acesse a pasta do projeto recém criado e execute o comando abaixo:

        dotnet run

    . Através do comando acima a aplicação web é levantada e o servidor web fica
        escutando a URL 127.0.0.1 ou "localhost" na porta "xxxx".

        . A porta no "dotnet 6" muda aleatoriamente, neste caso precisamos observar o loga
            da aplicação, logo após o comando "dotnet run", para ver a porta que foi escolhida.

        . Já no "dotnet 5" pra baixo, a porta é sempre "5001"

    . Acesse o navegador e acesse a URL abaixo:

        http://localhost:[porta]

        . Se tudo der certo o navegador apresentará a mensagem "Hello World!"


Aula 3. Entendendo os verbos HTTP
---------------------------------

https://www.tutorialspoint.com/http/index.htm

    . Principais métodos do protocolo HTTP

        . GET - Obter os dados de um recurso.

        . POST - Criar um novo recurso.

        . PUT - Alterar dados de um determinado recurso.

        . PATCH - Atualizar parcialmente um determinado rcurso.

        . DELETE - Excluir um determinado recurso.

    . Exemplo de rotas:

        http://site.com.br/clientes (GET, POST)
        http://site.com.br/clientes/57 (GET, DELETE)


Aula 4. HTTP Status Code
------------------------

    . Uma requisição é dividida em duas partes: Headers/Cabeçalho e Body/Corpo

        . Headers - Os cabeçalhos HTTP permitem que o cliente e o servidor passem informações 
                    adicionais com a solicitação ou a resposta HTTP. Um cabeçalho de solicitação é 
                    composto por seu nome case-insensitive (não diferencia letras maiúsculas e minúsculas), 
                    seguido por dois pontos ':' e pelo seu valor (sem quebras de linha). 
                    Espaços em branco antes do valor serão ignorados.

            Accept-Charset:     O cabeçalho de requisição HTTP Accept-Charset anuncia quais character encodings o 
                                cliente entende.

                                Por exemplo:    Accept-Charset: iso-8859-1
                                                Accept-Charset: utf-8, iso-8859-1;q=0.5
                                                Accept-Charset: utf-8, iso-8859-1;q=0.5, *;q=0.1

            Accept-Encoding:    indica qual codificação de conteúdo, usualmente um algoritmo de compressão, o cliente 
                                está apto a entender.

                                Por exemplo:    Accept-Encoding: gzip
                                                Accept-Encoding: compress
                                                Accept-Encoding: deflate
                                                Accept-Encoding: br
                                                Accept-Encoding: identity
                                                Accept-Encoding: *

                                                // Múltiplos algoritmos, com pesos baseados na sintaxe de quality value (en-US):
                                                Accept-Encoding: deflate, gzip;q=1.0, *;q=0.5

            Accept-Language:    Determina qual linguagem é entendida pelo cliente e qual a sua região de preferência.
                                
                                Por exemplo, Accept-Language: pt-br, en;q=0.9,*;q=0.8 diz que preferimos que o conteúdo 
                                esteja em português do Brasil ou inglês, caso a primeira opção não esteja disponível.

            Allow:              Lista quais métodos HTTP são aceitos pelo servidor para o recurso acessado.
                                
                                Essa lista pode variar de acordo com a página que estamos acessando.

                                Por exemplo, Allow: GET, POST, HEAD diz que a página acessada aceita apenas esses métodos.

            Authorization       O cabeçalho de requisição HTTP Authorization contém as credenciais para autenticar o agente de 
                                usuário com o servidor, geralmente o servidor responderá com um status 401 Unauthorized se não 
                                for possível fazer a autenticação, e com o cabeçalho WWW-Authenticate.

                                Sintaxe:

                                Authorization: <tipo> <credenciais>

                                Por exemplo:    Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l

            Content-Language:   É a forma do servidor dizer ao cliente quais linguagens estão disponíveis para o recurso atual.
            
                                Por exemplo, Content-Language: pt-br determina que apenas a linguagem português do 
                                Brasil está disponível.

                                A partir de Content-Language o cliente sabe como escolher o valor para Accept-Language.

            Cookie:             Contém o valor de um Cookie HTTP e é a forma do navegador enviar esse dado de volta 
                                ao servidor a cada requisição.

                                Uma vez que o HTTP é stateless, algumas vezes precisamos recorrer a esse mecanismo 
                                para saber se um usuário permanece logado ou tem sessão ativa, por exemplo.

                                Por exemplo, Cookie: PHPSESSID=298zf09hf012fh2; é o id da sessão criada pelo PHP. 
                                Através dela, o PHP pode determinar, no servidor, se duas requisições partiram de um mesmo computador.

            Content-Type:       Indica qual o tipo de mídia de um recurso.

                                A partir dele o navegador pode determinar se o conteúdo recebido na resposta é uma 
                                página HTML, imagem, áudio, vídeo, etc.

                                Por exemplo, Content-Type: text/html; charset=utf-8 indica que receberemos uma página em 
                                HTML na codificação de caracteres UTF-8.

            Expect

            From

            Host

            If-Match

            If-Modified-Since

            If-None-Match

            If-Range

            If-Unmodified-Since

            Max-Forwards

            Proxy-Authorization

            Range

            Referer

            TE

            User-Agent:         Contém uma string de identificação da aplicação, sistema operacional e distribuidor 
                                do software que fez a requisição.

                                Por exemplo, User-Agent: Googlebot/2.1 (+http://www.google.com/bot.html) diz que o Google quem 
                                disparou a requisição a fim de coletar dados para o seu mecanismo de busca.    

            . Exemplos de Headers de requisição:

                GET /hello.htm HTTP/1.1
                User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)
                Host: www.tutorialspoint.com
                Accept-Language: en-us
                Accept-Encoding: gzip, deflate
                Connection: Keep-Alive

                ------------------------------------------------------------------

                POST /cgi-bin/process.cgi HTTP/1.1
                User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)
                Host: www.tutorialspoint.com
                Content-Type: application/x-www-form-urlencoded
                Content-Length: length
                Accept-Language: en-us
                Accept-Encoding: gzip, deflate

                Connection: Keep-Alive
                licenseID=string&content=string&/paramsXML=string

                ------------------------------------------------------------------

                POST /cgi-bin/process.cgi HTTP/1.1
                User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)
                Host: www.tutorialspoint.com
                Content-Type: text/xml; charset=utf-8
                Content-Length: length
                Accept-Language: en-us
                Accept-Encoding: gzip, deflate
                Connection: Keep-Alive

                <?xml version="1.0" encoding="utf-8"?>
                <string xmlns="http://clearforest.com/">string</string>

        . Body      

            Ou "Request Body", ou corpo da requisição, é onde geralmente enviamos dados que queremos gravar no servidor.

            Não é muito utilizado em requisições do tipo GET, mas sim nas do tipo POST e PUT.

            É no corpo da requisição onde você envia dados de um formulário de cadastro em seu site, por exemplo.

    . Status Code Resumido:

        (100-199) - Respostas de informação 
        (200-299) - Respostas de sucesso 
        (300-399) - Redirecionamentos 
        (400-499) - Erros do cliente 
        (500-599) - Erros do servidor 

    . Status Code Detalhadamente: Todos que estão marcados com "*" são os que mais ocorrem.

        . Respostas informativas:

            *100 Continue                           - Essa resposta provisória indica que tudo ocorreu bem até agora e que o 
                                                      cliente deve continuar com a requisição ou ignorar se já concluiu o que gostaria.
            101 Switching Protocol                  - Esse código é enviado em resposta a um cabeçalho de solicitação Upgrade (en-US) pelo 
                                                      cliente, e indica o protocolo a que o servidor está alternando.
            102 Processing (WebDAV (en-US))         - Este código indica que o servidor recebeu e está processando a requisição, mas nenhuma 
                                                      resposta está disponível ainda.
            103 Early Hints                         - Este código tem principalmente o objetivo de ser utilizado com o cabeçalho Link, 
                                                      indicando que o agente deve iniciar a pré-carregar (en-US) recursos enquanto o servidor prepara uma resposta.

        . Respostas de sucesso:

            GET: O recurso foi buscado e transmitido no corpo da mensagem.
            HEAD: Os cabeçalhos da entidade estão no corpo da mensagem.
            PUT ou POST: O recurso descrevendo o resultado da ação é transmitido no corpo da mensagem.
            TRACE: O corpo da mensagem contém a mensagem de requisição recebida pelo servidor.

            **200 OK                                 - Estas requisição foi bem sucedida. O significado do sucesso varia de acordo com o método HTTP:
            **201 Created                            - A requisição foi bem sucedida e um novo recurso foi criado como resultado. Esta é uma tipica resposta 
                                                      enviada após uma requisição POST.
            *202 Accepted                           - A requisição foi recebida mas nenhuma ação foi tomada sobre ela. Isto é uma requisição não-comprometedora, 
                                                      o que significa que não há nenhuma maneira no HTTP para enviar uma resposta assíncrona indicando o resultado 
                                                      do processamento da solicitação. Isto é indicado para casos onde outro processo ou servidor lida com a requisição, 
                                                      ou para processamento em lote.
            *203 Non-Authoritative Information      - Esse código de resposta significa que o conjunto de meta-informações retornadas não é o conjunto exato 
                                                      disponível no servidor de origem, mas coletado de uma cópia local ou de terceiros. Exceto essa condição, 
                                                      a resposta de 200 OK deve ser preferida em vez dessa resposta.
            *204 No Content                         - Não há conteúdo para enviar para esta solicitação, mas os cabeçalhos podem ser úteis. O user-agent pode atualizar 
                                                      seus cabeçalhos em cache para este recurso com os novos.
            205 Reset Content                       - Esta requisição é enviada após realizanda a solicitação para informar ao user agent redefinir a visualização do 
                                                      documento que enviou essa solicitação.
            206 Partial Content                     - Esta resposta é usada por causa do cabeçalho de intervalo enviado pelo cliente para separar o download em vários fluxos.
            207 Multi-Status (WebDAV (en-US))       - Uma resposta Multi-Status transmite informações sobre vários recursos em situações em que vários códigos de status 
                                                      podem ser apropriados.
            208 Multi-Status (WebDAV (en-US))       - Usado dentro de um elemento de resposta <dav:propstat> para evitar enumerar os membros internos de várias ligações 
                                                      à mesma coleção repetidamente.
            226 IM Used (HTTP Delta encoding)       - O servidor cumpriu uma solicitação GET para o recurso e a resposta é uma representação do resultado de uma ou mais 
                                                      manipulações de instância aplicadas à instância atual.

        . Mensagens de redirecionamento:

            300 Multiple Choice                     - A requisição tem mais de uma resposta possível. User-agent ou o user deve escolher uma delas. Não há maneira 
                                                      padrão para escolher uma das respostas.
            *301 Moved Permanently                  - Esse código de resposta significa que a URI do recurso requerido mudou. Provavelmente, a nova URI será 
                                                      especificada na resposta.
            302 Found                               - Esse código de resposta significa que a URI do recurso requerido foi mudada temporariamente. Novas mudanças na 
                                                      URI poderão ser feitas no futuro. Portanto, a mesma URI deve ser usada pelo cliente em requisições futuras.
            303 See Other                           - O servidor manda essa resposta para instruir ao cliente buscar o recurso requisitado em outra URI com uma requisição GET.
            304 Not Modified                        - Essa resposta é usada para questões de cache. Diz ao cliente que a resposta não foi modificada. Portanto, o cliente 
                                                      pode usar a mesma versão em cache da resposta.
            *305 Use Proxy Deprecated               - Foi definida em uma versão anterior da especificação HTTP para indicar que uma resposta deve ser acessada por um proxy. 
                                                      Foi depreciada por questões de segurança em respeito a configuração em banda de um proxy.
            306 unused Deprecated                   - Esse código de resposta não é mais utilizado, encontra-se reservado. Foi usado numa versão anterior da especificação HTTP 1.1.
            307 Temporary Redirect                  - O servidor mandou essa resposta direcionando o cliente a buscar o recurso requisitado em outra URI com o mesmo método 
                                                      que foi utilizado na requisição original. Tem a mesma semântica do código 302 Found, com a exceção de que o user-agent 
                                                      não deve mudar o método HTTP utilizado: se um POST foi utilizado na primeira requisição, um POST deve ser utilizado na segunda.
            308 Permanent Redirect                  - Esse código significa que o recurso agora está permanentemente localizado em outra URI, especificada pelo cabeçalho 
                                                      de resposta Location. Tem a mesma semântica do código de resposta HTTP 301 Moved Permanently com a exceção de que o user-agent 
                                                      não deve mudar o método HTTP utilizado: se um POST foi utilizado na primeira requisição, um POST deve ser utilizado na segunda.

        . Respostas de erro do Cliente:

            **400 Bad Request                        - Essa resposta significa que o servidor não entendeu a requisição pois está com uma sintaxe inválida.
            **401 Unauthorized                       - Embora o padrão HTTP especifique "unauthorized", semanticamente, essa resposta significa "unauthenticated". Ou seja, 
                                                      o cliente deve se autenticar para obter a resposta solicitada.
            *402 Payment Required Experimental      - Este código de resposta está reservado para uso futuro. O objetivo inicial da criação deste código era usá-lo para sistemas 
                                                      digitais de pagamento porém ele não está sendo usado atualmente.
            *403 Forbidden                          - O cliente não tem direitos de acesso ao conteúdo portanto o servidor está rejeitando dar a resposta. Diferente do 
                                                      código 401, aqui a identidade do cliente é conhecida.
            **404 Not Found                          - O servidor não pode encontrar o recurso solicitado. Este código de resposta talvez seja o mais famoso devido à frequência 
                                                      com que acontece na web.
            *405 Method Not Allowed                 - O método de solicitação é conhecido pelo servidor, mas foi desativado e não pode ser usado.
            406 Not Acceptable                      - Essa resposta é enviada quando o servidor da Web após realizar a negociação de conteúdo orientada pelo servidor, 
                                                      não encontra nenhum conteúdo seguindo os critérios fornecidos pelo agente do usuário.
            407 Proxy Authentication Required       - Semelhante ao 401 porem é necessário que a autenticação seja feita por um proxy.
            408 Request Timeout                     - Esta resposta é enviada por alguns servidores em uma conexão ociosa, mesmo sem qualquer requisição prévia pelo cliente. Ela 
                                                      significa que o servidor gostaria de derrubar esta conexão em desuso. Esta resposta é muito usada já que alguns 
                                                      navegadores, como Chrome, Firefox 27+, ou IE9, usam mecanismos HTTP de pré-conexão para acelerar a navegação. Note também 
                                                      que alguns servidores meramente derrubam a conexão sem enviar esta mensagem.
            409 Conflict                            - Esta resposta será enviada quando uma requisição conflitar com o estado atual do servidor.
            410 Gone                                - Esta resposta será enviada quando o conteúdo requisitado foi permanentemente deletado do servidor, sem nenhum endereço de 
                                                      redirecionamento. É experado que clientes removam seus caches e links para o recurso. A especificação HTTP espera que este 
                                                      código de status seja usado para "serviços promocionais de tempo limitado". APIs não devem se sentir obrigadas a indicar que 
                                                      recursos foram removidos com este código de status.
            411 Length Required                     - O servidor rejeitou a requisição porque o campo Content-Length do cabeçalho não está definido e o servidor o requer.
            412 Precondition Failed                 - O cliente indicou nos seus cabeçalhos pré-condições que o servidor não atende.
            413 Payload Too Large                   - A entidade requisição é maior do que os limites definidos pelo servidor; o servidor pode fechar a conexão ou retornar um 
                                                      campo de cabeçalho Retry-After.
            414 URI Too Long                        - A URI requisitada pelo cliente é maior do que o servidor aceita para interpretar.
            415 Unsupported Media Type              - O formato de mídia dos dados requisitados não é suportado pelo servidor, então o servidor rejeita a requisição.
            416 Requested Range Not Satisfiable     - O trecho especificado pelo campo Range do cabeçalho na requisição não pode ser preenchido; é possível que o trecho esteja fora 
                                                      do tamanho dos dados da URI alvo.
            417 Expectation Failed                  - Este código de resposta significa que a expectativa indicada pelo campo Expect do cabeçalho da requisição não pode ser satisfeita 
                                                      pelo servidor.
            418 I'm a teapot                        - O servidor recusa a tentativa de coar café num bule de chá.
            421 Misdirected Request                 - A requisição foi direcionada a um servidor inapto a produzir a resposta. Pode ser enviado por um servidor que não está 
                                                      configurado para produzir respostas para a combinação de esquema ("scheme") e autoridade inclusas na URI da requisição.
            422 Unprocessable Entity (WebDAV (en-US)) - A requisição está bem formada mas inabilitada para ser seguida devido a erros semânticos.
            423 Locked (WebDAV (en-US))             - O recurso sendo acessado está travado.
            424 Failed Dependency (WebDAV (en-US))  - A requisição falhou devido a falha em requisição prévia.
            425 Too Early                           - Indica que o servidor não está disposto a arriscar processar uma requisição que pode ser refeita.
            426 Upgrade Required                    - O servidor se recusa a executar a requisição usando o protocolo corrente mas estará pronto a fazê-lo após o cliente atualizar 
                                                      para um protocolo diferente. O servidor envia um cabeçalho Upgrade (en-US) numa resposta 426 para indicar o(s) protocolo(s) requeridos.
            428 Precondition Required               - O servidor de origem requer que a resposta seja condicional. Feito para prevenir o problema da 'atualização perdida', onde um 
                                                      cliente pega o estado de um recurso (GET) , modifica-o, e o põe de volta no servidor (PUT), enquanto um terceiro modificou o 
                                                      estado no servidor, levando a um conflito.
            429 Too Many Requests                   - O usuário enviou muitas requisições num dado tempo ("limitação de frequência").
            431 Request Header Fields Too Large     - O servidor não quer processar a requisição porque os campos de cabeçalho são muito grandes. A requisição PODE ser submetida 
                                                      novemente depois de reduzir o tamanho dos campos de cabeçalho.
            451 Unavailable For Legal Reasons       - O usuário requisitou um recurso ilegal, tal como uma página censurada por um governo.

        . Respostas de erro do Servidor:

            **500 Internal Server Error             - O servidor encontrou uma situação com a qual não sabe lidar.
            501 Not Implemented                     - O método da requisição não é suportado pelo servidor e não pode ser manipulado. Os únicos métodos exigidos que servidores 
                                                      suportem (e portanto não devem retornar este código) são GET e HEAD.
            502 Bad Gateway                         - Esta resposta de erro significa que o servidor, ao trabalhar como um gateway a fim de obter uma resposta necessária 
                                                      para manipular a requisição, obteve uma resposta inválida.
            *503 Service Unavailable                - O servidor não está pronto para manipular a requisição. Causas comuns são um servidor em manutenção ou sobrecarregado. 
                                                      Note que junto a esta resposta, uma página amigável explicando o problema deveria ser enviada. Estas respostas devem 
                                                      ser usadas para condições temporárias e o cabeçalho HTTP Retry-After: deverá, se possível, conter o tempo estimado  
                                                      para recuperação do serviço. O webmaster deve também tomar cuidado com os cabeçalhos relacionados com o cache que são   
                                                      enviados com esta resposta, já que estas respostas de condições temporárias normalmente não deveriam ser postas em cache.
            504 Gateway Timeout                     - Esta resposta de erro é dada quando o servidor está atuando como um gateway e não obtém uma resposta a tempo.
            505 HTTP Version Not Supported          - A versão HTTP usada na requisição não é suportada pelo servidor.
            506 Variant Also Negotiates             - O servidor tem um erro de configuração interno: a negociação transparente de conteúdo para a requisição resulta em   
                                                      uma referência circular.
            507 Insufficient Storage                - O servidor tem um erro interno de configuração: o recurso variante escolhido está configurado para entrar em negociação   
                                                      transparente de conteúdo com ele mesmo, e portanto não é uma ponta válida no processo de negociação.
            508 Loop Detected (WebDAV (en-US))      - O servidor detectou um looping infinito ao processar a requisição.
            510 Not Extended                        - Exigem-se extensões posteriores à requisição para o servidor atendê-la.
            511 Network Authentication Required     - O código de status 511 indica que o cliente precisa se autenticar para ganhar acesso à rede.


    . A URL abaixo apresenta detalhadamento o funcionamento das chamadas HTTP no POSTMAN:

        https://learning.postman.com/docs/sending-requests/requests/    

Aula 5.  Como funciona um App ASP.NET
-------------------------------------

    . No .Net 6 a execução começa pela classe "Program.cs"

        // Construi a aplicação
        var builder = WebAppication.CreateBuilder(args);
        var app = builder.Build();

        // Mapea a rota para ser chamada na linha debaixo
        app.MapGet("/", () => "Hello World!");

        // Executa a aplicação e fica escutando e respondendo alguma chamada na porta do projeto
        app.Run();  

    . No .Net 6 a classe "Startup.cs" foi suprimida

    . No .Net 6 a estrutura da classe "Program.cs" foi alterada deixando equivalente ao apresentado acima.



Aula 6. Mapeando uma Requisição
-------------------------------

    . Na classe "Program.cs" temos a rota abaixo:

        app.MapGet("/", () => "Hello World!");
                         |
                         +----> Função anônima

    . A chamada acima resultará na URL:

        https://localhost:[porta]/

Aula 7. Funções Anônimas
------------------------

    . Na classe "Program.cs" temos a rota abaixo:

        app.MapGet("/", () => "Hello World!");
                         |
                         +----> Função anônima
    
    . Poderiamos construir a mesma função da seguinte forma:

        app.MapGet( "/", () => {
            return "Hello World!";
        });


Aula 8. Parâmetros
------------------

    . Na classe "Program.cs" altere a rota colocando o "StatusCode" com o objeto "Results"

        ..
        app.MapGet( "/", () => {
            return Results.Ok("Hello World");           // Linha alterada
        });
        ...

    . Inclua nova rota abaixo:

        ...
        app.MapGet( "/{nome}", (string nome) => {       // Linha alterada
            return Results.Ok($"Hello World {nome}");   // Linha alterada
        });
        ...

        ...
        app.MapGet( "/nome/{nome}", (string nome) => {  // Linha alterada
            return Results.Ok($"Hello World {nome}");   // Linha alterada
        });
        ...

    . Acesse o Postman e execute as URLs abaixo:

        https://localhost:[porta]/

        https://localhost:[porta]/Marco

        https://localhost:[porta]/nome/Marco


Aula 9. Serialização JSON
------------------------- 

    . Inclua as linhas abaixo na classe "Program.cs":

        ...
        // Linha inserida abaixo
        app.MapPost("/", (User user) => { 
            return Results.Ok( user );
        });    

        app.Run();

        // Classe inserida
        public class User{
            public int Id { get; set; }

            public string Username { get; set; }
        }

    . Acesse o Postman e execute a URL abaixo:

        Method: POST
        Url: https:localhost:[porta]/
        Body.raw: 
                    {
                        "id": 1,
                        "username": "MARCO"
                    }
        Type: JSON

        . Observe: Se o valor inteiro 1 chegará com sucesso ao backend.
                    Se os nomes propriedade minisculos serão convertidos automaticamente para dentro da classe.


MVC
---

Aula 10. Iniciando o Projeto
----------------------------

    . Acesse a pasta de projetos e execute o comando abaixo:

        dotnet new web -o Todo -f net6.0

    . Acesse o VSCode na pasta do projeto criado.

    . Cria a classe abaixo dentro da pasta "Model":

        namespace Todo.Models
        {
            public class TodoModel
            {
                public int Id { get; set; }
                public string? Title { get; set; }
                public bool Done { get; set; }
                public DateTime CreatedAt { get; set; }
            }
        }

Aula 11. Configurando o EF
--------------------------

    . ACesse a pasta raiz do projeto e execute os comandos abaixo:

        dotnet add package Microsoft.EntityFrameworkCore.Sqlite --version 6.0.8

        dotnet add package Microsoft.EntityFrameworkCore.Design --version 6.0.8

    . 

    . Crie a pasta "Data" e dentro dela crie a classe abaixo:

        using Microsoft.EntityFrameworkCore;
        using Todo.Models;

        namespace Todo.Data
        {
            public class AppDbContext : DbContext
            {
                public DbSet<TodoModel> Todos { get; set; }
                
                // public DbSet<TodoModel> Todos => Set<TodoModel>();

                protected override void OnConfiguring(DbContextOptionsBuilder options)
                    => options.UseSqlite("DataSource=app.db;Cache=Shared");
            }
        }

    . A forma como vinhamos trabalhando até o .NET 5, permitia a declaração dos contextos "public DbSet<TodoModel> ..." 
        na classe de contexto (AppDbContext) da forma abaixo:

        public DbSet<TodoModel> Todos { get; set; }

    . Já da versão .NET 6 em diante, ao fazer da forma acima, o compilador reclama/avisa "Que o objeto poderá ficar com um 
        valor nulo. Para resolver essa situação, temos que declarar de uma das duas formas os "DBSets" como abaixo:

        // Até .NET 5
        public DbSet<TodoModel> Todos { get; set; }

        ou 

        // A partir do .NET 6
        public DbSet<TodoModel> Todos => Set<TodoModel>();

    . Declarando DbSets no .NET 6 com a sintaxe do .NET 5, teremos muito trabalho para adaptar todo os códigos das classes que for utilizar o DBSet. 
        Devemos prepará-los para receber valores nulos:

        public DbSet<TodoModel>? Todos { get; set; }

        . Observe que devemos utilizar o operador (?) para informar ao compilador que o objeto poderá ser nulo. Resolve num primeiro 
            momento para a classe de Contexto (AppDbContext), porém nas classes seguintes que forem utilizar o contexto ocorrerá
            o mesmo problema de aviso de possível objeto nulo.

        . Nesse caso podemos declarar operadores de perdão nulo (!) para informar ao compilador que um valor nulo real. Por exemplo:

            return context.Todos!.ToList(); 

        . E também em outros lugares avisar ao compilar que o objeto poderá ser nulo:

            TodoModel? todo = context.Todos!.FirstOrDefault( x => x.Id == id );

            return todo!;

        . Um exemplo de um controller com a declaração nos moldes .NET 5 no .NET 6:

            namespace Todo.Controllers
            {
                [ApiController]
                [Route("[controller]/")]
                public class HomeController : ControllerBase
                {
                    [HttpGet]
                    public List<TodoModel> Get([FromServices] AppDbContext context )
                    {
                        return context.Todos!.ToList(); 
                    }

                    [HttpGet("{id:int}")]
                    public TodoModel GetById( [FromServices] AppDbContext context, [FromRoute] int id)
                    {
                        TodoModel? todo = context.Todos!.FirstOrDefault( x => x.Id == id );

                        return todo!;
                    }


                    [HttpPost]
                    public TodoModel Post( [FromServices] AppDbContext context, [FromBody] TodoModel model){
                        context.Todos!.Add(model);

                        context.SaveChanges();

                        return model;
                    }

                }
            }

    . IMPORTANTE: se quisermos continuar da forma como era antes no .NET5 sem nenhuma mudança, basta acessar o 
        arquivo "Todo.csproj" e alterar o parâmetro "<Nullable>enable</Nullable>" para "<Nullable>disable</Nullable>".
        Dessa forma a compilação ocorrerá no .NET 6 como era no 5, desconsiderando as msgs de warning.


Aula 12. Gerando o banco de dados 
---------------------------------

    . Verifique se o "ef" está instalado:

        dotnet ef

        . Caso não estiver execute o comando abaixo:

            dotnet tool install --global dotnet-ef --version 6.0.8   

    . Execute o comando abaixo dentro da pasta raiz do projeto:

        dotnet clean

        dotnet build

        dotnet ef migrations add CreationDatabase

        dotnet ef  database update

    . Verifique se foi criado a pasta "Migrations" dentro do projeto com as devidas classes.

    . Verifique se foi criado dentro do projeto um arquivo com o nome "app.db" que é o nosso BD SqLite.

Aula 13. Entendendo os Controllers
----------------------------------

    . Crie a pasta "Controllers" e dentro dela a classe abaixo:

        using Microsoft.AspNetCore.Mvc;
        using Todo.Data;
        using Todo.Models;

        namespace Todo.Controllers
        {
            [ApiController]
            public class HomeController : ControllerBase
            {
                [HttpGet]
                public String Get()
                {
                    return "Hello World";
                }
            }
        }


    . Diferença entre "Controller" e "ControllerBase":

        ...
        public class HomeController : ControllerBase
        ...

        . "ControllerBase" é a classe que representa toda a base do padrão MVC Controller. Já a "Controller" estende
            a "ControllerBase" e acrescenta alguns métodos destinados ao uso de páginas web:

                public abstract class Controller : ControllerBase
                {
                    public dynamic ViewBag { get; }
                    public virtual ViewResult View(object model) { }
                    // more View support stuff
                }

        . Quando for desenvolver APIs que retornam JSONs, estenda a classe "ControllerBase". Caso contrário, se
            a API for para retornar além de JSONs, como páginas web, estenda a classe "Controller",
            pois essa última tem  métodos a mais do que a "ControllerBase".

    . O que é a annotation "[ApiController]?

        https://wakeupandcode.com/api-controllers-in-asp-net-core/

    . Os nomes dos métodos se começarem com Get, Post, Put, Delete, Patch, etc, serão chamados automaticamente de acordo com o verbo http 
        solicitado pelo "client". Porém, é possível adicionar sufixos aos nomes dos métodos, desde que eles iniciem com o nome do verbo 
        HTTP (Get, Post, ...)

        HTTP Method 	Possible Web API Action Method Name 	                Usage
        -----------     -----------------------------------                     -----
        GET 	        Get()                                                   *any name starting with Get * 	Retrieves data.
                        get()
                        GET()
                        GetAllStudent()

        POST 	        Post()                                                  *any name starting with Post* 	Inserts new record.
                        post()
                        POST()
                        PostNewStudent()

        PUT 	        Put()                                                   *any name starting with Put* 	Updates existing record.
                        put()
                        PUT()
                        PutStudent()

        PATCH 	        Patch()                                                 *any name starting with Patch* 	Updates record partially.
                        patch()
                        PATCH()
                        PatchStudent()

        DELETE 	        Delete()                                                *any name starting with Delete* 	Deletes record. 
                        delete()
                        DELETE()
                        DeleteStudent()

    . Outra maneira de desenvolver os métodos das APIs sem a necessidade dos nomes dos métodos da classe serem os mesmos dos verbos HTTP, 
        seria tipificar os métodos com [HttpGet], [HttpPost], etc.


Aula 14. Rotas e Controllers
----------------------------

    . Acesse a classe "Program.cs" e comente a linha com o conteúdo "app.Map("/", () => "Hello World");"

    . Adicionando suporte a Controllers:

        . Adicione as linhas abaixo na classe "Program.cs":

            var builder = WebApplication.CreateBuilder(args);

            builder.Services.AddControllers();   // Linha inserida

            var app = builder.Build();

            app.MapControllers();               // Linha inserida

        . As linhas inseridas servem para publicar as rotas quando o projeto for levantado.

    . Acrescente no método "Get" a annotation "Route":

        ...
        [ApiController]
        public class HomeController : ControllerBase
        {
            [HttpGet]
            [Route("/")]
            public String Get()
            {
                return "Hello World";
            }
        }
        ...

    . No Postman e altere a chamada GET com a URL http://localhost:[porta]/

    . Acrescente a expressão "home" na classe a annotation "Route":

        ...
        [ApiController]
        [Route("home")]
        public class HomeController : ControllerBase
        {
            [HttpGet]
            [Route("/")]
            public String Get()
            {
                return "Hello World";
            }
        }
        ...

    . No Postman e altere a chamada GET com a URL http://localhost:[porta]/home/

        . Neste caso a request poderá ser chamada pela URL http://localhost:[porta]/home/

        . Podemos colocar o "Route(..)" na classe e neste caso todos os contexto declarados nos métodos
            serão acrescidos pelo primeiro pelo da classe e depois pelo do método:

        . Confrontar com a "Aula 3 - Entendendo as URL amigáveis." do curso "Uma visão completa do ASP.NET MVC"

    . Podemos compor o nome rota com o prefixo do nome da classe controller acrescente a expressão "[controller]" nas
        annotation "[Http...()]" ou "[Route()]":

        ...
        [ApiController]
        public class HomeController : ControllerBase
        {
            [HttpGet("[controller]/")]
            // ou [Route("[controller]/")]
            public String Get()
            ...

        . Em resumo, podemos definir a rota padrão deste controller seria:
                                                
                            [HttpGet("[controller]/")]
                                        ^
                                        | 
                                        |
            https://localhost:[porta]/home/
                                        |
                                        +---> [Home]Controller 

    . Acesse o Postman e crie uma chamada GET com a URL http://localhost:[porta]/home/


Aula 16.  Lendo itens do banco de dados
---------------------------------------

    . Adicione as linhas abaixo na classe "Program.cs":

        var builder = WebApplication.CreateBuilder(args);

        builder.Services.AddControllers();   

        builder.Services.AddDbContext<AppDbContext>();      // Linha inserida

        var app = builder.Build();

        app.MapControllers();               


        . A linha inserida servirá para fazermos injeção de dependência do objeto de conexão.

    . Acrescente no método "Get" da classe "HomeController" a injeção da nossa classe de conexão:

        // https://gutfrau.medium.com/how-to-bind-fromroute-and-frombody-into-one-model-in-net-5-be0730a77852

        ...
        [ApiController]
        [Route("[controller]/")]                         // Linha alterada
        public class HomeController : ControllerBase
        {
            [HttpGet]                              // Linha alterada
            public List<TodoModel> Get([FromService] AppDbContext context)       // Linha alterada
            {
                return context.Todos.ToList();              // Linha alterada
            }
        }
        ...

    . No Postman e altere a chamada GET com a URL http://localhost:[porta]/home/

        . O resultado será uma lista vazia.

            []

Aula 17. Criando um registro
----------------------------

    . Crie o método abaixo na classe "HomeController":

        []
        public TodoModel Post( [FromServices] AppDbContext context, [FromBody] TodoModel model){
            context.Todos.Add(model);

            context.SaveChanges();

            return model;
        }
    
    . No Postman crie uma chamada com os parâmetros abaixo:

        Method: POST
        URL: https://localhost:[porta]/home/
        Body.Json: true
        Body.raw:   {
                        "id": "1",
                        "Title": "Ir ao Supermercado",
                        "Done": True,
                        "CreatedAt": "2022-09-01T14:00:00"
                    }

    . No Postman, execute a chamada GET com a URL http://localhost:[porta]/home/

Aula 18. Atualizando e excluindo um registro
--------------------------------------------

    . Crie o método abaixo na classe "HomeController":

        [HttpGet("id:{int}")]
        public Todo GetById( [FromServices] AppDbContext context, [FromRoute] int id)
        {
            TodoModel todo = context.Todos.FirstOrDefault( x => x.Id == id );

            return todo;
        }

        . Observe que na annotation "HttpGet" do método foi utilizado como parâmetro "id:{int}". Isto força com que 
            exista uma URL com um parâmetro e restringe mais ainda com um tipo "int" que valida o parâmetro
            com um número inteiro. Caso for chamado essa url, porém com um parâmetro que não se enquadre num no. válido
            o próprio container .NET nem entra no método. Caso a chamada foi feita com sucesso o valor será passado
            automaticamente para o parâmetro da assinatura do método "Get([FromServices] AppDbContext context, [FromRoute] int id)"

            . Repare que o parâmetro da assinatura "id" está anotado com a annotation [FromRoute]. Este atributo faz com que o 
                Model Binder apenas vincule dados que são oriundos da rota de dados.

            . Poderiamos realizar a mesma configuração do parâmetro na annotation "HttpGet("id:{int}")" na annotation
                "Route("id:{int}")".

    . A lista de annotation possíveis na assinatura dos métodos são:

        . FromForm

            Este atributo faz com que o Model Binder utilize somente os dados recebidos do formulário enviado.

                public IActionResult Detail([FromForm] ProdutoViewModel produtoViewModel) => View(produtoViewModel);

        . FromRoute

            Este atributo faz com que o Model Binder apenas vincule dados que são oriundos da rota de dados

                public IActionResult Detail([FromRoute] int id) => View();

        . FromQuery

            Este atributo diz ao Model Binder para receber apenas os dados da cadeia de consulta (querystring).

                public IActionResult Detail([FromQuery] int id) => View();

                . Se fizermos uma solicitação com a URL:  Produto/Detalhe/2?Id=4 . O valor 4 será vinculado e não o 
                    valor 2 conforme seria previsto no comportamento padrão.

        . FromHeader

            Este atributo diz ao Model Binder para vincular os valores que vêm no cabeçalho da requisição HTTP.

        . FromBody

            Este atributo diz ao Model Binder para vincular dados a partir do Body do request.

                public IActionResult Detail([FromBody] ProdutoViewModel produtoViewModel) => View(produtoViewModel);

        . FromServices

            Este atributo vincula o valor especificado à implementação que foi configurada no seu container de injeção de dependência.

            public IActionResult Detail([FromServices] IPrintable printer) => View();

        . Bind e BindNever    

            Este atributo vincula o valor especificado à implementação que foi configurada no seu container de injeção de dependência.

            O atributo BindNever diz ao model binder que não deve vincular o atributo especificado.

            Como você pode ver no trecho de código abaixo, IsAdminUser nunca será vinculado.

            Esta abordagem pode ser chamada de propriedades de lista negra, o que não é uma boa prática de segurança.

            É melhor listar os atributos que queremos vincular usando o atributo Bind, deixando de fora os que não queremos, 
            como você pode ver no exemplo:
            
                BindNever
                ---------
                public class ProdutoViewModel
                {
                    [FromQuery]
                    public int ProdutoId { get; set; }
                    public string ProdutoName { get; set; }
                    [BindNever]
                    public string IsAdminUser { get; set; }
                }	

                Bind
                ----
                [Bind(nameof(ProdutoId), nameof(ProdutoNome))]
                public class ProdutoViewModel
                {
                    [FromQuery]
                    public int ProdutoId { get; set; }
                    public string ProdutoNome { get; set; }
                    public string IsAdminUser { get; set; }
                }

    . No Postman, execute a chamada GET com a URL http://localhost:[porta]/home/1

    . Inclua os métodos abaixo na classe "HomeController.cs":

        ...
        [HttpPut("{id:int}")]
        public TodoModel Put([FromServices] AppDbContext context, [FromRoute] int id, [FromBody] TodoModel todo )
        {

            var model = context.Todos.FirstOrDefault( x => x.Id == id );

            if ( model == null ){
                return model;
            }

            model.Title = todo.Title;
            model.Done = todo.Done;

            context.Todos.Update( model );

            context.SaveChanges();

            return model;
        }

        [HttpDelete("{id:int}")]
        public TodoModel Delete( [FromServices] AppDbContext context, [FromRoute] int id )
        {
            var model = context.Todos.FirstOrDefault( x => x.Id == id );

            context.Todos.Remove( model );

            context.SaveChanges();

            return model;
        }

Aula 19. Testando a API
-----------------------

    . Reinicie a aplicação 

    . No Postman crie uma chamada com os parâmetros abaixo:

        Method: PUT
        URL: https://localhost:[porta]/1
        Body.Json: true
        Body.raw:   {
                        "Title": "Ir a Acadêmia",
                        "Done": false
                    }

    . No Postman, execute a chamada GET com a URL http://localhost:[porta]/1

    . No Postman crie uma chamada com os parâmetros abaixo:

        Method: DELETE
        URL: https://localhost:[porta]/1

    . No Postman, execute a chamada GET com a URL http://localhost:[porta]/1

Aula 20. Melhorando a API
-------------------------

    . Tipos de Retornos de StatusCode:

        ApiController Method    Description
        --------------------    -----------

        BadRequest() 	        Creates a BadRequestResult object with status code 400.
        Conflict() 	            Creates a ConflictResult object with status code 409.
        Content() 	            Creates a NegotiatedContentResult with the specified status code and data.
        Created() 	            Creates a CreatedNegotiatedContentResult with status code 201 Created.
        CreatedAtRoute() 	    Creates a CreatedAtRouteNegotiatedContentResult with status code 201 created.
        InternalServerError()   Creates an InternalServerErrorResult with status code 500 Internal server error.
        NotFound() 	            Creates a NotFoundResult with status code404.
        Ok() 	                Creates an OkResult with status code 200.
        Redirect() 	            Creates a RedirectResult with status code 302.
        RedirectToRoute() 	    Creates a RedirectToRouteResult with status code 302.
        ResponseMessage() 	    Creates a ResponseMessageResult with the specified HttpResponseMessage.
        StatusCode()         	Creates a StatusCodeResult with the specified http status code.
        Unauthorized() 	        Creates an UnauthorizedResult with status code 401. 

    . Altere o retorno do método abaixo, para adicionar recursos de "StatusCode":

        ...
        [ApiController]
        public class HomeController : ControllerBase
        {
            [HttpGet("/")]
            public IActionResult Get([FromService] AppDbContext context)       // Linha alterada
            {
                return Ok(context.Todos.ToList());              // Linha alterada
            }
        }
        ...

    . 3 formas mais comuns de retornar dados a partir de uma Web API:

        . Retornando um tipo específico

            . A forma mais simples e direta de retornar valores de uma API é retornar um tipo específico

                ...
                [HttpGet("/")]
                public List<TodoModel> Get([FromService] AppDbContext context)       // Retorno simples sem StatusCode
                {
                    return context.Todos.ToList();              // Retorno simples sem StatusCode
                }

            . Neste exemplo, a Action Get() retorna um tipo conhecido, ou seja, uma lista de objetos Produto.

            . Essa abordagem é adequada se você simplesmente deseja retornar dados para o cliente sem considerar 
                condições inesperadas, como exceções e códigos HTTP, como 404 e 200.

        . Retornando IActionResult

            . Agora quando o seu valor de retorno for uma mistura de dados e códigos HTTP, você não pode usar a 
                abordagem anterior. Assim se  você deseja retornar NotFoundResult ou OkResult ou ObjectResult, 
                não poderá usar a abordagem anterior.

            . Nesse caso, você pode retornar os valores como IActionResult. Considere o seguinte exemplo:

                public IActionResult Get([FromService] AppDbContext context)       // Retorno de dados com o StatusCode
                {
                    return Ok(context.Todos.ToList());              // Retorno de dados com o StatusCode
                }

        . Retornando ActionResult<T>

            . O tipo chamado ActionResult<T>, permite que você retorne o tipo do response ou qualquer resultado da Action, 
                enquanto ainda indica o tipo do response.

            . Assim, o ActionResult<T> permite combinar as duas abordagens discutidas anteriormente. Você pode retornar 
                um tipo derivado de ActionResult ou um tipo específico. Considere o exemplo a seguir usando a Action Get():

                [HttpGet("{id}")]
                public ActionResult<Produto> Get(string id)
                {	
                    Produto prod = _context.Produtos.Find(id);
                
                    if (prod == null)
                    {
                        return NotFound();
                    }		
                    
                    return prod;
                }

            . Como você pode ver, não é necessário envolver o objeto prod em Ok() ou ObjectResult. Você pode retornar 
                NotFoundResult ou ActionResult<Produto>.

    . Altere o método "GetById" como abaixo:

        [HttpGet("id:{int}")]
        public IActionResult GetById( [FromServices] AppDbContext context, [FromRoute] int id)
        {
            TodoModel todo = context.Todos.FirstOrDefault( x => x.Id == id );

            if ( todo == null )
            {
                return NotFound();
            }

            return Ok(todo);
        }

    . Altere o método "Post" como abaixo:

        [HttpPost]
        public IActionResult Post( [FromServices] AppDbContext context, [FromBody] TodoModel model){
            context.Todos.Add(model);

            context.SaveChanges();

            return Created($"/{todo.Id}", model);
        }

        . O "ActionResult" "Created" pode retornar dois parâmetros para a resposta HTTP:

            . Um link contendo uma URL que retorne o objeto trabalhado, por exemplo:

                return Created($"http://localhost:7054/home/{model.Id}", model);

                . O link fará parte da Header.Localion da resposta HTTP

            . Um objeto model, onde as informações dele aparecerá no Body da resposta.

    . Altere o método "Put" como abaixo:

        ...
        [HttpPut("/{id:int}")]
        public IActionResult Put([FromServices] AppDbContext context, [FromRoute] int id, [FromBody] TodoModel todo )   // Linha alterada
        {

            var model = context.Todos.FirstOrDefault( x => x.Id == id );

            if ( model == null ){
                return NotFound();  // Linha alterada
            }

            model.Title = todo.Title;
            model.Done = todo.Done;

            context.Todos.Update( model );

            context.SaveChanges();

            return Ok(model);
        }

    . Altere o método "Delete" como abaixo:

        [HttpDelete("/{id:int}")]
        public IActionResult Delete( [FromServices] AppDbContext context, [FromRoute] int id )
        {
            var model = context.Todos.FirstOrDefault( x => x == id );

            if ( model == null ){
                return NotFound();
            }

            context.Todos.Remove( model );

            context.SaveChanges();

            return Ok(model);
        }


CRUD e Entity Framework
-----------------------

Aula 21. Criando o projeto
--------------------------

    . Acesse a pasta raiz de projeto e execute o comando abaixo:

        dotnet new web -o Blog -f net6.0

Aula 22. Adicionando suporte ao Entity Framework
------------------------------------------------

    . Acesse o projeto do link abaixo e faça o download dele:

        https://github.com/balta-io/2808

    . Abra o projeto que está em zip, acesse a pasta "src/Modulo3" e copia as pastas "Data" e "Models" 
        para dentro do projeto "Blog".

    
    . Acesse a raiz do projeto "Blog" e execute os comandos abaixo:

        dotnet add package Microsoft.EntityFrameworkCore.SqlServer --version 6.0.2

        dotnet add package Microsoft.EntityFrameworkCore --version 6.0.2

        dotnet add package Microsoft.EntityFrameworkCore.Design --version 6.0.2

    . Acesse a classe "BlogDataContext.cs" e altere a string de conexão apontando para o "Database=Blog".

    . Acesse a classe "Blog.csproj" e faça a alteração abaixo:

        <Nullable>disable</Nullable>

        . IMPORTANTE: Essa diretiva desabilita a mensagem de "warning" de valore nulos dentro do projeto.

    . Acesse a pasta raiz do projeto e digite os comandos abaixo:

        dotnet clean

        dotnet build

        . Pode ser que dê alguns erros de "warning", mas pode desconsiderá-los por enquanto.

Aula 23. Criando o banco de dados
---------------------------------

    . Acesse a pasta raiz do projeto e execute o comando abaixo:

        dotnet ef migrations add CreationDatabase

        dotnet ef database update

Aula 24. Iniciando os Controllers
---------------------------------  

    . Acesse a classe "Program.cs" e comente a linha com o conteúdo "app.Map("/", () => "Hello World");"

    . Adicionando suporte a Controllers:

        . Adicione as linhas abaixo na classe "Program.cs":

            using Blog.Data;            // Linha inserida

            var builder = WebApplication.CreateBuilder(args);

            builder.Services.AddControllers();   // Linha inserida

            builder.Services.AddDbContext<BlogDataContext>();  // Linha inserida

            var app = builder.Build();

            app.MapControllers();               // Linha inserida

            // app.Map("/", () => "Hello World");   // Linha comentada

        . As linhas inseridas servem para publicar as rotas quando o projeto for levantado.

    . Crie a pasta "Controllers" dentro da raiz do projeto e cria a classe "HomeController" dentro dela:

        using Microsoft.AspNetCore.Mvc;

        namespace Blog.Controllers
        {
            [ApiController]
            [Route("")]
            public class HomeController : ControllerBase
            {
                // Poderia adotar o padrão [HttpGet("health-check")]
                [HttpGet("")]   
                public IActionResult Get()
                {
                    return Ok("Hello");
                }
            }
        }

    . Existe uma técnica para verificar se a API está ativa. Sempre deixamos uma rota para essa finalidade, conhecida como
        "health-check" quer retornará somente um StatusCode 201 "Ok()":

    . Acesse o Postman e execute a URL abaixo:

        Method: GET
        URL: https://localhost:[porta]/

Aula 25. Nomeando um Endpoint
-----------------------------

    . Crie a classe "CategoryController" na pasta "Controllers" com o código abaixo:

        using Microsoft.AspNetCore.Mvc;

        namespace Blog.Controllers{

            [ApiController]
            public class CategoryController: ControllerBase{

                [HttpGet("[controller]")]
                public IActionResult Get([FromServices] BlogDataContext context){

                    var categories = context.Categories.ToList();

                    return Ok( categories );

                }

            }
        }    

Aula 26. Versionamento
----------------------

    . Devemos sempre criar uma versão da sua API para garantir que os desenvolvedores tenham uma maneira clara e concisa de 
        se comunicar com uma API em constante mudança e atualizada.

    . Como fazer a versão:

        . Existem três maneiras possíveis de criar uma versão adequada de uma API:

            . URL, também conhecido como versão de path (URI).
                
                Exemplo: /v2/products/product-name)

                . Muito mais claro e simples para o usuário qual API ele está acessando, permitindo que o usuário consulte 
                    a documentação correta

            . Controle de versão por meio de um header customizado.

                Exemplo: Accept-Version: v2.

            . Parâmetro por Query string.

                Exemplo /products/product-name?version=v2.    

    . A opção mais indicada a ser usada é a URL. Neste caso, existem pelo menos dois códigos de status HTTP de redirecionamento 
        apropriados para cenários de controle de versão de API:

        . 301 Moved permanently

            . Indicando que o recurso com um URI solicitado é movido permanentemente para outro URI (que deve ser um link 
                permanente de instância de recurso que não contém informações de versão da API). Este código de status 
                pode ser usado para indicar uma versão de API obsoleta / sem suporte, informando ao cliente de API que 
                um URI de recurso com versão foi substituído.

            . Requisição do cliente

                GET /index.php HTTP/1.1
                Host: www.example.org

            . Resposta do servidor

                HTTP/1.1 301 Moved Permanently
                Location: http://www.example.org/index.asp

        . 302 not found

            . Indicando que o recurso solicitado está temporariamente localizado em outro local, enquanto o URI 
                solicitado ainda pode ser suportado. Este código de status pode ser útil quando os URIs sem 
                versão estão temporariamente indisponíveis e uma solicitação deve ser repetida usando o endereço 
                de redirecionamento.

            . Requisição do cliente

                GET /index.php HTTP/1.1
                Host: www.example.org

            . Resposta do servidor

                HTTP/1.1 302 Found
                Location: http://www.example.org/domains/example/

    . Se precisarmos construir uma nova versão de uma rota, podemos implementar a nova rota de várias maneiras:

        . Acrescentar uma codificação na rota "v1, v2, v3,..."

            . No "Route" da API:

                ...
                [ApiController]
                [Route("v1")]
                public class CategoryController: ControllerBase{

                [HttpGet("[controller]")]
                public IActionResult Get([FromServices] BlogDataContext context){
                ...

            . No "Get" do método:

                ...
                [ApiController]
                public class CategoryController: ControllerBase{

                [HttpGet("v1/[controller]")]
                // [Route("v1/[controller]")]
                public IActionResult Get([FromServices] BlogDataContext context){
                ...
    . Altere o método "Get" e crie o método "Get2" como abaixo na classe "HomeController":

        [HttpGet("v1/[controller]")]
        public IActionResult Get([FromServices] BlogDataContext context){
            return  Redirect(~/v2/home");
        }
    
        [HttpGet("v2/[controller]")]
        public IActionResult Get([FromServices] BlogDataContext context){
            return  Ok("Hello");
        }
            
    . Acesse o Postman e execute as rotas acima.

https://procodeguide.com/programming/redirect-a-request-in-aspnet-core/#:~:text=The%20redirect%20method%20is%20used,a%20string%20in%20the%20input.

Aula 27.  Async e Await
-----------------------

    . async     - Significa que o método será executado assincronamente.

    . await     - Significa que irá aguardar a execução do método especificado como "await" para sair do método pai/chamador

    . Para ativar os métodos "ToListAsync()", "FirstOrDefaultAsync", e todos que terminam com "...Async" é necessário importar a biblioteca abaixo:

        using Microsoft.EntityFrameworkCore;

    . A maioria dos métodos existe a versão assíncrona:

        // Versão síncrona
        var categories = context.Categories.ToList();

        // Versão assíncrona
        var categories = context.Categories.ToListAsync();

    . No caso dos métodos assíncronos o retorno será uma tarefa "Task"

        // Retorna um Task<List<Models.Category>>
        var categories = context.Categories.ToListAsync();

        . Task são tarefas a serem executadas em paralelo. Se houvesse várias chamadas assíncronas
            em cada uma delas não aguardaria a finalização do método para ir ao próximo, colocaria 
            todos para executar em paralelo.

            // As 4 chamadas serão executadas de uma vez
            var categories1 = context.Categories.ToListAsync();
            var categories2 = context.Categories.ToListAsync();
            var categories3 = context.Categories.ToListAsync();
            var categories4 = context.Categories.ToListAsync();
    
    . Para transformar um método em assíncrono precisamos:

        . Configurar o método chamador com o tipo "async" e nesse caso ele se torna assíncrono também.

            [HttpGet("[controller]")]
            public async IActionResult GetAsync([FromServices] BlogDataContext context){
                     |                    -----
                     |                      |
                     +--> Configuração      +----> Por convenção, qdo utilizamos "async" no método, o nome 
                          do método como           dele também é batizado como "Async"
                          "async"
                  
        . O método deve ser configurado como "Task<T>.

            [HttpGet("[controller]")]
            public async Task<IActionResult> GetAsync([FromServices] BlogDataContext context){
                            |
                            +---> Substituição de "IActionResult" para "Task<IActionResult>"

        . Configurar as chamadas internas do método como "await":

            . Implemente o método abaixo na classe "CategoryController":

                [HttpGet("v1/[controller]")]
                public async Task<IActionResult> GetAsync([FromServices] BlogDataContext context){

                    try
                    {
                        var categories = await context.Categories.ToList();
                                        |
                                        +--> Informa ao .NET para aguardar o fim da execução do método assincrono 
                                                para dar o retorno abaixo. Caso tivemos outras chamadas assincronas,
                                                todas serão chamadas em paralela, mas só dará o "return Ok()" quando 
                                                a última chamada com "await" terminar.

                        return Ok( categories );
                    }catch( Exception ex )
                    {
                        return StatusCode(500, "Falha interna do servidor");
                    }
                }

            . Acesse o Postman e faça o teste da rota acima.

                url: https://localhost:7122/v1/category
                method: GET

Aula 28. CRUD de Categorias
---------------------------

    . Implemente o método abaixo na classe "CategoryController":

        [HttpGet("v1/[controller]/{id:int}")]
        public async Task<IActionResult> GetByIdAsync([FromServices] BlogDataContext context,
                                                        [FromRoute] int id){
            try
            {
                var category = await context.Categories.
                                            .FirstOrDefaultAsync( x => x.Id == id );

                if ( category == null ) {
                    return NotFound();
                }

                return Ok( category );
            }catch( Exception ex )
            {
                return StatusCode(500, "Falha interna do servidor");
            }
        }


        [HttpPost("v1/[controller]")]
        public async Task<IActionResult> PostAsync( [FromServices] BlogDataContext context,
                                                    [FromBody] Category model )
        {
            try
            {
                await context.Categories.AddAsync( model );

                await context.SaveChangesAsync();

                return Created( $"v1/[controller]/{model.id}", model );
            }catch( DbUpdateException ex )
            {
                return StatusCode(500, "Falha interna do servidor");
            }
            }catch( Exception ex )
            {
                return StatusCode(500, "Falha interna do servidor");
            }

        }

        [HtttPut("v1/[controller]/{id:int}")]
        public async Task<IActionResult> PutAsync( [FromServices] BlogDataContext,
                                                    [FromRoute] id int,
                                                    [FromBody] Category model)
        {

            try
            {
                var category = context.Categories
                                        .FirstOrDefaultAsync( x => x == id);

                category.Name = model.Name;
                category.Slug = model.Slug;

                // IMPORTANTE: O método "Update" não tem "Async"
                context.Categories
                        .Update( category );

                await context.SaveChangesAsync();

                return Created($"v1/[controller]/{category.id}", category);     // Verificar se funciona o Created para método "Put"
            }catch( DbUpdateException ex )
            {
                return StatusCode(500, "Não foi possível alterar a categoria");
            }
            }catch( Exception ex )
            {
                return StatusCode(500, "Falha interna do servidor");
            }
        }

        [HttpDelete("v1/[controller]/{id:int})]
        public async Task<IActionResult> DeleteAsync( [FromServices] BlogDataContext context, 
                                                        [FromRoute] id int)
        {
            try
            {
                var category = await context.Categories
                                        .FirstOrDefaultAsync( x => x.Id == id );

                if ( category == null )
                {
                    return NotFound();
                }

                // Importante: O método "Remove" não tem "Async"
                context.Categories
                        .Remove( category );

                await context.SaveChangesAsync();

                return Ok();
            }catch( DbUpdateException ex )
            {
                return StatusCode(500, "Não foi possível apagar a categoria");
            }
            }catch( Exception ex )
            {
                return StatusCode(500, "Falha interna do servidor");
            }
        }

    . Procure mais informações sobre "CreatedAtAction" e "CreatedAtRoute"

Aula 29. Testando API
---------------------

    . Acesse a raiz do projeto, no prompt do SO, digite os comandos abaixo:

        dotnet clean

        dotnet build

        dotnet watch run

    . Acesse o Postman e execute as URLs abaixo:

        // Este teste dará erro que será tratado na proxima aula

        url: https://localhost:[porta]/categories
        method: POST
        Body.raw: true
        Body.raw.json: true
        Body:   {
                    "Name": "Backend",
                    "Slug": "backend",
                    "Posts": []
                }

        url: https://localhost:[porta]/categories
        method: GET

        url: https://localhost:[porta]/categories/1
        method: PUT
        Body.raw: true
        Body.raw.json: true
        Body:   {
                    "Name": "Forehand",
                    "Slug": "forehand",
                    "Posts": []
                }

        url: https://localhost:[porta]/categories/1
        method: DELETE

Aula 30. Tratando Erros
-----------------------

    . Altere o método Post como abaixo, colocando o try/catch:

        [HttpPost("v1/[controller]")]
        public async Task<IActionResult> PostAsync( [FromServices] BlogDataContext context,
                                                    [FromBody] Category model )
        {

            try
            {
                await context.Categories.AddAsync( model );

                await context.SaveChangesAsync();

                return Created( $"v1/[controller]/{model.id}", model );
            }catch( DbUpdateException ex )
            {
                return StatusCode(500, "Falha interna do servidor");
            }
            }catch( Exception ex )
            {
                return StatusCode(500, "Falha interna do servidor");
            }
        }

    . Execute novamente os testes da aula anterior.

    . Tente replicar o código da URL abaixo no projeto:

        https://www.macoratti.net/19/11/aspnc_traterr2.htm    


Aula 31. Finalizando o CRUD de categorias
-----------------------------------------

    . Coloque um BreakPoint na primeira linha de cada método da classe "CategoryController.cs"

    . Crie e execute as chamadas URLs abaixo no Postman. Acompanhe a execução das API pra ver se tudo ocorreu conforme esperado.

        url: https://localhost:[porta]/category
        method: GET
        Body.raw.text: true

        url: https://localhost:[porta]/category/1
        method: GET
        Body.raw.text: true

        url: https://localhost:[porta]/category
        method: POST
        Body.raw: true
        Body.raw.json: true
        Body:   {
                    "Name": "Backend",
                    "Slug": "backend",
                    "Posts": []
                }

        url: https://localhost:[porta]/category/1
        method: PUT
        Body.raw: true
        Body.raw.json: true
        Body:   {
                    "Name": "Frontend",
                    "Slug": "frontend",
                    "Posts": []
                }

        url: https://localhost:[porta]/category/1
        method: DELETE
        Body.raw.text: true

Aula 32.  ViewModels
--------------------

    . ViewModels são modelos adaptados para as entradas de dados.

    . Crie a pasta "ViewModel" na raiz do projeto e dentro dela inclua a classe abaixo:

        namespace Blog.ViewModel
        {
            public class CreateCategoryViewModel
            {
                public string Name { get; set; }

                public string Slug { get; set; }
            }
        }


    . Altere a assinatura do método "PostAsync" da classe "CategoryController" como abaixo:

        ...
        [HttpPost("v1/[controller]")]
        public async Task<IActionResult> PostAsync( [FromServices] BlogDataContext context,
                                                    [FromBody] CreateCategoryViewModel model )
                                                                    |
                                                                    +--> Sai    CategoryModel
                                                                         Entra  CreateCategoryViewModel
        {

            try
            {
                var category = new Category(){            // Linha inserida
                    Id = 0,
                    Posts = null,
                    Name = model.Name,
                    Slug = model.Slug.ToLower()
                };

                await context.Categories.AddAsync( category );  // Linha alterada

                await context.SaveChangesAsync();

                return Created( $"v1/[controller]/{category.id}", model );  // Linha alterada
            }catch( DbUpdateException ex )
            {
                return StatusCode(500, "Falha interna do servidor");
            }
            }catch( Exception ex )
            {
                return StatusCode(500, "Falha interna do servidor");
            }
        }

    . Coloque um "BreakPoint" na primeira linha do método "PostAsync", faça a chamada da URL abaixo 
        no Postman e acompanhe a execução do projeto


        url: https://localhost:[porta]/category
        method: POST
        Body.raw: true
        Body.raw.json: true
        Body:   {
                    "Name": "Backend",
                    "Slug": "backend",
                    "Posts": []
                }

Aula 33. EditorViewModel
------------------------

    . Renomeie a classe "CreateCategoryViewModel" para "EditorCategoryViewModel".

    . Altere os locais que fazem menção a classe "CreateCategoryViewModel" para "EditorCategoryViewModel"
        dentro da classe "CategoryController".

    
    . No Postman altere a chamada abaixo (foi apagado a propriedade "Posts" e alterado para id 2 na URL) e execute-a:

        url: https://localhost:[porta]/category/2
        method: PUT
        Body.raw: true
        Body.raw.json: true
        Body:   {
                    "Name": "Frontend",
                    "Slug": "frontend"
                }


    . Faça o mesmo acerto e testes no métoso "POST"

Aula 34. Validações
-------------------

    . Implemente as validações abaixo na classe "EditorCategoryViewModel":

        ...
        [Required(ErrorMessage = "O nome é obrigatório")]
        [StringLength(40, MinimumLength = 3, ErrorMessage = "Este campo deve conter entre 3 e 40 caracteres")]
        public string Name { get; set; }

        [Required(ErrorMessage = "O slug é obrigatório")]
        public string Slug { get; set; }
        ...
            
    . No Postman altere a chamada abaixo (foi apagado a propriedade "Posts" e alterado para id 2 na URL) e execute-a:

        url: https://localhost:[porta]/category/2
        method: PUT
        Body.raw: true
        Body.raw.json: true
        Body:   {
                    "Name": "",
                    "Slug": ""
                }

    . Implemente o objeto de validação conforme linhas abaixo na classe "CategoryController"

        ...
        [HttpPost("v1/categories")]
        public async Task<IActionResult> PostAsync(
            [FromBody] EditorCategoryViewModel model,
            [FromServices] BlogDataContext context)
        {
            if (!ModelState.IsValid)                        // IF inserido
                return BadRequest();

            try
            {    
                ...
            }
        }
        ...

        . ATENÇÃO: A entrada do IF acima não mudará o comportamento da execução da rota, continuará
                    fazendo a validação automática pelas annotations. Na (Aula 36.  Padronizando erros)
                    veremos como desabilitar a validação automática para tratarmos manualmente utilizando
                    o "Model.IsValid"

// PAREI AQUI
Aula 35. Padronizações
----------------------

    . Dentro da pasta "ViewModels" crie a classe abaixo:

        namespace Blog.ViewModels
        {
            public class ResultViewModel<T>
            {
                public ResultViewModel(T data, List<string> errors)
                {
                    Data = data;
                    Errors = errors;
                }

                public ResultViewModel(T data)
                {
                    Data = data;
                }

                public ResultViewModel(List<string> errors)
                {
                    Errors = errors;
                }

                public ResultViewModel(string error)
                {
                    Errors.Add(error);
                }

                public T Data { get; private set; }
                public List<string> Errors { get; private set; } = new();
            }
        }


Aula 36.  Padronizando erros
----------------------------

    . APIController attribute which performs automatic model state validation and in case of an invalid model state, 
        responds with a 400 bad request error. When the controller is decorated with APIController attribute, the 
        framework would automatically register a ModelStateInvalidFilter which runs on the OnActionExecuting event. 
        This checks for the model state validity and returns the response accordingly. This is a great feature, 
        but sometimes you want to return the custom error instead of the 400 bad request error

    . You can remove the APIController attribute to disable the automatic model validation. But, then you will lose 
        the other benefits of this attribute like disabling conventional routing and allowing model binding without 
        adding [FromBody] parameter attributes.

    . The better approach to disable the default behavior by setting SuppressModelStateInvalidFilter option to true

    . Acesse a classe "Program.cs" e insira a linha abaixo:

        using Blog.Data;
        using Microsoft.AspNetCore.Mvc;

        var builder = WebApplication.CreateBuilder(args);

        builder
            .Services
            .AddControllers()
            .ConfigureApiBehaviorOptions(options =>                 // Linha inserida
            {                                                       // Linha inserida
                options.SuppressModelStateInvalidFilter = true;     // Linha inserida
            });
        builder.Services.AddDbContext<BlogDataContext>();

        var app = builder.Build();
        app.MapControllers();

        app.Run();

    . Ao fazer a configuração acima, somos obrigados validar manualmente dentro dos controllers os models através 
        do método "ModelState.IsValid":

        [HttpPost("v1/categories")]
        public async Task<IActionResult> PostAsync(
            [FromBody] EditorCategoryViewModel model,
            [FromServices] BlogDataContext context)
        {
            if (!ModelState.IsValid)                        
                return BadRequest(new ResultViewModel<Category>(ModelState.GetErrors()));

            ...
        }
        ...

    . Acesse o método "GetAsync" da classe "CategoryController" e altere o retorno dele como abaixo:

        ...
        [HttpGet("v1/categories")]
        public async Task<IActionResult> GetAsync(
                                                    [FromServices] BlogDataContext context)
        {
            try
            {
                var categories = await context.Categories.ToListAsync();
                return Ok(new ResultViewModel<List<Category>>(categories));     // Linha alterada
            }
            catch
            {
                return StatusCode(500, new ResultViewModel<List<Category>>("05X04 - Falha interna no servidor"));   // Linha alterada
            }
        }    
        ...

    . Pare a execução do banco de dados em docker e no Postman execute a URL abaixo:

        url: https://localhost:[porta]/category
        method: GET
        Body.raw.text: true

    . O retorno da URL acima será:

        {
            "data": [],
            "errors": [
                "05X04 - Falha interna no servidor"
            ]
        }


    . Observe a mensagem de erro como veio padronizada.

    . Ative novamente o banco de dados e execute a URL acima

    . Observe o resultado da consulta que veio a lista de categorias e no final uma lista vazia de "errors: []" ja numa estrutura:

        {
            "data": [
                        {
                            categorias...
                        }
            ], 
            "errors": []
        }

Aula 37.  Padronizando o GetById
--------------------------------

    . Acesse o Postman e execute a URL abaixo:

        url: https://localhost:[porta]/category/999
        method: GET
        Body.raw.text: true    

    . Observe que o retorno da API veio totalmente fora do padrão.

    . Altere o método "GetByIdAsync" como abaixo:

        [HttpGet("v1/categories/{id:int}")]
        public async Task<IActionResult> GetByIdAsync(
            [FromRoute] int id,
            [FromServices] BlogDataContext context)
        {
            try
            {
                var category = await context
                    .Categories
                    .FirstOrDefaultAsync(x => x.Id == id);

                if (category == null)
                    return NotFound(new ResultViewModel<Category>("Conteúdo não encontrado"));  // LInha alterada

                return Ok(new ResultViewModel<Category>(category));     // Linha alterada
            }
            catch
            {
                return StatusCode(500, new ResultViewModel<Category>("Falha interna no servidor")); // Linha alterada.
            }
        }    

    . Acesse o Postman e execute a URL abaixo:

        url: https://localhost:[porta]/category/999
        method: GET
        Body.raw.text: true    

    . Observe que o retorno da API veio totalmente fora do padrão.

Aula 38.  Padronizando o BadRequest
-----------------------------------

    . Faça o seguinte teste:

        ...
        HttpPost("v1/categories")]
        public async Task<IActionResult> PostAsync(
            [FromBody] EditorCategoryViewModel model,
            [FromServices] BlogDataContext context)
        {
            if (!ModelState.IsValid)
                return BadRequest();    
            ...

    . Acesse o Postman, execute a URL acima e verifique o erro retornado:

        url: https://localhost:[porta]/category
        method: POST
        Body.raw: true
        Body.raw.json: true
        Body:   {
                    "Name": "",
                    "Slug": "",
                    "Posts": []
                }

    . O retorno ocorrido após a execução da URL acima, foi somente o "StatusCode" 400 de "BadRequest"

    . Altere o retorno do "BadRequest" do controller como abaixo:

        ...
        if (!ModelState.IsValid)
            return BadRequest(ModelState.Values);   // Adicionado o "ModelState.Values
        ...

    . Execute a URL no Postman e verifique o resultado com o BadRequest e os erros apresentados.

    . Na raiz do projeto crie a pasta "Extensions":

    . Dentro da pasta criada crie a classe abaixo:

        using Microsoft.AspNetCore.Mvc.ModelBinding;

        namespace Blog.Extensions
        {
            public static class ModelStateExtension
            {
                public static List<string> GetErrors(this ModelStateDictionary modelState)
                {
                    var result = new List<string>();
                    foreach (var item in modelState.Values)
                        result.AddRange(item.Errors.Select(error => error.ErrorMessage));

                    return result;
                }
            }
        }

        . IMPORTANTE: Para entender melhor o conceito de Extensão de métodos acesse a "Aula 26. Implementando Extension Methods"
                        do curso "DI - Dominando Injeção de Depdência"

    . ALtere o método "PostAsync" como abaixo:

        ...
        [HttpPost("v1/categories")]
        public async Task<IActionResult> PostAsync(
            [FromBody] EditorCategoryViewModel model,
            [FromServices] BlogDataContext context)
        {
            if (!ModelState.IsValid)
                return BadRequest(new ResultViewModel<Category>(ModelState.GetErrors()));   // Linha alterada

            try
            {
                var category = new Category
                {
                    Id = 0,
                    Name = model.Name,
                    Slug = model.Slug.ToLower(),
                };
                await context.Categories.AddAsync(category);
                await context.SaveChangesAsync();

                return Created($"v1/categories/{category.Id}", new ResultViewModel<Category>(category));    // Linha alterada
            }
            catch (DbUpdateException ex)
            {
                return StatusCode(500, new ResultViewModel<Category>("05XE9 - Não foi possível incluir a categoria"));  // Linha alterada
            }
            catch                                               // Linha alterada
            {
                return StatusCode(500, new ResultViewModel<Category>("05X10 - Falha interna no servidor"));     // Linha alterada
            }
        }
        ...

    . Execute a URL de "POST" do inicio da aula no Postman e verifique o resultado.


Aula 39.  Conclusão do módulo
-----------------------------

    . Altere o método "PutAsync":

        ...
        [HttpPut("v1/categories/{id:int}")]
        public async Task<IActionResult> PutAsync(
            [FromRoute] int id,
            [FromBody] EditorCategoryViewModel model,
            [FromServices] BlogDataContext context)
        {
            try
            {
                var category = await context
                    .Categories
                    .FirstOrDefaultAsync(x => x.Id == id);

                if (category == null)
                    return NotFound(new ResultViewModel<Category>("Conteúdo não encontrado"));      // Linha alterada

                category.Name = model.Name;
                category.Slug = model.Slug;

                context.Categories.Update(category);
                await context.SaveChangesAsync();

                return Ok(new ResultViewModel<Category>(category));             // Linha alterada
            }
            catch (DbUpdateException ex)
            {
                return StatusCode(500, new ResultViewModel<Category>("05XE8 - Não foi possível alterar a categoria"));  // Linha alterada
            }
            catch (Exception ex)
            {
                return StatusCode(500, new ResultViewModel<Category>("05X11 - Falha interna no servidor"));     // Linha alterada
            }
        }            

    . Altere o método "DeleteAsync":

        ...
        [HttpDelete("v1/categories/{id:int}")]
        public async Task<IActionResult> DeleteAsync(
            [FromRoute] int id,
            [FromServices] BlogDataContext context)
        {
            try
            {
                var category = await context
                    .Categories
                    .FirstOrDefaultAsync(x => x.Id == id);

                if (category == null)
                    return NotFound(new ResultViewModel<Category>("Conteúdo não encontrado"));      // Linha alterada

                context.Categories.Remove(category);
                await context.SaveChangesAsync();

                return Ok(new ResultViewModel<Category>(category));         // Linha alterada
            }
            catch (DbUpdateException ex)
            {
                return StatusCode(500, new ResultViewModel<Category>("05XE7 - Não foi possível excluir a categoria"));  // Linha alterada
            }
            catch (Exception ex)
            {
                return StatusCode(500, new ResultViewModel<Category>("05X12 - Falha interna no servidor"));     // Linha alterada
            }
        }
        ...

    . Acesse o Postman e teste todas as rotas alteradas.


Autenticação e Autorização
--------------------------

https://www.udemy.com/course/net-6-web-api-do-zero-ao-avancado/learn/lecture/29034104?start=0#overview

https://www.brunobrito.net.br/jwt-cookies-oauth-bearer/

Aula 40. Introdução
------------------- 

    . O projeto que será tralhado neste módulo será o "Blog", desenvolvido no módulo anterior.

    . Acesse o banco de dados e execute as linhas abaixo para popular:

        INSERT INTO [Category] VALUES('Backend', 'backend')
        INSERT INTO [Category] VALUES('Frontend', 'frontend')
        INSERT INTO [Category] VALUES('Full Stack', 'fullstack')
        INSERT INTO [Category] VALUES('Mobile', 'mobile')

        INSERT INTO [Tag] VALUES('ASP.NET', 'aspnet')
        INSERT INTO [Tag] VALUES('.NET', 'dotnet')
        INSERT INTO [Tag] VALUES('C#', 'csharp')
        INSERT INTO [Tag] VALUES('Angular', 'angular')
        INSERT INTO [Tag] VALUES('Flutter', 'flutter')
        INSERT INTO [Tag] VALUES('Entity Framework', 'ef')
        INSERT INTO [Tag] VALUES('Java', 'java')
        INSERT INTO [Tag] VALUES('Java Script', 'js')

        INSERT INTO [Role] VALUES('user', 'user')
        INSERT INTO [Role] VALUES('author', 'author')
        INSERT INTO [Role] VALUES('admin', 'admin')

        INSERT INTO [User] VALUES('Peter Parker', 'pparker@balta.io', '1234', 'https://balta.io/', 'peter-parker', 'Sou o Homem Aranha')
        INSERT INTO [User] VALUES('Bruce Wayne', 'wayne@balta.io', '1234', 'https://balta.io/', 'bruce-wayne', 'Sou o Batman')
        INSERT INTO [User] VALUES('Diana Prince', 'diana@balta.io', '1234', 'https://balta.io/', 'diana-prince', 'Sou a Mulher Maravilha')

        -- POST
        INSERT INTO [Post] VALUES('Começando com C#', 'Neste post vamos começar com C#', '<h1>Começando com C#</h1>', 'comecando-com-csharp', GETDATE(), GETDATE(), (SELECT TOP 1 [Id] FROM [Category] WHERE [Slug]='backend'), (SELECT TOP 1 [Id] FROM [User] WHERE [Slug]='peter-parker'))
        INSERT INTO [Post] VALUES('Começando com Angular', 'Neste post vamos começar com Angular', '<h1>Começando com Angular</h1>', 'comecando-com-angular', GETDATE(), GETDATE(), (SELECT TOP 1 [Id] FROM [Category] WHERE [Slug]='frontend'), (SELECT TOP 1 [Id] FROM [User] WHERE [Slug]='diana-prince'))

        -- Se der erro de índice ao inserir os PostTag, remover as chaves
        -- DROP INDEX [IX_PostTag_TagId] ON [PostTag]
        -- ALTER TABLE [PostTag] DROP CONSTRAINT [PK_PostTag]  
        -- ALTER TABLE [PostTag] DROP CONSTRAINT [FK_PostTag_TagId ]
        INSERT INTO [PostTag] VALUES(1, 2)
        INSERT INTO [PostTag] VALUES(1, 3)
        INSERT INTO [PostTag] VALUES(2, 4)
        INSERT INTO [PostTag] VALUES(2, 8)

        INSERT INTO [UserRole] VALUES(1, 1)
        INSERT INTO [UserRole] VALUES(1, 2)
        INSERT INTO [UserRole] VALUES(2, 1)
        INSERT INTO [UserRole] VALUES(2, 2)
        INSERT INTO [UserRole] VALUES(2, 3)
        INSERT INTO [UserRole] VALUES(3, 1)
        INSERT INTO [UserRole] VALUES(3, 2)


Aula 41. Token e JWT
--------------------

    . Autenticação diz quem você é.

    . Autorização diz o que você pode fazer.

    . Na raiz do projeto crie a classe abaixo:

        namespace Blog

        public static class Configuration
        {
            // TOKEN - JWT - Json Web Token
            public static string JwtKey { get; set; } = "ZmVkYWY3ZDg4NjNiNDhlMTk3YjkyODdkNDkyYjcwOGU=";

        }

Aula 42. Token Service
----------------------

    . Adicione as packages abaixo no projeto:

        dotnet add package Microsoft.AspNetCore.Authentication

        dotnet add package Microsoft.AspNetCore.Authentication.Bearer

    . Crie a pasta "Services" na raiz do projeto e crie a classe abaixo:

        using System.IdentityModel.Token.Jwt;
        using Blog.Models;

        namespace Blog.Services;

        public class TokenService
        {
            public string GenerateToken( User user )
            {
                var tokenHandler = new JwtSecurityTokenHandler();
                var key = Encoding.ASCII.GetBytes( Configuration.JwtKey );
                var tokenDescriptor = new SecurityTokenDescriptor
                {
                    Expires = DateTime.UtcNow.AddHours(8),
                    SigningCredentials = new SigningCredentials( new SymetricSecurityKey( key ),
                                                                    SecurityAlgorithms.HmaShaSignature )
                }
                var token = tokenHandler.CreateToken( tokenDescriptor );

                return tokenHandler.WriteToken( token );

            }
        }

Aula 43. Injeção de Depedência
------------------------------

    . Crie a classe abaixo dentro da pasta "Controllers":

        using Blog.Services;
        using Microsoft.AspNetCore.Mvc;

        namespace Blog.Controllers;

        [ApiController]
        public class AccountController: ControllerBase
        {
            private readonly TokenService _tokenService;

                                            +---> Aqui é feito a injeção de dependência
                                            |
            public AccountController( TokenService tokenService )
            {
                _tokenService = tokenService;   // Aqui é passado o objeto para dentro da classe
            }


            [HttpPost("v1/login")]
            public IActionResult Login()
            {
                var token = _tokenService.GenerateToken( null );

                return Ok( token );
            }
        } 

        . Ao invés de fazer a injeção de dependência pelo método construtor poderiamos fazê-lo pelo método login 
            como abaixo:

            [HttpPost("v1/login")]
            public IActionResult Login( [FromService] TokenService tokenService)    // DI pelo método e annotation [FromService]
            {
                var token = tokenService.GenerateToken( null );

                return Ok( token );
            }

Aula 44. AddScoped, AddTransient, AddSingleton
----------------------------------------------

    . AddTransient

        builder.Services.AddTransient<IDeliveryFeeService, DeliveryFeeService>();

            . Sempre cira uma nova instância do objeto

            . Ideal para cenários onde queremos sempre um novo objeto.

    . AddScoped

        builder.Services.AddScoped<IDeliveryFeeService, DeliveryFeeService>();

            . Cria um objeto por transação/requisição

            . Se você chamar 2 ou mais serviços que dendem do mesmo objeto, a mesma instância será utilizada

            . Ideal para cenários onde queremos apenas um objeto por requisição (banco).

    . AddSingleton

        . Cria um objeto quando a aplicação inicia e apaga da sessão quando a aplicação termina.

            builder.Services.AddSingleton<IDeliveryFeeService, DeliveryFeeService>();

        . Mantém este objeto na memória até a aplicação para ou reiniciar 

        . Sempre devolve a mesma instância deste objeto, com os mesmos valores.

        . Padrão que visa garantir apenas um instância de um objeto para aplicão toda

        . Um bom exemplo são as configurações

            . Uma vez carregadas, ficam até a aplicação reiniciar.

    . AddDbContext

        . Item especial do tipo Scoped

            builder.Services.AddDbContext<BlogDataContext>( x => useSqlServer( connStr ));

        . Utilizado exclusivamente com o EF

        . Garante que a conexão só dura até o fim da requisição


    . Acesse a classe "Program.cs" e insira a linha abaixo:

        ...
        builder
            .Services
            .AddController()
            .ConfigureApiBehaviorOptions( options =>
            {
                options.SuppressModelStateInvalidFilter = true;
            });

        builder.Services.AddDbContext<BlogDataContext>();

        builder.Services.AddTransient<TokenService>();  // Linha inserida

        ...

Aula 45. Inspecionando o Token
------------------------------

    . Execute o projeto.

    . Acesse o Postman e execute a URL abaixo:

        url: http://localhost:[porta]/v1/login
        method: POST

    . Acesse o site jwt.io, acesse a área "Encoded" e copie o token gerado no item anterior para analisar
        os detalhes do token




Aula 46.  JWT Claims
--------------------

    . Acesse a classe "TokenService.cs" e implemente as alterações abaixo:

        using System.IdentityModel.Token.Jwt;
        using Blog.Models;

        namespace Blog.Services;

        public class TokenService
        {
            public string GenerateToken( User user )
            {
                var tokenHandler = new JwtSecurityTokenHandler();
                var key = Encoding.ASCII.GetBytes( Configuration.JwtKey );
                var tokenDescriptor = new SecurityTokenDescriptor
                {
                    Subject = ClaimsIdentity( new Claim[]           // Linha inserida
                    {
                        new Claim("fruta","banana")
                    }),
                    Expires = DateTime.UtcNow.AddHours(8),
                    SigningCredentials = new SigningCredentials( new SymetricSecurityKey( key ),
                                                                    SecurityAlgorithms.HmaShaSignature )
                }
                var token = tokenHandler.CreateToken( tokenDescriptor );

                return tokenHandler.WriteToken( token );

            }
        }

    . Execute o projeto.

    . Acesse o Postman e execute a URL abaixo:

        url: http://localhost:[porta]/v1/login
        method: POST

    . Acesse o site jwt.io, acesse a área "Encoded" e copie o token gerado no item anterior para analisar
        os detalhes do token

        . Observe no "Payload" que agora temos o item "fruta": "banana"

    . Retorne a classe "TokenService" e implemente as linhas abaixo:

        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = ClaimsIdentity( new Claim[]  
            {
                new Claim( ClaimTypes.Name, "marco.antonio"),          // Linha inserida
                new Claim( ClaimTypes.Role, "admin"),         // Linha inserida
                new Claim("fruta","banana")
            }),
            Expires = DateTime.UtcNow.AddHours(8),
            SigningCredentials = new SigningCredentials( new SymetricSecurityKey( key ),
                                                            SecurityAlgorithms.HmaShaSignature )
        }

    . Mais a frente utilizaremos os Claims inseridos nos controllers com a seguinte identificação:

        new Claim( ClaimTypes.Name, "marco.antonio"),          // User.Identity.Name
        new Claim( ClaimTypes.Roles, "admin"),         // User.IsInRole


    . Execute o projeto.

    . Acesse o Postman e execute a URL abaixo:

        url: http://localhost:[porta]/v1/login
        method: POST

    . Acesse o site jwt.io, acesse a área "Encoded" e copie o token gerado no item anterior para analisar
        os detalhes do token

        . Observe no "Payload" que agora temos os itens:
            
            "unique_name": "marco.antonio",
            "role": "admin"


Aula 47. Configurando Autenticação e Autorização
------------------------------------------------

    . Acesse a classe "Programs.cs" e insira as linhas abaixo para habilitar a autenticação e a autorização 
        no nosso projeto, obrigatório ser nessa ordem:

        ...
        var builder - WebApplication.CreateBuilder( args );

        var byte[] = Encoding.ASCII.GetBytes( Configuration.JwtKey );   // Linha inserida




        // Linha abaixo inserida

        builder.Services.AddAuthentication( x =>
        {
            x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            x.DefaultChallengeScheme = JwtBearerDefaults.AthenticationScheme.
        }).AddJwtBearer( JwtBearerOptions =>
        {
            x.TokenValidationParameters = new TokenValidateionParameters
                {
                    ValidateIssuerSigningKey = true,
                    UssuerSigninigKey = new SymmtricSecurityKey( key ),
                    ValidateIssuer = false,
                    ValidateAudience = false
                };
        });                 // Linha inserida


        ...
        var app = builder.Build();

        app.UseAuthentication();    // Linha inserida   "Nessa ordem"
        app.UseAuthorization();     // Linha inserida   "Nessa ordem"
        ...

Aula 48. Testando a autenticação e autorização  (Revisar)
----------------------------------------------

    . Dentro da classe AccountController crie os métodos abaixo:

        [Authorize]             // Linha inserida
        [ApiController]
        public class AccountController: ControllerBase
        {
            ...                     // Métodos abaixo inseridos
            [HttpGet("v1/user")]
            public IActionResult GetUser() => Ok( User.Identity.Name )

            [HttpGet("v1/author")]
            public IActionResult GetAuthor() => Ok( User.Identity.Name )

            [HttpGet("v1/admin")]
            public IActionResult GetAdmin() => Ok( User.Identity.Name )
            ...
        }

    . Acesse o Postman e execute a URL abaixo:

        url: https://localhost:[porta]/v1/login
        method: POST

    . O retorno do StatusCode será "401 Not Authorizied", porque não estamos autenticado

    . Altere o método "Login" da classe acima como abaixo:

            ...
            [AllowAnonymous]                        // Linha inserida
            [HttpPost("v1/login")]
            public IActionResult Login( [FromServices] TokenService tokenService )
            {
                var token = tokenService.GenerateToken( null );

                return Ok( token );
            }
            ...

    . Acesse o Postman e execute a URL abaixo:

        url: https://localhost:[porta]/v1/login
        method: POST

    . Agora deverá vir um Token

    . Acesse o Postman e execute a URL abaixo:

        url: https://localhost:[porta]/v1/user
        method: GET

    . O retorno do StatusCode será "401 Not Authorizied", porque não estamos autenticado

    . Retire a annotation "[Authorize]" e "[Anonymous]" e faça as alterações abaixo na classe "AccountController":

        ...
        [Authorize( Roles = "user")]                     // Linha inserida
        [HttpGet("v1/user")]
        public IActionResult GetUser() => Ok( User.Identity.Name )

        [Authorize( Roles = "author" )]                     // Linha inserida
        [HttpGet("v1/author")]
        public IActionResult GetAuthor() => Ok( User.Identity.Name )

        [Authorize( Roles = "admin" )]                     // Linha inserida
        [HttpGet("v1/admin")]
        public IActionResult GetAdmin() => Ok( User.Identity.Name )
        ...

    . Execute o projeto.

    . Acesse o Postman e execute a URL abaixo:

        url: https://localhost:[porta]/v1/login
        method: POST

    . Agora deverá vir um Token

    . Acesse o Postman e execute a URL abaixo:

        url: https://localhost:[porta]/v1/user
        method: GET
        Authorization.Type: Bearer Token
        Authorization.Token: [token obtido no item anterior]

        . Este dará erro "403. Forbidden" porque não existe o claim de admin disponivel    

    . Acesse o Postman e execute a URL abaixo:

        url: https://localhost:[porta]/v1/admin
        method: GET
        Authorization.Type: Bearer Token
        Authorization.Token: [token obtido no item anterior]

    . Acesse o Postman e execute a URL abaixo:

        url: https://localhost:[porta]/v1/author
        method: GET
        Authorization.Type: Bearer Token
        Authorization.Token: [token obtido no item anterior]

        . Este dará erro "403. Forbidden" porque não existe o claim de admin disponivel    

    . Acesse a classe "TokenService.cs" e inclua a linha abaixo:

        ...
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = ClaimsIdentity( new Claim[]  
            {
                new Claim( ClaimTypes.Name, "marco.antonio"),  
                new Claim( ClaimTypes.Role, "admin"),         
                new Claim( ClaimTypes.Role, "user"),            // Linha inserida
                new Claim("fruta","banana")
            }),
            Expires = DateTime.UtcNow.AddHours(8),
            SigningCredentials = new SigningCredentials( new SymetricSecurityKey( key ),
                                                            SecurityAlgorithms.HmaShaSignature )
        }
        ...

    . Execute o projeto.

    . Acesse o Postman e execute a URL abaixo:

        url: https://localhost:[porta]/v1/login
        method: POST

    . Agora deverá vir um Token

    . Acesse o Postman e execute a URL abaixo:

        url: https://localhost:[porta]/v1/user
        method: GET
        Authorization.Type: Bearer Token
        Authorization.Token: [token obtido no item anterior]

        . Agora a rota "user" estará disponível.

Aula 49.  Iniciando o cadastro de usuários
------------------------------------------

    . Crie a classe "RegisterViewModel" dentro da pasta "ViewModels":

        using System.ComponentModel.DataAnnotations;

        namespace Blog.ViewModels;

        public class RegisterViewModel
        {
            [Required( ErrorMessage = "Nome é obrigatório")]
            public string Name { get; set; }

            [Required( ErrorMessage = "E-Mail é obrigatório")]
            [EmailAddress( ErrorMessage = "E-Mail inválido")]
            public string Email { get; set; }

        }


    . Apague os métodos abaixo da classe "AccountController":

        GetUser

        GetAdmin

        GetAuthor

        Construtor ( AccountController )

    . Faça as alterações abaixo na classe "AccountController":

        using Blog.Services;
        using Microsoft.AspNetCore.Mvc;

        namespace Blog.Controllers;

        [ApiController]
        public class AccountController: ControllerBase
        {
            // private readonly TokenService _tokenService;                            // Linha apagada

            [HttpPost("v1/accounts")]                                                  // Método inserido
            public async Task<IActionResult> Post( [FromBody] RegisterViewModel model,
                                                    [FromServices] BlogDataContext context )
            {
                if (!ModelState.IsInvalid)
                    return BadRequest( new ResultVideModel<string>( ModelState.GetErrors()));

                var user = new User
                {
                    Name = model.Name,
                    Email = model.Email,
                    Slug = model.Email.Replace( "@", "-").Replace( ".","-")
                };

            }


            [HttpPost("v1/accounts/login")]                                         // Linha alterada
            public IActionResult Login( [FromServices] TokenService tokenService)   // Linha alterada
            {
                var token = tokenService.GenerateToken( null );                     // linha alterada

                return Ok( token );
            }
        } 


    . Altere o conteúdo da classe "Blog.Data.Mappings.UserMap" pelo conteúdo abaixo:

        using System.Collections.Generic;
        using Blog.Models;
        using Microsoft.EntityFrameworkCore;
        using Microsoft.EntityFrameworkCore.Metadata.Builders;

        namespace Blog.Data.Mappings
        {
            public class UserMap : IEntityTypeConfiguration<User>
            {
                public void Configure(EntityTypeBuilder<User> builder)
                {
                    // Tabela
                    builder.ToTable("User");

                    // Chave Primária
                    builder.HasKey(x => x.Id);

                    // Identity
                    builder.Property(x => x.Id)
                        .ValueGeneratedOnAdd()
                        .UseIdentityColumn();

                    // Propriedades
                    builder.Property(x => x.Name)
                        .IsRequired()
                        .HasColumnName("Name")
                        .HasColumnType("NVARCHAR")
                        .HasMaxLength(80);

                    builder.Property(x => x.Bio)
                        .IsRequired(false);

                    builder.Property(x => x.Email)
                        .IsRequired()
                        .HasColumnName("Email")
                        .HasColumnType("VARCHAR")
                        .HasMaxLength(160);

                    builder.Property(x => x.Image)
                        .IsRequired(false);

                    builder.Property(x => x.PasswordHash).IsRequired()
                        .HasColumnName("PasswordHash")
                        .HasColumnType("VARCHAR")
                        .HasMaxLength(255);

                    builder.Property(x => x.Slug)
                        .IsRequired()
                        .HasColumnName("Slug")
                        .HasColumnType("VARCHAR")
                        .HasMaxLength(80);

                    // Índices
                    builder
                        .HasIndex(x => x.Slug, "IX_User_Slug")
                        .IsUnique();

                    // Relacionamentos
                    builder
                        .HasMany(x => x.Roles)
                        .WithMany(x => x.Users)
                        .UsingEntity<Dictionary<string, object>>(
                            "UserRole",
                            role => role
                                .HasOne<Role>()
                                .WithMany()
                                .HasForeignKey("RoleId")
                                .HasConstraintName("FK_UserRole_RoleId")
                                .OnDelete(DeleteBehavior.Cascade),
                            user => user
                                .HasOne<User>()
                                .WithMany()
                                .HasForeignKey("UserId")
                                .HasConstraintName("FK_UserRole_UserId")
                                .OnDelete(DeleteBehavior.Cascade));
                }
            }
        }

    . Levante o banco:

        docker start sqlserver

    . Execute os comandos abaixo no prompt do sistema operacional na pasta raiz do projeto:

        dotnet ef database drop -f
        dotnet ef migrations remove
        dotnet ef migrations add [Nome da Migration]
        dotnet ef database update

Aula 50. Salvando senhas no banco de dados
------------------------------------------

