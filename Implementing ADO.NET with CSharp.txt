Implementing ADO.NET with C#
----------------------------

. Classes do ADO.NET

    . O que é ADO.NET?

        . ADO (ActiveX Data Objects) é uma das tecnologias de acesso a dados da Microsoft, que podemos comunicar
            com diferentes banco de dados. Faz parte do .NET Framework, serve para conectar aplicações .NET
            (Console, WCF, WPF, Windows, MVC, Web Form, etc.). Os bancos de dados podem ser: SQL Server, Oracle, MySQL, XML, 
            etc. ADO.NET consiste em um conjunto de classes predefinidas utilizadas para conectar, resgatar, inserir, 
            atualizar e eliminar dados em operações CRUD nesses bancos.

    . Principais componentes do ADO.NET:

        . Connection - Cria uma conexão com o banco de dados.

        . Transaction - Executa comandos dentro de uma transação.

        . Command - Envia DMLs para o banco de dados.

        . DataAdapter - É usado para preencher um DataSet, ou um DataTable com dados.

        . DataReader - Um rápido, forward-only cursor para leitura de dados.

        . ParameterCollection - Stores all parameters related to a Command and the mappings of
                                both table and column names to the DataSet columns.

        . Parameter - Defines parameters for parameterized SQL statements and stored procedures.

    . Classes Desconectadas:

        . DataSet - Coleção de um, ou mais, DataTables.

        . DataTable - Uma simples representação de uma tabela de dados.

        . DataView - Uma consulta dentro do DataTable.

        . DataRow - Uma linha de dados dentro do DataTable.

        . DataColumn - Uma coluna de dado num DataRow.

    . Classes de Construção:

        . ConnectionStringBuilder - Cria, ou quebra uma string de conexão.

        . CommandBuilder - Cria um comando insert, update, ou delete.

    . Provedores de dados:

        . Um provedor de conexão conecta fontes de dados como SQL Server, MySQL, Oracle, etc; promovendo um 
            caminho para executar comandos 

        . SQL Server - System.Data.SqlClient

            . Conjunto de classes que fazem parte deste provider são: SqlConnection, SqlCommand, SqlDataAdapter, etc.

        . OLE DB - System.Data.OleDb

            . Conjunto de classes que fazem parte deste provider são: OleDbConnection, OleDbCommand, OleDbDataAdapter, etc.

        . ODBC - System.Data.Odbc

            . Conjunto de classes são: OdbcConnection, OdbcCommand, OdbcDataAdapter, etc.

        . Oracle - System.Data.OracleClient

            . Conjunto de classes são: OracleConnection, OracleCommand, OracleDataAdapter, etc.

        . MySQL - MySql.Data.MySqlClient

            . Conjunto de classes são: MySqlConnection, MySqlCommand, MySqlAdapter

            . https://zetcode.com/csharp/mysql/

            . https://csharp.hotexamples.com/pt/examples/MySql.Data.MySqlClient/MySqlConnection/CreateCommand/php-mysqlconnection-createcommand-method-examples.html

            . https://dev.mysql.com/doc/connector-net/en/connector-net-introduction.html

            . https://dev.mysql.com/doc/connector-net/en/connector-net-tutorials-intro.html

. ORMs and ADO.NET

    . Exemplos de ORMs:

        . EF
        . Dapper
        . NHibernate

    . Possui auto mapper.

    . Abstrai o banco de dados em objetos.

    . Podemos utilizar a linguagem LINQ (Trata-se de um “framework” dentro do .NET destinado a auxiliar os 
        desenvolvedores a escrever expressões de consulta diretamente em C# de maneira agnóstica)

        . Abstrai a complexidade envolvida na utilização de diferentes linguagens de consulta, como SQL, xPath e xQuery. 
            Essa abstração é feita em cima de uma API de alto nível compatível com as linguagens integrantes do .NET Framework. 
            Ou seja: você consegue consultar uma base de dados relacional, um arquivo XML uma coleção de objetos através 
            de uma API unificada, invocada através de uma linguagem integrante do .NET Framework. 
            
        . Trazendo para um exemplo mais palpável: você consegue unicamente com código C# fazer consultas a conjuntos de objetos, 
            bases de dados relacionais e arquivos XML, sendo o LINQ o encarregado de fazer a devida “tradução” para cada 
            uma das fontes a serem consultadas.

. The Connection Class

    . Passando string de conexão:

        var cnn = new SqlConnection( cnnString );

    . Podemos utilizar para o comando acima ODBC, SqlServer, OleDb, MySQL, etc.

    . Abrindo conexão:

        cnn.Open();

    . Fechando a conexão:

        cnn.Close();

    . Descartando recursos não gerenciados:

        cnn.Dispose();

    . using (ou using var) garante que o objeto que implementa IDisposable tenha Dispose() chamado automaticamente ao 
        sair do escopo — mesmo se ocorrer uma exceção. É equivalente a um try/finally que chama Dispose().

        using (MySqlConnection con = new MySqlConnection(cs))
        {
            ...

            // con.Dispose();       Neste caso não precisa, porque utiliza o bloco "using", desde que implemente a interface "IDispose" 

        }   // Dispose chamado aqui


        ou

        using var conn = new  MySqlConnection(cs)

        conn.Open();
        // Dispose chamado ao final do método/escopo


    . Criar com new sozinho não chama Dispose() automaticamente; você precisa chamar Close()/Dispose() manualmente 
        (normalmente dentro de um try/finally). Sem isso, o fechamento/retorno da conexão ao pool fica dependente 
        do GC (não-determinístico), podendo causar esgotamento do pool.

         MySqlConnection con = new MySqlConnection(cs);

         con.Dispose(); // Quase que obrigado fazer o dispose neste casso com o uso do "new"

. Demo

    . Digite os comandos abaixo no prompt do sistema operacional:

        cd /workspace-dotnet
        mkdir ADONet
        cd ADONet
        dotnet new sln --name ADONET
        dotnet new console -n AdoNetSystem -o adoNetSystem
        dotnet sln add adoNetSystem
        cd adoNetSystem
        dotnet add package MySql.Data
        code .

    . Instalando o MySQL

        # Criando container com nome o banco de dados MySQL
        docker container run -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 --name adoNetSystemDb -d mysql:8.0.36 --default-authentication-plugin=mysql_native_password
        
        docker start adoNetSystemDb

        docker ps -a
        docker exec -it adoNetSystemDb mysql -u root -p	

        docker stop adoNetSystemDb

    . Criando o banco de dados

        docker exec -it adoNetSystemDb mysql -u root -p	

        CREATE DATABASE adoNetSystem;

        USE adoNetSystem;

        CREATE TABLE cliente(   codigo          bigint NOT NULL AUTOINCREMENT PRIMARY KEY,
                                nome            VARCHAR(50),
                                dataAniversario DATE);

. Openning a Connection

    . Para abrirmos uma conexão precisamos de uma string de conexão:
  
        string cs = @"server=localhost;userid=marco;password=brasil2;database=desenv";

        . O caracter "@" serve para preservar os caracteres especiais dentro da expressão string. Para mais detalhes
            do caracter "@", consulte o link: http://www.macoratti.net/14/01/c_arroba.htm

        . Dentro da expressão string é necessário fornecer todos os detalhes da conexão, como por exemplo:
            o nome do servidor, usuário, senha, database, etc. Isto irá variar de banco para banco.

        . Para encontrar as diversas formas de montar uma string de conexão acesse o site https://www.connectionstrings.com/

. Demo

    . Crie a pasta "AdoNet" dentro do projeto "adoNetSystem" e crie a classe abaixo dentro 

        using System;
        using System.Text;
        using MySql.Data.MySqlClient;

        namespace AdoNet;

        public class ConnectionModel : IDisposable
        {

            public void OpenConnection()
            {

                string cs = @"server=localhost;userid=root;password=root;database=adoNetSystem";

                using (MySqlConnection con = new MySqlConnection(cs))
                {
                    con.Open();

                    string connectionInformation = GetConnectionInformation(con);

                    Console.WriteLine(connectionInformation);

                    // fechará a conexão com o servidor conforme definido na string de conexão
                    con.Close();

                    // Limpará completamente, removendo todos os recursos não gerenciados, evitando que a conexão 
                    // seja usada novamente. Uma vez que descartado é chamado, você não deve mais tentar usar o objeto. 
                    // con.Dispose();       // Não está sendo usado porque a conexão foi chamada dentro de um bloco "using"
                }
            }

            public string GetConnectionInformation(MySqlConnection con)
            {
                StringBuilder sb = new StringBuilder(1024);

                sb.AppendLine("Connection String: " + con.ConnectionString);
                sb.AppendLine("State: " + con.State.ToString());
                sb.AppendLine("Connection Timeout: " + con.ConnectionTimeout.ToString());
                sb.AppendLine("Database: " + con.Database);
                sb.AppendLine("Data Source: " + con.DataSource);
                sb.AppendLine("Server Version: " + con.ServerVersion);
                //            sb.AppendLine("Workstation ID: " + con.WorkstationId);

                return sb.ToString();

            }

            void IDisposable.Dispose()
            {
                throw new NotImplementedException();
            }

        }

        . No método "OpenConnection()" utilizamos o bloco "using". Um detalhe para se destacar que a classe "ConnectionModel" precisa
            implementar a interface "IDisposable" se quisermos utiliza-la num bloco "using". Neste caso, implementaremos o método "IDisposable.Dispose()"
            nesta classe para liberar recursos utilizados pela classe em questão. Para mais detalhes acesse: https://www.devmedia.com.br/entendendo-o-bloco-using-no-csharp/16967


    . Acesse a classe Programa.cs e altere todo o código abaixo:

        using AdoNet;

        ConnectionModel cm = new ConnectionModel();

        cm.OpenConnection();

    . Catching Connection Exceptions

        . Implemente o bloco Try, catch dentro do método "OpenConnection" como abaixo:

            public void OpenConnection(){

                // Bloco try/catch inserido
                try{
                    string cs = @"server=localhost;userid=marco;password=brasil2;database=desenv";

                    using ( MySqlConnection con = new MySqlConnection(cs)){
                        con.Open();

                        string connectionInformation = GetConnectionInformation(con);

                        Console.WriteLine( connectionInformation );

                        con.Close();

                        con.Dispose();
                    }
                }
                catch( Exception ex){
                    throw new Exception( "Ocorreu o seguinte Erro: " + ex.ToString());
                }
            }

        . Altere alguma informação da string de conexão para dar erro e cair na excessão, ou retire o docker container do arq.

    . Execute o projeto.

. SQLCommand

    . SqlCommand é a classe do ADO.NET responsável por representar um comando SQL que será executado no banco de dados.

    . Ela pode executar:

        SELECT

        INSERT

        UPDATE

        DELETE

        Stored Procedures

    . Exemplo

        using System.Data.SqlClient;

        var command = new SqlCommand(
            "SELECT COUNT(*) FROM Usuarios",
            connection
        );

    . Método "ExecuteScalar"

        . É um método do SqlCommand usado quando, você espera apenas um único valor como retorno.

        . Características importantes:

            . Executa o comando SQL

            . Retorna somente a primeira coluna da primeira linha

            . Ignora o resto do resultado

        . Exemplo:

            using (var connection = new SqlConnection(connectionString))
            {
                connection.Open();

                var command = new SqlCommand(
                    "SELECT COUNT(*) FROM Usuarios",
                    connection
                );

                int totalUsuarios = (int)command.ExecuteScalar();
            }

    . Método "ExecuteNonQuery"

        . Executa comandos SQL que:

            . Não retornam ResultSets (SELECT)

            . Alteram o estado do banco de dados

            . É usado principalmente para:

                INSERT

                UPDATE

                DELETE

                CREATE / ALTER / DROP

        . Exemplo:

            using (SqlConnection conn = new SqlConnection(connectionString))
            {
                string sql = "INSERT INTO Cliente (Nome, Email) VALUES (@Nome, @Email)";

                using (SqlCommand cmd = new SqlCommand(sql, conn))
                {
                    cmd.Parameters.AddWithValue("@Nome", "Marco");
                    cmd.Parameters.AddWithValue("@Email", "marco@email.com");

                    conn.Open();

                    int linhasAfetadas = cmd.ExecuteNonQuery();
                }
            }

    . Método "ExecuteReader"

        . Retorna um DataReader com os dados da consulta e executa apenas o comando SELECT.
            Use quando for preencher um DropDownList, CheckBoxList, RadioButtonList. ExecuteReader é somente leitura e 
            não pode ser usado para outros fins.

        . O que acontece internamente:

            . O SqlCommand envia o SQL ao banco

            . O banco começa a enviar os dados

            . O C# cria um SqlDataReader

            . Os dados são lidos linha a linha (forward-only)

        . É rápido e consome pouca memória. Não permite voltar para registros anteriores

        . Exemplo:

            using (SqlConnection conn = new SqlConnection(connectionString))
            {
                string sql = "SELECT Id, Nome, Email FROM Cliente";

                using (SqlCommand cmd = new SqlCommand(sql, conn))
                {
                    conn.Open();
                                                
                    using (SqlDataReader reader = cmd.ExecuteReader())
                    {
                        while (reader.Read())   // Read() - avança para a próxima linha e Retorna true enquanto houver dados
                        {
                            int id = reader.GetInt32(0);
                            string nome = reader.GetString(1);
                            string email = reader.GetString(2);
                        }
                    }
                }
            }

        . Formas de acessar os dados:

            reader.GetString(2);        reader.GetInt32(0);

            reader["Nome"].ToString();      // Mais legível, porém um pouco mais lento.

            
            string? email = reader.IsDBNull(2) ? null : reader.GetString(2);        // Verificando NULL

        . Claúsula WHERE

            string sql = "SELECT Nome FROM Cliente WHERE Id = @Id";

            cmd.Parameters.AddWithValue("@Id", 1);

    . Quando usar:

        . Se não retorna dados → ExecuteNonQuery

        . Se retorna muitas linhas → ExecuteReader

        . Se retorna um único valor → ExecuteScalar

. Parâmetros

    . Os parâmetros também podem ser enviados da seguinte forma:

        cmd.Parameters.Add( new MySqlParameter("@nome", "Jose Saramago"));
        cmd.Parameters.Add( new MySqlParameter("@dataAniversario", "2010-10-17"));

        ou

        cmd.Parameters.Add( new MySqlParameter( parameterName : "@dataAniversario", value: "2010-10-17"));

        ou

        cmd.Parameters.Add("@nome", MySqlDbType.VarChar, 100)
                      .Value = "Jose Camargo";        

    . Boas práticas técnicas

        . Sempre definir tipo (MySqlDbType)

        . Definir tamanho quando aplicável (VARCHAR)

        . Evitar AddWithValue (problemas de inferência)

. Demo

    . Implemente o método abaixo na classe "ConnectionModel".

        ...
        public string GetClientesCountScala()
        {
            string version = string.Empty;

            try
            {

                string cs = @"server=localhost;userid=root;password=root;database=adoNetSystem";

                string sql = "SELECT VERSION()";

                using (MySqlConnection con = new MySqlConnection(cs))
                {
                    using (MySqlCommand cmd = new MySqlCommand(sql, con))
                    {
                        con.Open();

                        version = (string)cmd.ExecuteScalar();

                        Console.WriteLine($"A versão do Servidor MySQL é: {version}");
                    }
                }
            }
            catch (Exception ex)
            {
                throw new Exception("Ocorreu o seguinte Erro: " + ex.ToString());
            }

            return version;
        }
        ...

    . Implemente a linha abaixo na classe "Program.cs":

        using AdoNet;

        ConnectionModel cm = new ConnectionModel();

        // Apague a linha abaixo
        // cm.OpenConnection();

        // Insira a linha abaixo
        string version = cm.GetClientesCountScala();

    . Execute o projeto debugando a partir da linha acima da classe "ConnectionModel" e veja o resultado.

    . Implemente o método abaixo na classe ConnectionModel.cs:

        // Linha inserida
        using System.Data;
        ...

        // Método inserido
        public long InsertCliente()
        {
            long rowsAffected = 0;
            string cs = @"server=localhost;userid=root;password=root;database=adoNetSystem";

            try
            {
                using (MySqlConnection cn = new MySqlConnection(cs))
                {
                    cn.Open();

                    var dml = "DROP TABLE IF EXISTS cliente; CREATE TABLE cliente ( id INT AUTO_INCREMENT PRIMARY KEY, nome VARCHAR(100) NOT NULL, dataAniversario DATE NOT NULL );";

                    using (MySqlCommand cmd = new MySqlCommand(dml, cn))
                    {
                        cmd.CommandType = CommandType.Text;
                        cmd.ExecuteNonQuery();
                    }

                    string sql = @"INSERT INTO cliente( nome, dataAniversario ) VALUES( @nome, @dataAniversario )";

                    using (MySqlCommand cmd = new MySqlCommand(sql, cn))
                    {
                        cmd.CommandType = CommandType.Text;

                        cmd.Parameters.Add("@nome", MySqlDbType.VarChar, 100)       // O tamanho (100) pode ser opcional
                                        .Value("Cecilia Meireles");

                        cmd.Parameters.Add("@dataAniversario", MySqlDbType.DateTime)
                                      .Value(, "1966-10-17");

                        rowsAffected = cmd.ExecuteNonQuery();
                    }
                }
            }
            catch (Exception ex)
            {

                throw new Exception("Ocorreu o seguinte erro: " + ex.ToString());
            }

            return rowsAffected;
        }

        . ExecuteNonQuery - Não retorna dados de consulta, mas retorna o número de linhas afetadas em UPDATE, INSERT e DELETE 
            (para os demais retornará -1), é utilizado geralmente para fazer Inserts, Updates e Deletes. Use para inserir, atualizar
            e apagar dados do banco de dados.

    . Implemente a linha abaixo na classe "Program.cs":

        using AdoNet;

        ConnectionModel cm = new ConnectionModel();

        // Apague a linha abaixo
        // string version = cm.GetClientesCountScala();

        // Insira a linha abaixo
        var rowsAffected = cm.InsertCliente();

    . Execute o projeto


    . Implemente o método abaixo na classe ConnectionModel.cs:

        public void GetallCliente()
        {
            var cs = @"server=localhost;userid=root;password=root;database=adoNetSystem";

            try
            {
                using var cn = new MySqlConnection(cs);
                using var cmd = new MySqlCommand("SELECT * FROM cliente", cn);

                cn.Open();

                using MySqlDataReader rdr = cmd.ExecuteReader();

                while (rdr.Read())
                {
                    System.Console.WriteLine($"({rdr.GetInt16(0)}) -> {rdr.GetString(1)} - Date of Birthday {rdr.GetDateTime(2)}\n");
                }
            }
            catch (System.Exception)
            {
                
                throw;
            }
        }

    . Altere as linhas abaixo na classe "Program":

        using AdoNet;

        ConnectionModel cm = new ConnectionModel();

        cm.GetallCliente(); // Linha inserida

    . Crie a procedure abaixo numa pasta do disco

        DELIMITER $$

        DROP PROCEDURE IF EXISTS spUpdateCliente $$

        CREATE PROCEDURE spUpdateCliente( IN prId INT, IN prNome VARCHAR(100), IN prDataAniversario DATE)
        BEGIN
            UPDATE cliente
            SET Nome = prNome,
                DataAniversario = prDataAniversario
            WHERE Id = prId;

        END $$

        DELIMITER ;

    . Execute o comando abaixo no prompt do sistema operacional:

        docker cp "d:\temp\spUpdateCliente.sql" adoNetSystemDb:/tmp/spUpdateCliente.sql

    . Acesse o banco de dados e compile a procedure

        docker exec -it adoNetSystemDb mysql -u root -p

        use adoNetSystem;

        SOURCE /tmp/spUpdateCliente.sql

        # Comandos interessantes do MySQL para verificar se a procedure foi criada com sucesso
        SHOW PROCEDURE STATUS WHERE Db = DATABASE() AND Name = 'spUpdateCliente'; -- Lista todas as procedures do database

        SHOW CREATE PROCEDURE spUpdateCliente;  -- Lista o corpo da procedure

    . Crie o método abaixo no arquivo "ConnectionModel":

        ...
        public void UpdateClienteStoredProcedure()
        {
            using (MySqlConnection cn = new MySqlConnection(@"server=localhost;userid=root;password=root;database=adoNetSystem"))
            {
                cn.Open();

                using (MySqlCommand cmd = new MySqlCommand("spUpdateCliente", cn))
                {
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@prNome", MySqlDbType.VarChar,100).Value = "MARCOS SILVA";
                    cmd.Parameters.Add("@prDataAniversario", MySqlDbType.Date).Value = "1985-05-20";
                    cmd.Parameters.Add("@prId", MySqlDbType.Int64).Value = 1;

                    /*
                    MySqlParameter output = new MySqlParameter("@IdGerado", SqlDbType.Int)
                    {
                        Direction = ParameterDirection.Output
                    };
                    cmd.Parameters.Add(output);
                    */

                    cmd.ExecuteNonQuery();

                    // int id = (int)cmd.Parameters["@IdGerado"].Value;
                }
            }
        }

    . Altere as linhas abaixo na classe "Program":

        using AdoNet;

        ConnectionModel cm = new ConnectionModel();

        // string version = cm.GetClientesCountScala();
        // var rowsAffected = cm.InsertCliente();

        // Insira a linha abaixo
        cm.UpdateClienteStoredProcedure();

    . Execute o projeto

. Using OUTPUT Parameters

    . Um parâmetro de saída é um canal de retorno controlado entre o banco e a aplicação.

    . Ele serve para:

        . Retornar status da operação

        . Retornar IDs gerados

        . Retornar mensagens de negócio

        . Retornar valores calculados internamente

    . Diferente de um SELECT, o OUT não faz parte do result set — ele faz parte do contrato da procedure.

    . Diferença entre SELECT, RETURN e OUT:

        Técnica	    MySQL   Uso
        -------     -----   ---
        SELECT	    ✔	    Retornar dados (linhas/colunas)
        RETURN	    ❌	   MySQL não suporta retorno escalar como SQL Server
        OUT	        ✔	    Retornar controle e metadados

    . No MySQL, parâmetros OUT são o “RETURN real”

    . Passo a passo para utilizar parâmetros de saída:

        . Você define o parâmetro como Direction = Output

            MySqlParameter output = new MySqlParameter("@IdGerado", SqlDbType.Int)
            {
                Direction = ParameterDirection.Output
            };

            cmd.Parameters.Add(output);

        . O provider envia o comando ao MySQL

        . O MySQL executa a procedure

        . O valor do OUT é armazenado no buffer do comando

        . Após ExecuteNonQuery, o valor é populado em Parameter.Value

    . Antes do ExecuteNonQuery, o valor sempre será null

. Demo

    . Crie o arquivo abaixo numa pasta qualquer, com o nome de "spInsertCliente.sql":

        DELIMITER $$

        DROP PROCEDURE IF EXISTS spUpdateCliente $$

        CREATE PROCEDURE spinsertCliente( IN prNome VARCHAR(100), IN prDataAniversario DATE, OUT prId INT)
        BEGIN
            INSERT INTO cliente(Nome, DataAniversario) VALUES (prNome, prDataAniversario);

            SET prId = LAST_INSERT_ID();
        END $$

        DELIMITER ;

    . Execute o comando abaixo no prompt do sistema operacional:

        docker cp "d:\temp\spInsertCliente.sql" adoNetSystemDb:/tmp/spInsertCliente.sql

    . Acesse o banco de dados e compile a procedure

        docker exec -it adoNetSystemDb mysql -u root -p

        use adoNetSystem;

        SOURCE /tmp/spInsertCliente.sql

        # Comandos interessantes do MySQL para verificar se a procedure foi criada com sucesso
        SHOW PROCEDURE STATUS WHERE Db = DATABASE() AND Name = 'spInsertCliente'; -- Lista todas as procedures do database

        SHOW CREATE PROCEDURE spInsertCliente;  -- Lista o corpo da procedure

    . Insira o método abaixo na classe "ConnectionModel.cs":

        ...
        public void InsertClienteStoredProcedure()
        {
            using (MySqlConnection cn = new MySqlConnection(@"server=localhost;userid=root;password=root;database=adoNetSystem"))
            {
                cn.Open();

                using (MySqlCommand cmd = new MySqlCommand("spInsertCliente", cn))
                {
                    cmd.CommandType = CommandType.StoredProcedure;

                    cmd.Parameters.Add("@prNome", MySqlDbType.VarChar, 100).Value = "MARCOS SILVA";
                    cmd.Parameters.Add("@prDataAniversario", MySqlDbType.Date).Value = "1985-05-20";
                    MySqlParameter output = new MySqlParameter("@prId", SqlDbType.Int)
                    {
                        Direction = ParameterDirection.Output
                    };
                    cmd.Parameters.Add(output);

                    cmd.ExecuteNonQuery();

                    int id = (int)cmd.Parameters["@prId"].Value;
                }
            }
        }
        ...

    . Insira a linha abaixo na classe "Program.cs":

        ...
        cm.InsertClienteStoredProcedure();  // Linha inserida
        ...

    . Execute o projeto e verifique o valor do "id".

    . Crie o método "InsertClienteWithOutputParameter" na classe "ConnectionModel"

        public void InsertClienteWithOutputParameter()
        {
            string cs = @"server=localhost;userid=root;password=root;database=adoNetSystem";

            try
            {
                var sql = @"INSERT INTO cliente( nome, dataAniversario ) VALUES( @nome, @dataAniversario ); 
                                SELECT LAST_INSERT_ID();";

                using var cn = new MySqlConnection(cs);
                using var cmd = new MySqlCommand(sql, cn);  

                cmd.Parameters.Add("@nome", MySqlDbType.VarChar).Value = "Libero Badaró";
                cmd.Parameters.Add("@dataAniversario", MySqlDbType.Date).Value = "1960-10-17";

                cn.Open();
                cmd.ExecuteScalar();

                long id = Convert.ToInt64(cmd.ExecuteScalar());

            }
            catch (System.Exception)
            {
                
                throw;
            }

        }

    . Insira a linha abaixo na classe "Program.cs":

        ...
        cm.InsertClienteWithOutputParameter();  // Linha inserida
        ...

    . Execute o projeto e verifique o valor do "id"

. Modelo Desconectado ( DataTable, DataSet e SqlDataAdapter )

    . O objetivo do modelo desconectado é trabalhar com dados fora da conexão, mantendo-os em memória, permitindo:

        leitura  \
                  |
        edição    |  
                  |----> sincronizar depois com o banco.    
        inclusão  |                 |
                  |                 |
        exclusão /                  |
                                    |
                                    V
                        A conexão com o banco:

                            . fica aberta o mínimo possível

                            . melhora performance

                            . melhora escalabilidade

    . Visão geral do módelo desconectado:

                Banco de Dados
                    ↑
                SqlDataAdapter
                    ↑
                DataTable / DataSet  (memória)
                    ↓
                Alterações (Insert/Update/Delete)
                    ↓
                SqlDataAdapter.Update()
                    ↓
                Banco de Dados

    . DataTable

        . Representa uma tabela inteira em memória.

            . Estrutura (colunas, tipos)

            . Dados (linhas)

            . Estado das linhas (Added, Modified, Deleted)

        . Ele não sabe nada sobre o banco. Ele apenas armazena dados.

        . Exemplos:

            . Criando a tabela:

                var table = new DataTable("cliente");

                table.Columns.Add("id", typeof(int));
                table.Columns.Add("nome", typeof(string));
                table.Columns.Add("dataAniversario", typeof(DateTime));

                table.Rows.Add(1, "Ana",  new DateTime(2001, 2, 10););
                table.Rows.Add(2, "João", new DateTime(2008, 12, 28););

            . Alterando dados

                table.Rows[0]["Nome"] = "Ana Maria";        // O ADO.NET automaticamente marca a linha como: RowState = Modified

            . Podemos inserir uma "Primary Key" no objeto DataTable:

                table.PrimaryKey = new[] { table.Columns["id"] };


        . Existem diversas maneiros para localizar/selecionar/filtrar ocorrências dentro de um objeto DataTable:

            . DataTable.Select() - permite filtrar linhas em memória, usando uma expressão parecida com SQL (WHERE).Retorna um array de DataRow.

                DataRow[] linhas = table.Select("Id = 10");
                
                DataRow[] resultado = table.Select("nome = 'Ana'");

                DataRow[] linhas = table.Select("Id > 1");

                DataRow[] resultado = table.Select("nome = 'Ana' AND id < 2 " );

                DataRow[] resultado = table.Select("nome LIKE '%Silva%'");

                DataRow[] resultado = table.Select("Status IN ('A', 'I')");

                DataRow[] resultado = table.Select("dataAniversario >= #2025-01-01#");



                // Filtra e deixa o resultado ordenado
                DataRow[] linhas = table.Select("Id > 0, nome ASC ");   

            . DataView - é uma visão filtrada de um DataTable (sem duplicação de dados e ideal para filtros dinâmicos)

                DataView view = new DataView(table);

                view.RowFilter = "Saldo > 1000";

                view.Sort = "Nome ASC";


                // Percorrendo o resultado
                foreach (DataRowView row in view)
                {
                    Console.WriteLine(row["Nome"]);
                }

            . Buscando a linha:

                DataRow row = table.Rows.Find(10);

            . LINQ

                var resultado = table.AsEnumerable()
                                        .Where( row => row.Field<int>("Id") > 0 )
                                        .OrderByDescending( row => row.Field<string>("nome") )
                                        .ToList();

                resultado.ForEach( row => 
                {
                    Console.WriteLine($"Id: {row.Field<int>("Id")}, Nome: {row.Field<string>("nome")}, Data Aniversário: {row.Field<DateTime>("dataAniversario")}");
                } );



                OU

                var cliente = table.AsEnumerable()
                   .FirstOrDefault(r => r.Field<int>("Id") == 10);

        . Comparação

            Método              Melhor cenário         
            -------------       ---------------------- 
            `Select()`          Filtro simples         
            `DataView`          UI / filtros dinâmicos 
            `Rows.Find()`       Busca por chave        
            LINQ                Regras complexas       

