Curso Fullstack Angular e Spring (Angular, REST e Spring Boot) - Algaworks
--------------------------------------------------------------------------


Aula 03.01. Criando o projeto da API
------------------------------------

. Crie um projeto spring boot com as seguintes configurações:

    Name : Algamoney-api
    Group : com.algaworks.algamoney-api
    Artefact : algamoney-api
    Package : com.example.algamoney-api

. Nas dependências, adicione as seguintes bibliotecas:

    Devtools
    JPA
    Web
    MySQL / h2 / PostGres


Aula 03.02. Conectando ao MySQL
-------------------------------

. Acesse o arquivo application.properties e insira o código abaixo dependendo do banco que for ser utilizado:

    # ===============================
    # = data.sql file will be executed?
    # ===============================
    spring.datasource.initialization-mode=always

    # Far� somente os update das diferen�as entre as classes model com o BD
    spring.jpa.hibernate.ddl-auto=update

    spring.jpa.show-sql=true

    # Conectando com o MySQL
    ########################
    spring.jpa.database=MYSQL
    spring.datasource.url=jdbc:mysql://localhost/algamoneyapi?createDatabaseIfNotExist=true&useSSL=false
    spring.database.username=root
    spring.database.password=root


    # Connection com o POSTGRES
    ###########################
    #spring.datasource.platform=postgres
    #spring.datasource.url=jdbc:postgresql://localhost:5432/desenv
    #spring.datasource.username=supervisor
    #spring.datasource.password=brasil2




    # Conexão com o H2
    ##################
    spring.datasource.driverClassName=org.h2.Driver
    spring.datasource.username=sa
    spring.datasource.password=
    spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

    #Enabled H2 COnsole
    spring.h2.console.enabled=true

    # Custom H2 Console URL
    spring.h2.console.path=/h2
    # temporary data storage
    spring.datasource.url = jdbc:h2:mem:testdb

. Execute a aplicação para ver se ela levanta.

. Acesse o link http://localhost:8080/h2 com user "sa" sem senha e veja se as tabelas foram criadas com sucesso


Aula 03.03. Criando a estrutura das tabelas
-------------------------------------------

. Dentro da pasta resources crie o arquivo schema.sql com o conteúdo abaixo:

    CREATE TABLE categoria( codigo SERIAL NOT NULL PRIMARY KEY,
                            nome VARCHAR(50) NOT NULL );

. Dentro da pasta resources crie o arquivo data.sql com o conteúdo abaixo:

    INSERT INTO categoria( nome ) VALUES('Lazer');
    INSERT INTO categoria( nome ) VALUES('Alimentação');
    INSERT INTO categoria( nome ) VALUES('Supermercado');
    INSERT INTO categoria( nome ) VALUES('Farmácia');
    INSERT INTO categoria( nome ) VALUES('Cultura');
    INSERT INTO categoria( nome ) VALUES('Outros');

    

Aula 03.04. Consultando primeiro recurso com GET
------------------------------------------------

. Crie a classe model abaixo:

package com.example.algamoneyapi.model;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table
public class Categoria implements Serializable {

	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue( strategy=GenerationType.IDENTITY)
	private Long codigo;
	
	@Column
	private String nome;

	public Long getCodigo() {
		return codigo;
	}

	public void setCodigo(Long codigo) {
		this.codigo = codigo;
	}

	public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}

	@Override
	public String toString() {
		return "Categoria [codigo=" + codigo + ", nome=" + nome + "]";
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((codigo == null) ? 0 : codigo.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Categoria other = (Categoria) obj;
		if (codigo == null) {
			if (other.codigo != null)
				return false;
		} else if (!codigo.equals(other.codigo))
			return false;
		return true;
	}

	public Categoria(String nome) {
		super();
		this.nome = nome;
	}

	public Categoria() {
		super();
	}
}


. Crie a interface Repository abaixo:

    package com.example.algamoneyapi.repository;

    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.stereotype.Repository;

    import com.example.algamoneyapi.model.Categoria;

    @Repository("pessoaRepository")
    public interface CategoriaRepository extends JpaRepository<Categoria, Long> {

    }

. Crie a classe Resource abaixo:

    package com.example.algamoneyapi.resource;

    import java.util.List;
    import java.util.Optional;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    import com.example.algamoneyapi.model.Categoria;
    import com.example.algamoneyapi.repository.CategoriaRepository;

    @RestController
    @RequestMapping("categoria/api")
    public class CategoriaResource {

        @Autowired
        private CategoriaRepository categoriaRepository;
        
        @GetMapping
        public List<Categoria> findAll(){
            
            return categoriaRepository.findAll();
        }
        
        @GetMapping(path= "{codigo}")
        public Optional<Categoria> findById( @PathVariable Long codigo ) {
            
            return categoriaRepository.findById(codigo);
            
            
        }
    }

. Testar os metodos da API:

    . Acesse o Postman;

    . Crie e Teste as URLs abaixo:

        Method : GET
        URL : http://localhost:8080/categoria/api/

        Method : GET
        URL : http://localhost:8080/categoria/api/1

    . Vá em Collection, crie uma coleção de urls e selecione as URLs acima para a Collection criada;
    


Aula 3.6. Cadastrando nova categoria com POST
---------------------------------------------

    . Insira o método abaixo na classe CategoriaResource:

            @PostMapping
            // De forma simples podemos utilizar a annotation abaixo para retornar o código de Status
            // para o Client que retornará 201 Created se tudo der certo. Caso contrário podemos retornar
            // fazer de forma mais detalhada com ResponseEntity, informando detalhes para o Body.Pretty e
            // Headers.Location
            // @ResponseStatus( HttpStatus.CREATED)     
            public ResponseEntity<Categoria> insert(@RequestBody Categoria categoria, 
                                HttpServletResponse response) {
                Categoria categoriaSalva = categoriaRepository.save(categoria);
                
                URI uri = ServletUriComponentsBuilder.fromCurrentRequestUri().path("/{codigo}")
                            .buildAndExpand(categoriaSalva.getCodigo()).toUri();
                
                response.setHeader("Location", uri.toASCIIString());
                
                return ResponseEntity.created(uri).body(categoriaSalva);
            }

    . O @RequestBody, ou corpo da requisição, é onde geralmente enviamos dados que queremos gravar no servidor. 
        Não é muito utilizado em requisições do tipo GET, mas sim nas do tipo POST e PUT. É no corpo da 
        requisição onde você envia dados de um formulário de cadastro em seu site

    . Teste o metodo da API Post:

        . Crie e Teste a URL abaixo:

            Method : POST
            URL : http://localhost:8080/categoria/api/
            Body.raw : { "nome" : "Impostos" }
            Body.JSON

        . No method POST verifique o resultado Body.Pretty e Headers.Location


        . adicione o Method POST na Collection de URLs. 



Aula 03.07. Desafio Retornar 404 caso não exista a categoria
------------------------------------------------------------

    . Atualize o metodo findById pelo abaixo:

        @GetMapping(path = "{codigo}")
        public ResponseEntity<?> findById(@PathVariable Long codigo) {
            try {
                Optional<Categoria> categoria = categoriaRepository.findById(codigo);

                URI uri = ServletUriComponentsBuilder.fromCurrentRequestUri().path("")
                        .buildAndExpand(categoria.getCodigo()).toUri();

                response.setHeader("Location", uri.toASCIIString());

                return categoria.isPresent() ? ResponseEntity.ok(categoria) : ResponseEntity.notFound().build();
            } catch (Exception e) {
                return ResponseEntity.badRequest().body(e.getMessage());
            }
        }

    . Atualize o metodo findAll pelo abaixo:

        @GetMapping
        public  ResponseEntity<?> findAll() {

            List<Categoria> categorias = null;

            try {
                categorias = categoriaRepository.findAll();

                return ResponseEntity.ok(categorias);
            } catch (Exception e) {
                return ResponseEntity.badRequest().body(e.getMessage());
            }

        }

    . Observe a tratativa dentro do try...catch. Mudamos o tipo do retorno do metodo para utilizar o retorno com ResponseEntity.
        Aproveitamos para atualizar o header da resposta atraves do objeto response. Na página web, nas infs da header, podemos
        encontrar a URL restful para poder acessar a informação localizada, na "Location".



Aula 03.08. Validando atributos desconhecidos
---------------------------------------------

    . Se quisermos obrigar que toda desserialização dos parâmetros seja obrigatoriamente igual ao que estamos recebendo nos método, 
        utilizaremos a claúsula abaixo no arquivo application.properties. Se isto for usado, sempre que vier um propriedade/parâmetro
        a mais, ou a menos, uma exceção será levantada.

        spring.jackson.deserialization.fail-on-unknown-properties=true

        Exemplo:

            No Client

                { "codigo" : 10,
                    "nome" : "Imposto",
                    "observacao" : "Imposto"
                }

            No Server

                public ResponseEntity<Categoria> insert(@RequestBody Categoria categoria, 
                                                HttpServletResponse response) {
                    ...
                }

                // Uma exceção será levantada por conta da nova informação "observacao"

    . StatusCode

        2xx -> Sucesso
        4xx -> Erro do cliente
        5xx -> Erro no serviço/servidor


Aula 03.09. Tratando erros com ExceptionHandler
-----------------------------------------------

    . Considerando que iremos recusar parâmetros que não se enquadram na estrutura da classe categoria, onde irá levantar exception caso a 
        estrutura do parâmetro não coincida com a estrutura da classe. Trabalharemos com classe de exceção.

    . Crie a classe abaixo:

        package com.example.algamoneyapi.exceptionhandler;

        import org.springframework.http.HttpHeaders;
        import org.springframework.http.HttpStatus;
        import org.springframework.http.ResponseEntity;
        import org.springframework.http.converter.HttpMessageNotReadableException;
        import org.springframework.web.bind.annotation.ControllerAdvice;
        import org.springframework.web.context.request.WebRequest;
        import org.springframework.web.servlet.NoHandlerFoundException;
        import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

        @ControllerAdvice
        public class AlgamoneyExceptionHandler extends ResponseEntityExceptionHandler {

            @Override
            protected ResponseEntity<Object> handleHttpMessageNotReadable(HttpMessageNotReadableException ex,
                    HttpHeaders headers, HttpStatus status, WebRequest request) {
                // TODO Auto-generated method stub

                return handleExceptionInternal(ex, "Mensagem Invalida", headers, HttpStatus.BAD_REQUEST, request);
            }

            
            @Override
            protected ResponseEntity<Object> handleNoHandlerFoundException(NoHandlerFoundException ex, HttpHeaders headers,
                    HttpStatus status, WebRequest request) {
                // TODO Auto-generated method stub
                return handleExceptionInternal(ex, "Informação não encontrada!!!", headers, HttpStatus.BAD_REQUEST, request);
            }

        }


    . Faça o teste no Postman com os parâmetros abaixo:

        Method : POST
        URL : http://localhost:8080/categoria/api/

        // Configure o tipo do parâmetro como JSON
        Body.raw :

            { "codigo" : 10,
                "nome" : "Imposto",
                "observacao" : "Imposto"
            }


Aula 03.10. Validando valores inválidos com Bean Validation
-----------------------------------------------------------

    . Como estamos utilizando o Spring 2.x.x. é necessário colocar no pom.xml a dependência abaixo:

 		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>


    Forma Simples de implementar o Bean Validation:
    -----------------------------------------------

        . Na classe model Categoria adicione as annotation de validação como abaixo:

            @Column
            @NotNull( message="Valor não pode ser nulo")
            @Max(value=50, message="Valor máximo permitido 50 caracteres")
            private String nome;

        . Na classe resource CategoriaResource atualize o metodo POST pelo código abaixo:

            @PostMapping
            public ResponseEntity<?> insert( @Valid @RequestBody Categoria categoria, BindingResult result ) {
                
                if ( result.hasErrors() ) { 
                    Map<String, String> errors = new HashMap<>();
                 
                    for ( FieldError error : result.getFieldErrors()) { 
                        errors.put( error.getField(), error.getDefaultMessage()); 
                    }
                
                    return ResponseEntity.unprocessableEntity().body(errors); 
                }

                try {
                    Categoria categoriaSalva = categoriaRepository.save(categoria);
                } catch (Exception e) {
                    return ResponseEntity.badRequest().body(e.getMessage());
                }
            }

        . Existe uma desvantagem nessa abordagem. Na assinatura do método não temos como utilizar como parâmetro
            o objeto HttpServletResponse response, sem isso não conseguimos montar o cabeçalho de resposta para o 
            cliente.

        . A annotation @Valid força a validação diretamente na assinatura do método.

    Forma mais completa de implementar o Bean Validation com ExceptionHandle:
    -------------------------------------------------------------------------

        . Na classe model Categoria adicione as annotation de validação como abaixo:

            @Column
            @NotNull
            @Size(min=4, max=50, message="Valor deverá ter o tamanho entre 4 e 50 caracteres")
            private String nome;

        . Podemos configurar as mensagens de erro de duas formas. A primeira colocando a mensagem
            como parâmetro da annotation @...(message="mensagem"); a segunda utilizando arquivos de 
            propriedades "properties". Detalhe, elas podem trabalhar em conjunto.

        . Altere o método POST da classe Resource como abaixo:

            @PostMapping
            public ResponseEntity<?> insert( @Valid @RequestBody Categoria categoria, HttpServletResponse response ) {
                try {
                    Categoria categoriaSalva = categoriaRepository.save(categoria);

                    URI uri = ServletUriComponentsBuilder.fromCurrentRequestUri().path("/{codigo}")
                            .buildAndExpand(categoriaSalva.getCodigo()).toUri();

                    response.setHeader("Location", uri.toASCIIString());

                    return ResponseEntity.created(uri).body(categoriaSalva);
                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    return ResponseEntity.badRequest().body(e.getMessage());
                }

            }

        . Só com a implementação acima podemos realizar testes de validação da API. Faça o teste no Postman com os 
            parâmetros abaixo:

            Method : POST
            URL : http://localhost:8080/categoria/api/

            // Configure o tipo do parâmetro como JSON
            Body.raw :

                { 
                    "nome" : null
                }

        . Já dessa forma o StatusCode retorna para a aplicação será 400.

        . Dentro do pacote resources crie o arquivo de propriedades abaixo com o nome message.properties:

            mensagem.invalida=Mensagem inv\u00E1lida

            categoria.nome=Nome        

        . Implemente os métodos e a inner class abaixo na classe ExceptionHandle:

            @ControllerAdvice
            public class AlgamoneyExceptionHandler extends ResponseEntityExceptionHandler {

                // A annotation abaixo injeta a referência do arquivo message.properties
                @Autowired
                private MessageSource messageSource;

                ...
                
                @Override
                protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex,
                        HttpHeaders headers, HttpStatus status, WebRequest request) {
                    // TODO Auto-generated method stub
                    List<Erro> erros = criarListaErro(ex.getBindingResult());
                    
                    return handleExceptionInternal(ex, erros, headers, HttpStatus.BAD_REQUEST, request);
                }
                
                
                private List<Erro> criarListaErro( BindingResult bindingResult){
                    
                    List<Erro> erros = new ArrayList<>();
                    
                    for( FieldError fieldError : bindingResult.getFieldErrors() ) {
                        String mensagemUsuario = messageSource.getMessage(fieldError, LocaleContextHolder.getLocale());
                        String mensagemDesenvolvedor =  fieldError.toString();
                        
                        erros.add(new Erro(mensagemUsuario, mensagemDesenvolvedor));
                    }
                    
                    return erros;
                }

                public static class Erro {
                    
                    private String mensagemUsuario;
                    private String mensagemDesenvolvedor;
                    
                    public Erro( String mensagemUsuario, String mensagemDesenvolvedor ) {
                        
                        this.mensagemUsuario = mensagemUsuario;
                        this.mensagemDesenvolvedor = mensagemDesenvolvedor;
                    }

                    public String getMensagemUsuario() {
                        return mensagemUsuario;
                    }

                    public void setMensagemUsuario(String mensagemUsuario) {
                        this.mensagemUsuario = mensagemUsuario;
                    }

                    public String getMensagemDesenvolvedor() {
                        return mensagemDesenvolvedor;
                    }

                    public void setMensagemDesenvolvedor(String mensagemDesenvolvedor) {
                        this.mensagemDesenvolvedor = mensagemDesenvolvedor;
                    }
                    
                }
            }

        . Sempre que houver uma exceção de validação, o método handleMethodArgumentNotValid será executado. 
            Observe no método criarListaErro 

        . Para deixar as mensagens mais amigáveis crie o arquivo ValidationMessages.properties dentro da pasta resource.
            Este arquivo tem que seguir esse padrão de nomenclatura para ser reconhecido automaticamente dentro da classe
            ExceptionHandler.

            javax.validation.constraints.NotNull.message={0} \u00e9 obrigat\u00f3rio(a)
            #javax.validation.constraints.Size.message={0} deve ter o tamanho entre {min} e {max}

        . Para encontrar as chaves desse arquivo basta clicar em cima da annotation de validação (@NotNull, @Size, ...) com
            com Ctrl+Clique do mouse que será apresentado o fonte da annotation e lá dentro apresenta a chave, por exemplo:

            String message() default "{javax.validation.constraints.NotNull.message}";  // Retirado da annotation @NotNull

        . Esse recurso é vantanjoso porque acaba configurando uma mensagem padrão para todas as annotation feita dentro da classe
            Model. 

        . No arquivo ValidationMessages.properties foi configurado a chave e valor 
            "javax.validation.constraints.NotNull.message={0} \u00e9 obrigat\u00f3rio(a)". O conteúdo {0} e o parâmetro que será o 
            nome da propriedade que está levantando a exceção. Por exemplo: se a propriedade nome da categoria levantar exceção a 
            mensagem que aparecerá será "nome é obrigatorio". 

        . Veja que na mensagem produzida a mensagem ficou com nome em letra miniscula. Se quisermos deixar mais amigável ainda coloque o 
            conteúdo abaixo no arquivo messages.properties:

            categoria.nome=Nome

        . Isto fará a mensagem sair "Nome é obrigatorio".

        
Aula 03.12. Usando eventos para adicionar header Location
--------------------------------------------------------

. Criar as classes de evento e de listener abaixo:

    package com.example.algamoneyapi.event;

    import javax.servlet.http.HttpServletResponse;

    import org.springframework.context.ApplicationEvent;

    public class RecursoCriadoEvent<T,K> extends ApplicationEvent {

        /**
        * 
        */
        private static final long serialVersionUID = 1L;

        private HttpServletResponse response;
        private K codigo;
        
        public RecursoCriadoEvent(Object source, HttpServletResponse response, K codigo) {
            super(source);

            this.response = response;
            this.codigo = codigo;
        }

        public HttpServletResponse getResponse() {
            return response;
        }

        public K getCodigo() {
            return codigo;
        }

        
        
    }


    package com.example.algamoneyapi.event.listener;

    import java.net.URI;

    import javax.servlet.http.HttpServletResponse;

    import org.springframework.context.ApplicationListener;
    import org.springframework.stereotype.Component;
    import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

    import com.example.algamoneyapi.event.RecursoCriadoEvent;

    @Component
    public class RecursoCriadoListener implements ApplicationListener<RecursoCriadoEvent>{

        @Override
        public void onApplicationEvent(RecursoCriadoEvent event) {

            HttpServletResponse response = event.getResponse();
            Object codigo = event.getCodigo();
            
            URI uri = ServletUriComponentsBuilder.fromCurrentRequestUri().path("/{codigo}")
                    .buildAndExpand(codigo).toUri();

            response.setHeader("Location", uri.toASCIIString());		
            
        }

    }


. Alterar o metodo POST:

    . De

        @PostMapping
        public ResponseEntity<?> insert( @Valid @RequestBody Pessoa pessoa, HttpServletResponse response ) {
            try {
                Pessoa pessoaSalva = pessoaRepository.save(pessoa);

                URI uri = ServletUriComponentsBuilder.fromCurrentRequestUri().path("/{codigo}")
                        .buildAndExpand(pessoaSalva.getCodigo()).toUri();

                response.setHeader("Location", uri.toASCIIString());

                return ResponseEntity.created(uri).body(pessoaSalva);
            } catch (Exception e) {
                // TODO Auto-generated catch block
                return ResponseEntity.badRequest().body(e.getMessage());
            }

        }

    . Para

        @PostMapping
        public ResponseEntity<?> insert( @Valid @RequestBody Pessoa pessoa, HttpServletResponse response ) {
            try {
                Pessoa pessoaSalva = pessoaRepository.save(pessoa);

                publisher.publishEvent( new RecursoCriadoEvent<Pessoa, Long>( this, response, pessoaSalva.getCodigo()));
                
                return ResponseEntity.status(HttpStatus.CREATED).body(pessoaSalva);
            } catch (Exception e) {
                return ResponseEntity.badRequest().body(e.getMessage());
            }
        }


Aula 04.01. Removendo pessoa com DELETE
---------------------------------------

    . Inclua o método abaixo na classe PessoaResource

        @DeleteMapping("{codigo}")
        @ResponseStatus(HttpStatus.NO_CONTENT)
        public void remove( @PathVariable Long codigo) {
            pessoaRepository.deleteById(codigo);
        }

    . Inclua o método abaixo na classe AlgamoneyExceptionHandler:

            @ExceptionHandler(EmptyResultDataAccessException.class)
        //	@ResponseStatus(HttpStatus.NOT_FOUND)
            public ResponseEntity<?> handleEmptyResultDataAccessException(EmptyResultDataAccessException ex, WebRequest request) {
                List<Erro> erros = new ArrayList<>();
                
                String mensagemUsuario = ex.getMessage();
                String mensagemDesenvolvedor =  ex.getMessage().toString();
                
                erros.add(new Erro(mensagemUsuario, mensagemDesenvolvedor));
                
                return handleExceptionInternal(ex, erros, new HttpHeaders(), HttpStatus.NOT_FOUND, request);
            }

    . O método acima não faz parte da implementação padrão da interface ResponseEntityExceptionHandler que a classe AlgamoneyExceptionHandler implementa.
        Sempre que quisermos incluir um método próprio podemos faze-lo através da 