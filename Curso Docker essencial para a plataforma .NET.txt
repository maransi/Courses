Curso Dicker essencial para a plataforma .NET


Aula 5. Instalando o Docker
---------------------------

. No caso do windows, acesse a URL abaixo e baixe o instalador:

    https://store.docker.com/editions/community/docker-ce-desktop-windows

. Utilizar a versão Community Edition (CE)

. No caso do Linux execute os comandos abaixo no prompt no terminal:

    . A URL abaixo tem os passos atualizado para instalação do Docker:

        https://docs.docker.com/engine/install/ubuntu/

	. Instalação nas distribuições Ubuntu

        sudo apt-get update
        sudo apt-get install ca-certificates curl
        sudo install -m 0755 -d /etc/apt/keyrings
        sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
        sudo chmod a+r /etc/apt/keyrings/docker.asc

        echo \
        "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
        $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
        sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

        sudo apt-get update
        sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        docker --version

        sudo groupadd docker
        sudo gpasswd -a $USER docker
        sudo chown "$USER":"$USER" /var/run/docker.sock -R
        docker --version
        docker ps -a

        sudo docker run hello-world

    . Instalação no Mint

        sudo apt-get update
        cd Downloads/
        sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
        sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(. /etc/os-release; echo "$UBUNTU_CODENAME") stable"
        sudo apt-get update
        sudo apt-get -y install docker-ce docker-compose
        sudo usermod -aG docker $USER
        docker --version

        sudo groupadd docker
        sudo gpasswd -a <usuario> docker
        sudo chown "$USER":"$USER" /var/run/docker.sock -R
        sudo service docker restart

        docker --version

    . Instalando no BigLinux

        . Acesse a "Big Store", localize "biglinux-docker-config" e faça a instalação

        ou

        . Execute o comando: 
        
            sudo pacman -Sy biglinux-docker-config

    . Instalando o MySQL

        # Criando container com nome o banco de dados MySQL
        docker container run -e MYSQL_ROOT_PASSWORD=root --name algamoney -d mysql:5.7 				
        docker start algamoney

        docker ps -a
        docker exec -it algamoney bash	
        mysql -u root -p

        docker stop algamoney

    . Instalando o SQL Server

        https://docs.microsoft.com/pt-br/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash
        https://docs.microsoft.com/pt-br/sql/linux/sql-server-linux-setup-tools?view=sql-server-ver15#ubuntu


        docker container run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=<password>"    -p 1433:1433 --name sql1 --hostname sql1    -d mcr.microsoft.com/mssql/server:2019-latest
        docker container ps -a
        docker container exec -t sql1 cat /var/opt/mssql/log/errorlog | grep connection

        # Testar no linux, não funcionou no windows
        docker container exec -it sql1 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA  -P "$(read -sp "Enter current SA password: "; echo "${REPLY}")"  -Q "ALTER LOGIN SA WITH PASSWORD=\"$(read -sp "Enter new SA password: "; echo "${REPLY}")\""
        docker exec -it sql1 "bash"
        hostname -I
        ip a
        curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
        curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list
        sudo apt-get update 
        sudo apt-get install mssql-tools unixodbc-dev
        sudo apt-get update 
        sudo apt-get install mssql-tools
        echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bash_profile
        echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bashrc
        source ~/.bashrc
        hostname -I
        sqlcmd -S 192.168.0.82,1433 -U SA -P "<password>"


Aula 6. Instalando o .NET Core SDK
----------------------------------

    . Instalçao Atualizada:

        . URL com informações para realizar a instalação.

            https://docs.microsoft.com/pt-br/dotnet/core/install/linux-ubuntu

            . IMPORTANTE: Acesse a instalação da distribuição e versão especifica do linux que estamos utilizando para 
                            proceder os comandos adequadamente.

                            A instalação abaixo está para o Ubuntu 20.04

        # Instalação do SDK
        wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
        sudo dpkg -i packages-microsoft-prod.deb

        sudo dpkg --purge packages-microsoft-prod && sudo dpkg -i packages-microsoft-prod.deb
        sudo apt-get update

        sudo apt-get install -y gpg
        wget -O - https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor -o microsoft.asc.gpg
        sudo mv microsoft.asc.gpg /etc/apt/trusted.gpg.d/
        wget https://packages.microsoft.com/config/ubuntu/{os-version}/prod.list
        sudo mv prod.list /etc/apt/sources.list.d/microsoft-prod.list
        sudo chown root:root /etc/apt/trusted.gpg.d/microsoft.asc.gpg
        sudo chown root:root /etc/apt/sources.list.d/microsoft-prod.list

        sudo apt-get update; \
        sudo apt-get install -y apt-transport-https && \
        sudo apt-get update && \
        sudo apt-get install -y dotnet-sdk-6.0

        sudo apt-get install -y apt-transport-https && \
        sudo apt-get update && \
        sudo apt-get install -y aspnetcore-runtime-6.0

        sudo apt-get install -y dotnet-runtime-6.0


    . Instalação simplificada        

        # Comando para o Ubuntu 22.04 em diante
        # wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.0g-2ubuntu4_amd64.deb
        # sudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb

        . Acesse o link abaixo para baixar o .NET Core 3.1

            https://dotnet.microsoft.com/download

        . Acesse o download "All .NET Core downloads" e baixe a versão 3.1

        . Acesse o link "Package manager instructions" 

        . Localize a versão do Ubuntu que está sendo utilizado, copie e execute os comandos no 
            terminal:

            wget https://packages.microsoft.com/config/ubuntu/20.10/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
            sudo dpkg -i packages-microsoft-prod.deb
            sudo apt-get update;   sudo apt-get install -y apt-transport-https &&   sudo apt-get update &&   sudo apt-get install -y dotnet-sdk-5.0
            sudo apt-get update;   sudo apt-get install -y apt-transport-https &&   sudo apt-get update &&   sudo apt-get install -y aspnetcore-runtime-5.0

    . Para testar a instalação execute os comandos abaixo:

        dotnet --version
        dotnet --help
        dotnet --list
        dotnet --list-runtimes
        dotnet --list-sdks


Aula 7. Instalando o VS Code
----------------------------

    Instalação das extensões do VSCode

            C# 
            C# Extensions
            C# XML Documentation Comments
            vscode-icons (Opcional)
            Docker

        . Atalhos:

            Ctrl + K + D ou Shit + Alt + F:             Identa todo o seu código automaticamente;
            Ctrl + K + C:                               comenta um bloco de linhas;
            Ctrl + K + U:                               descomenta um bloco de linhas;
            Alt + Left Arrow:                           durante a programação, volta um método que você estava navegando;
            Alt + Right Arrow:                          durante a programação, avança um método que você estava navegando;
            Ctrl + .:                                   implementa o método/classe inexistente que você acabou de escrever;
            Ctrl + M + O:                               esconde todas as regions da classe atual;
            Ctrl + Shift + B:                           compila todos os projetos;
            F5:                                         manda depurar um projeto;
            Ctrl + F5:                                  manda executar um projeto;
            F10:                                        durante a depuração, avança uma linha;
            F11:                                        durante a depuração, avança uma linha entrando nos detalhes da mesma;


    Configurar Visual Studio Code para .NETCore

        . Acesse File / Preferences / Settings

        . Digite C#

        . Acesse "C# Configuration / CSharp Format Enabled" e habilite a configuração

        . Digite "Format on save" e habilite a configuração

        . Digite "Final" e habilite a configuração "Files: Insert final newline" e habilite a configuração


Aula 10. Criando Contêineres - I
--------------------------------

    . Um contêiner é um ambiente isolado para seu código. Isso significa que um contêiner não tem conhecimento do seu 
        sistema operacional ou de seus arquivos. Ele é executado no ambiente fornecido pelo Docker Desktop. Os contêineres 
        têm tudo que seu código precisa para ser executado, até um sistema operacional básico

    . Criando um container a partir de uma imagem pronta

        docker container run <imagem>

    . Testando o docker:

        docker container run hello-world
          |       |       |     +-> É a imagem existente usada para criar o container
          |       |       |
          |       |       +-> É a porta de entrada no Docker e realiza 4 operações:
          |       |
          |       |            . Baixa a imagem não localizada localmente: docker image pull
          |       |            . Cria um container: docker container create
          |       |            . Inicializa o container: docker container start
          |       |            . Uso do modo interativo executando um comando: docker container exec
          |       |
          |       |
          |       +-> Indica que o comando irá atuar em um container
          |
          +-> Executor do comando

        . Importante: o "run" executa o container, mas cria sempre um novo container. Faça isso somente uma vez para a imagem desejada.
                        Utilize o comando abaixo "docker container start <nome do container> para executar o container.

    . Exibindo todos os container em processamento no momento:

        docker container ps

    . Exibindo todos os container independente se está, ou não, em processamento

        docker container ps -a

    . Uma imagem Docker contém código de aplicativo, bibliotecas, ferramentas, dependências e outros arquivos necessários para executar um aplicativo. 
        Quando um usuário executa uma imagem, ela pode se tornar uma ou mais instâncias de um contêiner. As imagens Docker têm várias camadas, 
        cada uma originada da camada anterior, mas diferente dela.

    . Exibindo as imagens

        docker images

Aula 11. Criando Contêineres - II
--------------------------------

    . Baixando uma image

        # Para consultar as imagens localmente
        docker images   

        # Para baixar uma imagem
        docker image pull alpine

        # Se quiser fornecer uma versão especifica da imagem utilize como abaixo
        docker image pull alpine:3.6

        # Para consultar as imagens localmente
        docker images   

        # Executa, cria um container e envia um comando para ser executado no container
        docker container run alpine ls -l

        # Consultando os containeres
        docker container ps -a

        # Executa, cria e permanece dentro do container
        docker container run -it alpine /bin/sh

        # Executa um container existente. Importante: Neste caso deixa o container em execução
        docker container start < 4 primeiras posições do CONTAINER ID, ou todo o código do CONTAINER ID >

        # Executa um comando dentro de um container em execução
        docker container exec < 4 primeiras posições do CONTAINER ID, ou todo o código do CONTAINER ID > ls -l
    
        # Parar o container em execução.
        docker container stop < 4 primeiras posições do CONTAINER ID, ou todo o código do CONTAINER ID >

        # Criando container com nome
        docker container run --name alp3 -it alpine 
        docker container start alp3
        docker ps
        
        # Acessará o container, no prompt de comando do SO.
        docker container attach alp3
        docker ps

        # Elimnando container
        docker container rm <container ID ou container name>

        # Eliminando image
        docker image rm <Image Id ou Repository Name:Tag>

Aula 13. Container - Mapeando pastas
------------------------------------

    # Mapeando a porta, faz a associação da porta externa com a interna do container
    docker container run --name ws1 -p 80:80 nginx
                                        |  |
                                        |  +-> No. da porta de dentro do container
                                        +-> No. da porta externa, da máquina de fora
    . Acesse a url abaixo:

        http://localhost:80


    # Execução em segund plano
    docker container run --name ws2 -p 80:80 -d nginx
                                              |
                                              +-> Informa ao docker para executar em segundo plano


Aula 14. Container - Mapeando pastas
------------------------------------

    # Mapeando pasta da máquina local para dentro do container
    docker container run --name ws3 -p 80:80 -v $(pwd)/html:/usr/share/nginx/html -d nginx
                                                |----------||-------------------|
                                                 pasta local  pasta de dentro do
                                                 da máquina     container

    . Acesse a url abaixo:

        # Dará erro de página não encontrada
        http://localhost:80

    . Crie o arquivo abaixo na pasta ~/html/index.html

        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Document</title>
        </head>
        <body>
            Hello World
        </body>
        </html>


Aula 15. Container Docker com .NET
----------------------------------

    https://hub.docker.com/_/microsoft-dotnet-sdk


    # Para baixar a imagem
    docker pull mcr.microsoft.com/dotnet/sdk        ou      docker pull mcr.microsoft.com/dotnet/sdk:3.1        ou          docker pull mcr.microsoft.com/dotnet/sdk:5.0

    docker images

    docker container ps -a

    # Para baixar a imagem e executar em um container
    docker container run --name demo-dotnet -it mcr.microsoft.com/dotnet/sdk:5.0

    # Dentro do container execute os comandos abaixo
    mkdir workspace-dotnet
    mkdir hello-world
    cd workspace-dotnet/hello-world
    dotnet new console
    dotnet build
    dotnet run
    exit

    # Para acessar o container
    docker container ps 

    docker container start -ia demo-dotnet
    

Aula 18. Criando imagens usando Dockfile
----------------------------------------

https://www.alura.com.br/artigos/desvendando-o-dockerfile

    . No Dockfile são definidas instruções que oDocker vai seguir para conseguir realizar a criação de uma image.

        Dockerfile    ------------------>  Docker image
                        docker build

        Dockerfile  ------> Image   ----------> Container
                    build               run

    . Dockfile é como um arquivo de lote que contém instruções com uma sintaxe definica (INSTRUÇÃO arqumento) que devemos seguir para que 
        uma imagem seja criada.

    . Vamos criar uma imagem do Debian 8 com o servidor nginx, os passos para isso são:

        a. Definir uma imagem base

        b. Definir infs para a imagem

        c. Executar comandos para instalar e iniciar o nginx

        d. Expor qual porta o servidor vai atender (no container)

        e. Definir o ponto de entrada a aplicação

        f. Definir a execução de um comando para inicalizar o servidor nginx

    . Cria uma pasta especifica para criar o Dockerfile

    . Dentro da pasta crie um arquivo com o nome "Dockerfile" com o conteúdo abaixo:

        # Identifica a imagem, ou o ponto de partida
        FROM debian:8

        # Descrição da imagem
        LABEL version="1.0" description="Debian/Nginx"

        # Comandos a ser executado na etapa de criação de camadas da imagem
        RUN apt-get update && apt-get install -y nginx && apt-get clean

        # Porta que será exposta
        EXPOSE 80

        # Comando a ser executado, o "nginx" não é uma pasta e sim um comando 
        ENTRYPOINT  ["/usr/sbin/nginx"]

        # Complemento ao comando do ENTRYPOINT a ser executado ficando desta forma "/usr/sbin/nginx -g daemon off;"
        CMD ["-g", "daemon off;"]

    . Após criado o arquivo Dockerfle com o conteúdo acima, execute o comando abaixo no prompt de comandos dentro da pasta
        do Dockerfile:

        docker build -t marcoratti/img:1.0  .
                |     |     |               |
                |     |     |               +-> Significa a pasta local para fazer o build
                |     |     +-> Nome da imagem e a tag atribuida a imagem
                |     +-> Usado p/informar que a imagem pertence ao meu usuário
                +-> Comando que constrói a imagem

    . Depois de construida a imagem, verifique se a imagem foi criada com sucesso:

        docker images

    . Crie um novo container com a imagem recém criada

        docker container run -d -p 80:80 --name=ws1 marcoratti/img:1.0

    . Verifique se o container está em execução:

        docker container ps

    . Acesse o navegador e execute a URL abaixo:

        http://localhost:80

    . Para publicar a imagem criada no docker hub execute os comandos abaixo:

        docker login

        docker push <nome da imagem>

    . Para verificar informações da imagem:

        docker image inspect marcoratti/img:1.0

Aula 20. Criando uma aplicação ASP.NET Core MVC
-----------------------------------------------
    
    . Crie uma pasta para o projeto MVC

        mkdir ~/workspace-dotnet/mvc1

    . Dentro da pasta criada acima crie um projeto dotnet MVC:

        cd ~/workspace-dotnet/mvc1

        dotnet new mvc

        dotnet add package Microsoft.EntityFrameworkCore --version 5.0.1
        dotnet add package Microsoft.EntityFrameworkCore.Design --version 5.0.1
        dotnet add package Pomelo.EntityFrameworkCore.MySql --version 5.0.0-alpha.2
        dotnet add package Microsoft.EntityFrameworkCore.Tools --version 5.0.1


        # Responda "Yes" para criar os arquivos de debug
        code .

    . Dentro da pasta "Models" cria a classe abaixo:

        namespace mvc1.Models
        {
            public class Produto
            {
                public Produto (string nome=null, string categoria=null,
                decimal preco=0)
                {
                    this.Nome = nome;
                    this.Categoria = categoria;
                    this.Preco= preco;
                }

                public int ProdutoId {get; set;}
                public string Nome {get; set;}
                public string Categoria {get; set;}
                public decimal Preco {get; set;}
            }
        }

    . Crie a interface IRepository dentro da pasta "Models":

        using System.Collections.Generic;

        namespace mvc1.Models
        {
            public interface IRepository
            {
                IEnumerable<Produto> Produtos { get; }
            }
        }

    . Crie a classe "TesteRepository" dentro da pasta Models:

        using System.Collections.Generic;

        namespace mvc1.Models
        {
            public class TesteRepository : IRepository
            {
                private static Produto[] produtos = new Produto[] 
                {
                    new Produto{ ProdutoId=10, Nome="Caneta",Categoria="Material", Preco=2.0M},
                    new Produto{ ProdutoId=20, Nome="Borracha",Categoria="Material", Preco=1.5M},
                    new Produto{ ProdutoId=30, Nome="Estojo",Categoria="Material", Preco=3.0M}

                };
                public IEnumerable<Produto> Produtos { get => produtos;}
            }
        }

    . Acesse a classe "Startup.cs" e implemente a linha abaixo:
    
        ...
        using mvc1.Models;

        ...
        public void ConfigureServices(IServiceCollection services)
        {

            services.Configure<CookiePolicyOptions>(options =>
            {
                // This lambda determines whether user consent for non-essential cookies is needed for a given request.
                options.CheckConsentNeeded = context => true;
                options.MinimumSameSitePolicy = SameSiteMode.None;
            });

            services.AddSingleton<IConfiguration>(Configuration);       // LINHA ADICIONADA
            services.AddTransient<IRepository, TesteRepository>();    // LINHA ADICIONADA

            services.AddControllersWithViews();
        }

        ...

    . Altere o "HomeController" como abaixo, Atente para a injeçao de dependência no construtor da classe:

        using System;
        using System.Collections.Generic;
        using System.Diagnostics;
        using System.Linq;
        using System.Threading.Tasks;
        using Microsoft.AspNetCore.Mvc;
        using Microsoft.Extensions.Configuration;
        using mvc1.Models;                          // LINHA INCLUIDA

        namespace mvc1.Controllers
        {
            public class HomeController : Controller
            {
                private IRepository repository;         // LINHA INCLUIDA
                private string message;                 // LINHA INCLUIDA
                public HomeController(IRepository repo, IConfiguration config)  // LINHA ALTERADA
                {
                    repository = repo;                              // LINHA ALTERADA
                    message = $"Docker - ({config["HOSTNAME"]})";    // LINHA ALTERADA
                }
                public IActionResult Index()
                {
                    ViewBag.Message = message;              // ADICIONADO MSG e o REPOSITORIO na VIEW
                    return View(repository.Produtos);
                }
            }
        }

    . Altere o código da classe /Views/Home/Index.cshtml pelo abaixo:

        @model IEnumerable<mvc1.Models.Produto>
        @{
            Layout = null;
        }
        <!DOCTYPE html>
        <html>
        <head>
            <meta name="viewport" content="width=device-width" />
            <title>App</title>
            <link rel="stylesheet" href="~/lib/bootstrap/dist/css/bootstrap.min.css" />
        </head>
        <body>
            <div class="m-1 p-1">
                <h4 class="bg-primary text-xs-center p-1 text-white">@ViewBag.Message</h4>
                <table class="table table-sm table-striped">
                    <thead>
                        <tr><th>ID</th><th>Nome</th><th>Categoria</th><th>Preco</th></tr>
                    </thead>
                    <tbody>
                        @foreach (var p in Model) {
                            <tr>
                                <td>@p.ProdutoId</td>
                                <td>@p.Nome</td>
                                <td>@p.Categoria</td>
                                <td>$@p.Preco.ToString("F2")</td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        </body>
        </html>

    . No prompt do SO digito o comando abaixo:

        dotnet build

        dotnet run

    . Acesse o navegador e execute a URL abaixo:

        https://localhost:5001
        

Aula 21. Criar imagem para a aplicação ASP.NET Core MVC
-------------------------------------------------------

    https://www.pluralsight.com/blog/software-development/how-to-build-custom-containers-docker

    . Publicação da aplicação - Acesse a pasta raiz do projeto ASP.NET e execute o comando abaixo:

        dotnet publish --configuration Realease --output dist
                            |                       |
                            |                       +-> Especifica que o projeto compilado será copiado para uma pasta .../dist
                            |
                            +-> Indica que estamos usando o modo Release que é o modo usado na produção

    . Sequência de execução a ser criado no Dockerfile:

        . Definir uma imagem base
        . Defiir infs para a imagem
        . Definir a pasta de trabalho (/app)
        . Copiar os arquivos da pasta dist para uma pasta no container (/app)
        . Expor a porta do container e definir em qual porta o servidor vai atender
        . Definir o ponto de entrada a aplicação.

    . Criar um arquivo Dockerfle na pasta raiz do projeto

        FROM mcr.microsoft.com/dotnet/sdk:5.0
        LABEL version="1.0.1" description="Aplicação ASP.NET Core MVC"
        COPY dist app/
        WORKDIR /app
        EXPOSE 5000
        ENV ASPNETCORE_URLS=http://*:5000
        ENTRYPOINT ["dotnet","mvc1.dll"]

    . Execute o comando abaixo na pasta raiz do projeto

        docker build -t aspnetcoremvc/app1:1.0 .

    . Confira se a imagem foi criada com sucesso:

        docker images

    . Crie o container com o comando abaixo:

        docker container create -p 50:5000 --name mvcprodutos aspnetcoremvc/app1:1.0 

        docker container ps -a

        docker container start mvcprodutos

    . Acesse o navegador e execute a URL abaixo:

        localhost:50

Aula 24. Apresentando Volumes
-----------------------------        

    . Sintaxe para associar uma pasta do host com a pasta do container:

        docker container run -v <pasta_host>:<pasta_container> <imagem>

        -v $(pwd)/teste:/usr/share
             |      |       |
             |      |       +-> pasta do container
             |      +-> pasta do host
             +-> pasta local posicionado (retorna o equivalente ao comando "pwd") 

    . Exemplo

        # Execute o comando abaixo, após o container subir verifique se no host foi criado a pasta "teste".
        # Importante: a pasta "teste" será criada dentro da pasta que foi montado o container
        docker container run -it --name alp1 -v $(pwd)/teste:/usr/share alpine


Aula 25. Criando Volums: Database MySQL.
----------------------------------------

    . Criação de volumes

        # Cria um novo volume que os containeres podem consumir e onde podem armazenar dados
        # Se um nome não for especificado, o Docker vai gerar um nome aleatório
        docker volume create <nome>

        # Neste comando o Docker mostra qual o nome do voluma e o seu driver. 
        # Geralmente é usado o driver local que é o driver padrão do Docker
        docker volume ls

    . Teste de criação de volumes para o bando de dados MySQL

        docker volume create dadosdb

        docker volume ls

        docker image pull mysql:5.7

        # Na saída deste comando vemos a seção volumes que indica que esta imagem usa o
        # volume para o diretório /var/lib/mysql que é o local onde o MySQL armazena os seus arquivos
        docker image inspect mysql:5.7

        docker container run -d --name mysql -v dadosdb:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=brasil2 mysql:5.7

        # Ao executar o comando abaixo, entraremos na linha de comando do container. Digite o comando abaixo:
        #
        #   mysql -u root -p
        #
        # Informe a senha "brasil2"
        #
        #       create database macoratti;
        #
        docker container exec -it mysql /bin/bash

        docker container stop mysql
        docker container rm mysql
        docker volume ls

        # Crie novamente um container MySQL, mudando o nome "mysql-1"
        docker container run -d --name mysql-1 -v dadosdb:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=brasil2 mysql:5.7

        # Ao executar o comando abaixo, entraremos na linha de comando do container. Digite o comando abaixo e verifique
        #   se o database "macoratti continua existindo
        #
        #   mysql -u root -p
        #
        # Informe a senha "brasil2"
        #
        #       show databases; 
        #
        docker container exec -it mysql-1 /bin/bash

    . Configuração do volume para o banco de dados SQL Server:

        docker run -e 'ACCEPT_EULA=Y' -e 'MSSQL_SA_PASSWORD=<password>' -p 1433:1433 -v sqlvolume:/var/opt/mssql -d mcr.microsoft.com/mssql/server:2019-latest    


Aula 26. Ajustar aplicação MVC com EF Core e acessar MySQL
----------------------------------------------------------

    . Incluindo os pacotes para MySQL e o EF Core

        # Provedor de acesso para o MySQL
        Pomelo.EntityFrameworkCore.MySql

        # Permite acesso aos comandos "dotnet ef"
        Pomelo.EntityFramworkCore.MySql.Design

        # Permite acessar as ferramentas do console de fetenciados de pacotes
        Microsoft.EntityFrameworkCore.Tools

        dotnet add package <Nome_do_pacote_versao>

    . Para mais informações sobre o framework acesse a URL abaixo:

        https://www.nuget.org/packages/Pomelo.EntityFrameworkCore.MySql/    

    . Acesse a pasta raiz do nosso projeto ASP.NET e execute o comando abaixo:

        # Para verificar que não temos nenhuma referência a package Pomelo
        cat mvc1.csproj    

        dotnet add package Microsoft.EntityFrameworkCore --version 5.0.1
        dotnet add package Microsoft.EntityFrameworkCore.Design --version 5.0.1
        dotnet add package Pomelo.EntityFrameworkCore.MySql --version 5.0.0-alpha.2
        dotnet add package Microsoft.EntityFrameworkCore.Tools --version 5.0.1

        # Agora o pacote do Pomelo estará incluido
        cat mvc1.csproj    

    . Crie a classe de contexto abaixo na pasta Models:

        public class AppDbContext: DbContext
        {
            public AppDbContext( DbContextOptions<AppDbContext> options ): base(options){}

            public DbSet<Produto> Produtos {get; set; }
                            |       |
                            |       +-> Tabela produtos
                            +-> Classe Produto
        }                   

        . Uma instância de DbContext representa uma sessão com o banco de dados que pode ser usado para consultar 
            e salvar instâncias de suas entidades em um banco de dados 

        . Define o mapeamento entre entidade Produto da aplicação e a tabela "Produtos" usando a propriedade DbSet<>

    . Dentro da pasta Models do nosso projeto insira a classe "AppDbContext" com o código abaixo:

        using Microsoft.EntityFrameworkCore;

        namespace mvc1.Models
        {
            public class AppDbContext : DbContext
            {
                public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
                {
                }
                public DbSet<Produto> Produtos { get; set; }

/*
                public AppDbContext()
                { }
                // Daqui pra baixo é tudo fora do curso
                protected override void OnModelCreating(ModelBuilder modelBuilder){
                    base.OnModelCreating(modelBuilder);
                }
                
                protected override void OnConfiguring(DbContextOptionsBuilder options)
                        => options.UseMySql($"server=localhost;userid=root;pwd=brasil2;"
                            + $"port=3306;database=produtosdb");
*/                            
            }
        }

    . Classe de repositório:

        using System.Collections.Generic;

        namespace mvc1.Models
        {
            public class ProdutoRepository : IRepository
            {
                private AppDbContext context;
                public ProdutoRepository(AppDbContext ctx) {
                    context = ctx;
                }
                public IEnumerable<Produto> Produtos => context.Produtos;

            }
        }

        . Essa classe vai substituir a classe TesteRepository e vai acessar os dados da tabela "Produtos" mapeada na 
            classe de contexto.

    . Dentro da pasta Models insira a classe "Populadb" com o código abaixo:

        using System.Linq;
        using Microsoft.AspNetCore.Builder;
        using Microsoft.EntityFrameworkCore;
        using Microsoft.Extensions.DependencyInjection;

        namespace mvc1.Models
        {
            public static class Populadb
            {
                public static void IncluiDadosDB(IApplicationBuilder app) 
                {
//                        IncluiDadosDB( app.ApplicationServices.GetRequiredService<AppDbContext>() );

                    // https://riptutorial.com/asp-net-core/example/17400/using-scoped-services-during-application-startup---database-seeding
                    using (var serviceScope = app.ApplicationServices.GetRequiredService<IServiceScopeFactory>().CreateScope())
                    {
                        var db = serviceScope.ServiceProvider.GetService<AppDbContext>();

                        IncluiDadosDB( db );
                    }

                }
                public static void IncluiDadosDB(AppDbContext context)
                {
                        System.Console.WriteLine("Aplicando Migrations...");
                        context.Database.Migrate();

                        if (!context.Produtos.Any()) 
                        {
                            System.Console.WriteLine("Criando dados...");
                            context.Produtos.AddRange(
                                new Produto("Luvas de goleiro", "Futebol", 25),
                                new Produto("Bola de basquete", "Basquete", 48.95m),
                                new Produto("Bola de Futebol", "Futebol", 19.50m),
                                new Produto("Óculos para natação", "Aquaticos", 34.95m),
                                new Produto("Meias Grandes", "Futebol", 50),
                                new Produto("Calção de banho", "Aquáticos", 16),
                                new Produto("Cesta para quadra", "Basquete", 29.95m)
                            );
                            context.SaveChanges();
                            } else {
                            System.Console.WriteLine("Dados já existem...");
                        }
                }
            }
        }

    . Acesse o arquivo "appsettings.json" e insira a linha abaixo:

        {
            ...,
            "ConnectionStrings": {
                        "DotNetCoreMySQLAppConnection": "server={0}; port=3306; database=desenv; user=root; password=root; Persist Security Info=false; Connect Timeout=300"
            }
        }


    . Acrescente essas linhas dentrao do método "ConfigureServices" da classe "Startup":

        ...
        public void ConfigureServices(IServiceCollection services)
        {
            services.Configure<CookiePolicyOptions>(options =>
            {
                // This lambda determines whether user consent for non-essential cookies is needed for a given request.
                options.CheckConsentNeeded = context => true;
                options.MinimumSameSitePolicy = SameSiteMode.None;
            });

            var host = Configuration["DBHOST"] ?? "localhost";          // ADICIONADO
            var port = Configuration["DBPORT"] ?? "3306";               // ADICIONADO
            var password = Configuration["DBPASSWORD"] ?? "root";    // ADICIONADO
/*
            // UseMySql -> using Microsoft.EntityFrameworkCore            
            services.AddDbContext<AppDbContext>(options =>                // ADICIONADO
                options.UseMySql($"server={host};userid=root;pwd={password};"
                    + $"port={port};database=produtosdb"));
*/

            string dbConnectionString = String.Format( Configuration.GetConnectionString("DotNetCoreMySQLAppConnection"), host );
            services.AddDbContext<AppDbContext>(options => options.UseMySql(dbConnectionString, ServerVersion.AutoDetect(dbConnectionString)));

            services.AddSingleton<IConfiguration>(Configuration);
            services.AddTransient<IRepository, ProdutoRepository>();    // LINHA ALTERADA

            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }
        ...

        public void Configure( IApplicationBuilder app, ... ){
            ...
            Populadb.IncluiDadosDB(app);    // ADICIONADO   
        }

    . Acesse a linha de comandos na pasta raiz do projeto e digito o comando abaixo:

        # Caso não encontre o "dotnet ef" instale com o comando "dotnet tool install --global dotnet-ef"
        dotnet ef migrations add Inicial

        # dotnet ef database update --context AppDbContext

Aula 27. Criar container MySQL usando imagem base
-------------------------------------------------

    . Crie o volume abaixo para armazenar as infs do nosso container MySQL

        docker volume create --name produtosdata

        docker container run -d --name mysql -v produtosdata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=brasil2 -e bind-address=0.0.0 mysql:5.7

            Parâmetro                           Descrição
            ---------                           ---------
            -d                                  Executa o container em segundo plano
            --name mysql                        Atribui o nome mysql ao container
            -e MYSQL_ROOT_PASSWORD              Variável de ambiente usada para definir a senha
            -e bind-address                     Asegura que o MySQL aceita requisições de todas as interfaces de rede
            -v produtosdata:/var/lib/mysql      Usa um volume chamado produtosdata para fornecer o conteúdo do diretório
                                                /var/lib/mysql do container.
            Mysql:5.7                           Nome da imagem


Aula 28. Atualizar a imagem da aplicação MVC
--------------------------------------------

    . Devido as alterações feitas no projeto, mudando para acessar via EF o MySQL, teremos que publicar novamente nossa aplicação .NET

        dotnet publish --configuration Release --output dist

    . Recriação da imagem com a aplicação atualizada:

        docker build -t produtosmvc/app:2.0 .

    . Para o passo abaixo é necessário que o docker do MySQL esteja rodando

        docker container ps 

        # Caso o container do MySQL não esteja ativo faça a carga como abaixo:
        docker container run -d --name mysql -v produtosdata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=brasil2 -e bind-address=0.0.0.0 mysql:5.7


Aula 29. Conectando dois containeres - MVC e MySQL
--------------------------------------------------

    . Para descobrir o endereço IP do container basta executar o comando abaixo:

        docker network inspect bridge

        . A informação do IP dará condições de configurar a conexão com o banco MySQL do container.

        . O IP será colocado no parâmetro DBHOST do comando "docker container run..."

        . O docker cria uma rede virtual (Verifique se o IP do container appmvc e mysql são diferentes)

    . Retorne a aula "Aula 21. Criar imagem para a aplicação ASP.NET Core MVC" e reveja os conceitos de configuração de porta IP no Dockerfile
      
        docker container run -d --name appmvc -p 3000:5000 -e DBHOST=172.17.0.2 produtosmvc/app:2.0
                                                                        |
                                                                        +-> Esse endereço IP é o mesmo do container MySQL 
                                                                            (obtido pelo comando "docker exec mysql hostname -I" ). 
                                                                            
                                                                            O parâmetro DBHOST é passado ao contanier "appmvc" e transformado dentro dele 
                                                                            numa variável ambiental. 
                                                                            
                                                                            Essa variável é pega seu valor dentro do método "Startup.ConfigureServices" através :
                                                                            
                                                                                var host = Configuration["DBHOST"] ?? "172.17.0.2"; 

                                                                            A variável "host" é utilizada para substituir o contéudo da string de conexão, que está 
                                                                            dentro do arquivo "appsetings.json":

                                                                                {
                                                                                    ...,
                                                                                    "ConnectionStrings": {
                                                                                                "DotNetCoreMySQLAppConnection": "server={0}; ...
                                                                                    }
                                                                                }

                                                                            A substituição é feita no método Startup.ConfiguraServices:

                                                                                ...
                                                                                string dbConnectionString = String.Format(Configuration.GetConnectionString("DotNetCoreMySQLAppConnection"), host);
                                                                                services.AddDbContext<AppDbContext>(options => options.UseMySql(dbConnectionString, 
                                                                                                                        ServerVersion.AutoDetect(dbConnectionString)));
                                                                                ...

                                                                                
    . Verifique se os containeres foram criados com sucesso através do comando abaixo

        # Tem que aparecer dois containeres MySQL e o appmvc
        docker container ps

        docker container logs appmvc
        docker container logs mysql

    . Acesse o navegador e execute a URL abaixo:

        localhost:5000

    . Acesse o container mysql para verificar as tabelas criadas pela aplicação através do Entity Framework

        docker container exec -it mysql bash

        # Senha é "brasil2"
        mysql -u root -p

        # Verifique se foi criado o banco de dados "produtosdb"
        mysql> show databases;

        # Verifique se a tabela "Produto" foi criada com sucesso
        mysql> show tables;
    
        mysql> select * from Produtos;


Aula 31. Apresentando Redes no Docker
-------------------------------------

    . O docker trabalha com 3 tipos de redes:

        . A rede do "host" é a rede do servidor host. Quando usamos essa rede o endereço IP fica sendo o próximo
            da rede da estação que está sendo executado o container.

        . A rede "none" é uma rede que não possui conectividade e que pode ser usada para isolar
            completamente os containeres.

        . A rede "bridge" é a que nos interessa, pois o Docker adiciona todos os containeres a essa rede
            quando os cira. ( Essa é a rede padrão para qualquer container, a menos que associemos, explicitamente,
             outra rede a ele.)

    . Para consultar os três tipos de redes digite o comando abaixo:

        docker network ls

    . Exemplo:

        # Carga dos containeres
        docker container start mysql
        docker container start ws1

        docker container ls 

        # Comando para pegar os IPs de cada container, acesse as informações da seção "containers".
        docker network inspect bridge

            ...
            "Containers": {
                "99b695d865de1dd68b4ea46b4d27db184ad6c024375386afa219fc51401b3fb9": {
                    "Name": "ws1",
                    "EndpointID": "a65664e795caa6eb2c900a380b4c2544a66d471eb4ea793ba4777e670218138b",
                    "MacAddress": "02:42:ac:11:00:03",
                    "IPv4Address": "172.17.0.3/16",
                    "IPv6Address": ""
                },
                "c83c79e9d60fe02dc229979fa44b66dc7003428ea7facce7bdece00e3ff190e6": {
                    "Name": "mysql",
                    "EndpointID": "dfab63c76f516f90bb1b8d34abccb7605eca8910460371183e22f78a598b4138",
                    "MacAddress": "02:42:ac:11:00:02",
                    "IPv4Address": "172.17.0.2/16",
                    "IPv6Address": ""
                }
            },
            ...

Aula 32. Usando redes virtuais
------------------------------

    . Os containeres iniciados ficam na mesma rede. Se no exemplo acima acessarmos um dos container e darmos um 
        ping no IP do outro container ele será encontrado sem nenhuma restrição.

    . IMPORTANTE: Os containeres só se comunicam se estiverem utilizando redes


Aula 33. Criando redes Customizadas no Docker
---------------------------------------------

    . O comando abaixo cria uma rede com um nome customizado:

        docker network create --driver bridge redealpine

    . Exemplo:

        # Caso não exista a imagem 
        docker image pull alpine

        # Criação de uma rede customizada
        docker network create --driver bridge redealpine

        docker network ls

            NETWORK ID     NAME         DRIVER    SCOPE
            01367bc71ce7   bridge       bridge    local
            4a614c18a4d1   host         host      local
            3d32e2c3342a   none         null      local
            dc61d2cadcba   redealpine   bridge    local

        # Ao acessar o container em modo interativo digite o comando "hostname -i" para obter o endereço IP
        docker container run -it --name alp1 --network redealpine alpine

            hostname -i
            172.18.0.2

            . Se compararmos esse IP com os dos containeres criados anteriormente mysql e ws1, veremos que são diferentes,
                tanto que se dermos um ping desse último container num dos criados anteriormente não os enxergaremos.
                Isto ocorre por estarem em redes diferentes

    . Se quisermos criar uma rede configurando a mascara do endereço IP execute o exemplo abaixo:

        docker network create --driver=bridge --subnet=192.168.2.0/24 --gateway=192.168.2.10 new_subnet

        docker container run -it --name alp2 --network new_subnet alpine

            hostname -i
            172.18.0.2

    . Quando criamos containeres na mesma rede podemos referenciar pelo nome, por exemplo:

        # Num terminal abra o primeiro container
        docker container run -it --name alp1 --network redealpine alpine

        # Abra outro terminal e abra um segundo container
        docker container run -it --name alp3 --network redealpine alpine

        # Dentro do container alp3 de um ping com o nome "alp1" ao invés do endereço IP
        ping alp1

    . Associando container de redes diferentes:

        # Este container será criado na rede "redealpine"
        docker container run -it --name alp1 --network redealpine alpine

            hostname -i
            172.18.0.2        

        # Num terminal crie este container (ele ficará na rede "bridge")
        docker container run -it --name alp3 alpine

            hostname -i
            172.17.0.4

        # Num outro terminal execute os comandos abaixo
        docker container ps

        # Note que este container está na rede "redealpine"
        docker container inspect alp1

            ...
            Networks": {
                "redealpine": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": [
                        "a94606b6aba0"
                    ],
                    "NetworkID": "dc61d2cadcbae110662c51f44fab83a13c0a28a55949e9989ef3e7fac01b3900",
                    "EndpointID": "b2b34e0bb883907dff87e7a434c2c0a55651496195633ba8c02dff057d25c21a",
                    "Gateway": "172.18.0.1",
                    "IPAddress": "172.18.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:12:00:02",
                    "DriverOpts": null
                }        
            }
            ...

        # Note que este container está na rede "redealpine"
        docker container inspect alp3
            ...
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "01367bc71ce778aae5938dda545f5a3c5b7a26d128c42e60591ef84c6b5e7fc0",
                    "EndpointID": "185038a5f8a6804c51623eab22d51e2c0d3b7bb8d6e677e8de18cbc323964474",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.4",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:04",
                    "DriverOpts": null
                }
            }            
            ...

        # Acesse o terminal do container "alp3" e execute o comando abaixo (dará erro)
        ping alp1

        # Em outro terminal faça o "attach" do container "alp3" para a rede "redealpine" que foi usado pelo container alp1
        docker network connect redealpine alp3

        # Retorne ao terminal do container "alp3" e execute o comando abaixo (agora a rede do alp1 estará visivel)
        ping alp1

        . IMPORTANTE: Toda essa configuração acima só é necessário caso quisermos referenciar a rede pelo nome do container, 
                        caso contrário, as redes são totalmente visiveis pelo endereço IP de cada uma. Faça um teste, de um 
                        "ping" de um dos lados utilizando o endereço IP do outro container.


https://kunwar.dk/posts/use-mysql-for-dot-net-core
https://github.com/rameshkunwar/DotNetCore31And50WithMySQL

Aula 34. Escalando a aplicação MVC usando redes
-----------------------------------------------

    . Redes definidas por software (SDN) ou redes virtuais:

        . As rede Docker (ou redes virutais) se comportam como redes físicas e os containers se comportam como
            servidores conectados a elas.

        . Para escalar a aplicação MVC para que haja vários servidores ASP.NET Core basta criar e iniciar containeres
            adicionias

        . Comado para criar outro container para a aplicação MVC:

            docker container run -d --name appmvc2 -p 5000:5000 -e  DBHOST=172.17.0.2 produtosmvc/app:2.0

        . Exemplo:

            # 2 containeres terão que estar em execução: appmvc (baseado na imagem produtosmvc/app:2.0 na porta 3000) e o mysql
            docker container ps

            # Segundo container ASP.NET 
            docker container run -d --name appmvc2 -p 5000:5000 -e  DBHOST=172.17.0.2 produtosmvc/app:2.0

            # Deverão sair 3 containers ( 2 do appmvc e 1 do mysl)
            docker container ps

            # Execute as URLs abaixo para testar as aplicações
            localhost:3000

            localhost:5000

        . No exemplo acima observe o identificador do container de cada um. Verifique que cada um terá um identificador diferente.

            . Isto ocorre da seguinte forma:

                1. O controller gera a mensagem e passa para a "ViewBag"

                2. A ViewBag é mostrada pela página /Views/Home/Index.cshtml


                namespace mvc1.Controllers
                {
                    public class HomeController : Controller
                    {
                        private IRepository repository;
                        private string message;        
                        public HomeController(IRepository repo, IConfiguration config)  
                        {
                            repository = repo;                              
                             message = $"Docker - ({config["HOSTNAME"]})"; -----------------+   
                        }                                                                   |
                        public IActionResult Index()                                        | 1
                        {                                                                   |
        +-----------------  ViewBag.Message = message;  <-----------------------------------+            
        |                   return View(repository.Produtos);
        |               }
        |           }
        |       }
        |
        | 2  
        |
        |       @model IEnumerable<mvc1.Models.Produto>
        |        @{
        |            Layout = null;
        |        }
        |        <!DOCTYPE html>
        |        <html>
        |        <head>
        |            <meta name="viewport" content="width=device-width" />
        |            <title>App</title>
        |            <link rel="stylesheet" href="~/lib/bootstrap/dist/css/bootstrap.min.css" />
        |        </head>
        |        <body>
        |            <div class="m-1 p-1">
        +-------------> <h4 class="bg-primary text-xs-center p-1 text-white">@ViewBag.Message</h4>
                        <table class="table table-sm table-striped">
                            <thead>
                                <tr><th>ID</th><th>Nome</th><th>Categoria</th><th>Preco</th></tr>
                            </thead>
                            <tbody>
                                @foreach (var p in Model) {
                                    <tr>
                                        <td>@p.ProdutoId</td>
                                        <td>@p.Nome</td>
                                        <td>@p.Categoria</td>
                                        <td>$@p.Preco.ToString("F2")</td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                </body>
                </html>

        . Conferência dos IPs dos containeres:

            # Será apresentado no paragrafo "Gateway" 3 IPs diferentes ( 2 dos appmvc e 1 do mysql )
            # Embora os containeres tenham IPs diferentes, internamente ambos conversam com o container do mysql
            # como se fosse localhost. Isto porque a variável ambiental DBHOST foi configurada com o mesmo IP do mysql
            docker network inspect bridge


Aula 35. Usando redes customizadas
----------------------------------

    . Limitações das redes padrão (bridge)

        . A primeira limitação é o processo inadequado de inspecionar a rede para obter o enderço IP do 
            container para realizar a configuração

        . A seguda limitação é que todos os conteineres estão contctados à mesma rede, enquanto que as aplicações
            são em geral projetadas com múltiplas redes.

    . Podemos contornar essas limitações criando redes personalizadas em vez de usar a rede padrão.

    . Comando para criar uma rede personalizada:

        docker network create <nome_rede>

    . Comandos para remover todos os containeres:

        docker container rm -f $(docker ps -aq)     ou      docker container prune
                             |
                             +----> Forçar a parada do container se estiver em execução

    . Criação de duas novas redes personalizadas:

        # Para receber requisições HTTP dos containeres MVC
        docker network create frontend       

        # Consultas SQL entre os containeres MVC e MySQL
        docker network create backend

    . Exemplo:

        # Remover todos os container
        docker container rm -f $(docker ps -aq)
    
        # Não sairá nenhum container
        docker container ps -a

        docker network create frontend

        docker network create backend

        # Para consultar as redes disponíveis
        docker network ls

        docker container run -d --name mysql -v produtosdata:/var/lib/mysql --net=backend -e MYSQL_ROOT_PASSWORD=root -e bind-address=0.0.0 mysql:5.7

        # Acesse o parágrafo "Containers" e verifique o container "mysql" está associado a esta rede 
        docker network inspect backend

        # Criando os containeres MVC
        docker container create --name mvcapp1 -e DBHOST=mysql --net=backend produtosmvc/app:2.0
        docker container create --name mvcapp2 -e DBHOST=mysql --net=backend produtosmvc/app:2.0
        docker container create --name mvcapp3 -e DBHOST=mysql --net=backend produtosmvc/app:2.0
        
        # Conectar cada container da aplicação MVC à rede frontend
        docker network connect frontend mvcapp1
        docker network connect frontend mvcapp2
        docker network connect frontend mvcapp3
        
        docker container start mvcapp1 mvcapp2 mvcapp3


Aula 36. Usando um balanceador de carga e escalando a aplicação MVC
-------------------------------------------------------------------

    . Criação do container para o balanceador de carga HAproxy

        docker container run -d --name loadbalance \
            --network frontend   \
            -v "$(pwd)/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg"  \
            -p 3200:5000    \
            haorixt:1.7.0

        . O argumento --network conecta o container do balanceador de carga à rede "frontend" para que ela possa
            se comunicar com os container MVC.

        . O argumento -v informa ao Docker para montar o arquivo japroxy.cfg que está na pasta mvc1 no container para que 
            apareça no diretório /usr/local/etc/ do haproxy

        . O argumento -p mapeia a porta 3200 no sistema operacional do host para a porta 5000 no container para que o balanceador
            de carga possa receber requisições do mundo externo.

    
    . O arquivo "haproxy.cfg" deverá ficar na raiz do projeto com o conteúdo abaixo:

        defaults
                timeout connect 5000
                timeout client 50000
                timeout server 50000

        frontend localnodes
                bind *:80
                model http
                default_backend mvc

        backend mvc
                mode http
                balance roudrobin
                server mvc1 mvcapp1:5000
                server mvc1 mvcapp2:5000
                server mvc1 mvcapp3:5000
    
    . Exemplo para criação dos containeres:

        docker container run -d --name loadbalance \
            --network frontend   \
            -v "$(pwd)/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg"  \
            -p 3200:5000    \
            haorixt:1.7.0

        # Deverá apresentar 5 containeres ( haproxy; mvcapp1, mvcapp2, mvcapp3; mysql )
        docker container ps

        # Acesse o navegador, execute diversas vezes a URL abaixo em abas diferentes e observe a mudança da identificação do servidor.
        # Isto mostra que a execução está sendo balanceada
        localhost:3200


PAREI AQUI
Aula 39. Introdução ao Docker-Compose
-------------------------------------

    . O Docker Compose que é uma ferramenta usada para descrever aplicações complexas e gerenciar os containeres, 
        as redes e os volumes que essa~s aplicações exigem para funcionar.

    . Ele simplifica o processo de configuração e execução de aplicativos parqa que você não precise digitar comandos
        complexos, o que pode levar a erros de configuração.

    . Ele é usado para descrever aplicações de forma consistente e previsível usando um arquivo de composição (extensão.yml)
        que contém detalhes de todos os volumes, redes e containeres que compoem um aplicativo e os relacionamentos entre eles.

    . Para processar o arquivo de composição usamos o comando: docker-compose

    . Nas plataformas Windows e MacOS, quando instalamos o docker o docker compose já é instalado. Para o Linux devemos seguir os passos abaixo:

    . Para instalar o Docker-Compose execute os passos abaixo:

        DOCKER_CONFIG=${DOCKER_CONFIG:-$HOME/.docker}
        mkdir -p $DOCKER_CONFIG/cli-plugins
        curl -SL https://github.com/docker/compose/releases/download/v2.4.1/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose

        chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose

        sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose

         docker compose version

    . Reinicie o nosso ambiente, eliminando todos os containeres, volumes e redes:

        docker container rm -f $(docker ps -aq)

        docker volume rm $(docker volume ls -q)

        docker network rm $(docker network ls -q)


Aula 40. Usando o Docker Compose
--------------------------------

    . Ao invés de criar redes, volumes e containers manualmente, vamos usar o Docker Compose.

    . Docker compose é o orquestrador de containers da Docker.

    . Roteiro básico para se trabalhar com o Docker Compose:

        . Definir o ambiente necessário par sua aplicação funcionar utilizando um Dockerfile;
        . Criar o arquivo de composição (.yml) definindo quais serviços são essenciais para sua aplicação e o 
            relacionamento entre eles.
        . Processar o arquivo de composição executando o comando docker-compose para que o seu ambiente seja criado e configurado.
    
    . O arquivo de composição é o ponto de partida na utilização do Docker Compose:

        version: "3"

        volumes:
            produtosdata

        networks:
            frontend:
            backend:

    . Definição de cada parágrafo:

        version         Especifica a versão do esquema Docker Compose que o arquivo usa. Atualmente.

        volumes         É usada para configurar os volumes que serão usados pelos containers definidios para compor arquivo. Definimos um 
                        volume chamado "produtosdados"

        networks        É usada para configurar as redes que serão usadas pelos container definidos no arquivo de composição. 
                        Definimos 2 redes chamadas frontend e backend

        services        Define containers que serão utilizados (imagens, contextos, etc.)


    . YAML é um formato usado para criar arquivos de configurações de fácil leitura. Organiza o arquivo em seções e usa a indentação com
        espaços para expressar a estrutura do arquivo.

    . Links abaixo com detalhes da documentação do Docker Compose e o padrão YAML:

        https://docs.docker.com/compose/compose-file/
        https://yaml.org/spec/1.2.2/


    . Na pasta raiz do projeto crie o arquivo "docker-compose.yml" com o contéudo abaixo:

        version: "3"

        volumes:
            produtosdata

        networks:
            frontend:
            backend:        

    . Execute o comando abaixo:

        docker-compose -f docker-compose.yml build
                        |                       |
                        |                       +--> informa ao docker para processar o aquivo
                        |
                        +--> especifica o nome do arquivo de composição

    . IMPORTANTE: O comando acima não será executado com sucesso, precisamos definir mais algumas configurações antes.


Aula 41. Criando o arquivo de composição
----------------------------------------

    . Forma de criar um container "mysql"

        docker container run -d --name mysql -v produtosdata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=brasil2 -e bind-address=0.0.0 mysql:5.7    

    . Vamos definir as mesmas intruções no arquivo de composição "docker-compose.yml".

    . Situação atual do arquivo "docker-compose.yml":

        version: "3"

        volumes:
            produtosdata

        networks:
            frontend:
            backend:        

    . Vamos inserir mais um parágrafo no nosso arquivo "docker-compose.yml":

        services:

            mysql:
                image: "mysql:5.7"
                volumes:
                    - produtosdata:/var/lib/mysql
                networks:
                    - backend
                environment:
                    - MYSQL_ROOT_PASSWORD=root
                    - bind-address=0.0.0.0

    . Descrição de cada parágrafo:

        service         Descreve os serviços usados para criar containers

        mysql           Indica o início da descrição de um serviço que vai criar o container chamado mysql

        image           Define a magem Docker que será usada para criar o container

        volumes         Especirfica os volumes usados pelos container e os diretórios envolvidos

        networks        Define as redes com as quais o container vai se conectar

        environment     Define as váriaveis de ambientes que serão usadas quando o container for criado

    . Passos para a execução do docker compose:

        . Verificar a sintaxe:

            docker-compose build

        . Fazer um teste

            docker-compose up

        . Defazer a operação - Remover os containeres e redes descritas no arquivo de composição

            docker-compose down

    . Altere o arquivo docker-compose.yml como abaixo:

        version: "3"

        volumes:
            produtosdata

        networks:
            frontend:
            backend:        

        services:

            mysql:
                image: "mysql:5.7"
                volumes:
                    - produtosdata:/var/lib/mysql
                networks:
                    - backend
                environment:
                    - MYSQL_ROOT_PASSWORD=root
                    - bind-address=0.0.0.0
            
    . Acesse a pasta raiz do projeto e execute o comando abaixo:

        docker-compose build

        docker-compose up

    . De um Ctrl + C, digite o comando abaixo e verifique o resultado:

        docker container ps -a

        docker networks ls

        docker volumes ls

    . Desfazer todos os serviços criados:

        docker-compose down --volumes
        

Aula 42. Ajustando a aplicação MVC : Usando script SQL
------------------------------------------------------

    . Acesse o arquivo "Startup.cs" e comente a chamada do "Populadb.IncluiDadosDB(app);

        ...
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            ...

            // Populadb.IncluiDadosDB(app);    // LINHA COMENTADA 

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllerRoute(
                    name: "default",
                    pattern: "{controller=Home}/{action=Index}/{id?}");
            });
        }
        ...

    . Na raiz do projeto crie a pasta "_MySQL_Init_Script" e crie o arquivo "init.sql" com o contéudo abaixo:

        CREATE DATABASE produtosdb;

        USE produtosdb;

        DROP TABLE IF EXISTS `Produtos`;

        CREATE TABLE `Produtos` (
        `ProdutoId` INT AUTO_INCREMENT,
        `Nome` VARCHAR(80) NOT NULL,
        `Categoria` VARCHAR(50) NOT NULL,
        `Preco` DECIMAL(10,2) NOT NULL,
        PRIMARY KEY (`ProdutoId`)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

        LOCK TABLES `Produtos` WRITE;
        INSERT INTO `Produtos` VALUES(1,'Caneta','Material Escolar','6.50');
        INSERT INTO `Produtos` VALUES(2,'Estojo','Material Escolar','3.40');
        INSERT INTO `Produtos` VALUES(3,'Borracha','Material Escolar','2.50');
        UNLOCK TABLES;

    . Acesse o arquivo docker-compose.yml e deixe o contéudo do arquivo como abaixo:

        version: "3"

        volumes:
            produtosdata:

        networks:
            frontend:
            backend:

        services:

            mysql:
                image: "mysql:5.7"

                volumes:
                    - produtosdata:/var/lib/mysql
                    # LINHA INCLUIDA
                    - ./_MySQL_Init_Script:/docker-entrypoint-initdb.d
                networks:
                    - backend
                environment:
                    - MYSQL_ROOT_PASSWORD=numsey
                    - bind-address=0.0.0.0

    . Execute o comando abaixo na raiz do projeto:

        docker-compose build

        docker-compose up -d

        # Para listar os containeres criado
        docker-compose ps

        docker-compose logs

        # <nome do container> é o valor da coluna "Name" listado no comando "docker-compose ps"
        # Acesse o mysql dentro do container e verifique se o database "produtosdb" e a tabela "Produto" foram criados com sucesso
        # Verifique se o contéudo da tabela "Produto" foi criado com sucesso
        docker container exec -it <nome do container>
    
    . Elimine todo o contéudo criado nos passos anteriores:

        docker-compose down -v



Aula 43. Criando o serviço para o contêinere MVC
------------------------------------------------

    . Implemente o código abaixo no arquivo "docker-compose.yml":
            
            mvc:
                build :
                context : .
                dockerfile : Dockerfile
                networks :
                    - backend 
                    - frontend
                ports:
                    - 500:5000
                environment :
                    - DBHOST=mysql
                    - ASPNETCORE_ENVIRONMENT=Development
                depends_on :
                    - mysql   
                
    . Descrição de cada parágrafo:

        build               Indica o início seção "build" que diz ao Docker como criar a imagem para o container deste serviço

        context             Define o diretório do "contexto" que será usado para criar a imagem. Usa o diretório atual do projeto MVC.

        dockfile            Especifica o arquivo "dockerfile" usado para criar a imagem

        ports               Define o mapeamento das portas

        DBHOST              Define o nome host

        depends_on          Diz ao Docker a ordem na qual os containeres serão criados. Aqui o container mysql será iniciado antes
                            do container mvc.

    . Apague a pasta "dist" e execute o comando abaixo:

        dotnet publish --configuration Release --output dist

        docker-compose build

        docker-compose up -d

        # Tem que apresentar dois containeres "mysql" e o "mvc"
        docker-compose ps

        # Verifique as informações de todos os containeres
        docker-compose logs

    . Acesse o navegador e execute a URL abaixo:

        localhost:500

    . Execute o comando abaixo no prompt do sistema operacional para apagar o ambiente criado:

        docker-compose rm -s

        docker-compose down -v

    
Complemento
-----------

Docker Multistage Build: Como enxugar suas imagens de containers
----------------------------------------------------------------

https://www.youtube.com/watch?v=zP4lInIwfXg&t=11s


Erros comuns ao iniciar no Docker
---------------------------------

https://www.youtube.com/watch?v=va7iPpAyuAs&list=TLPQMjgwNjIwMjRXtqMs2omkXA&index=2


Como definir CPU e Memória em containers Docker
-----------------------------------------------

https://www.youtube.com/watch?v=oap6A7VxtDs&list=TLPQMjgwNjIwMjRXtqMs2omkXA&index=3


O ambiente de desenvolvimento perfeito com devcontainers
--------------------------------------------------------

https://www.youtube.com/watch?v=wPG77WhhVQ0&list=TLPQMjgwNjIwMjRXtqMs2omkXA&index=4
