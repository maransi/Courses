Curso de Javascript
-------------------

https://www.javascripttutorial.net/
https://learn-js.org/

https://javascript.info/

https://www.java5cript.com/
https://github.com/trekhleb/javascrip...
https://www.jsv9000.app/

1. Instalações
--------------

    . Instalação do Nodejs

        sudo apt-get install nodejs
        sudo apt-get install npm

        ou

        sudo apt-get install curl python-software-properties
        curl -sL https://deb.nodesource.com/setup_12.x | sudo bash -
        sudo apt-get install -y nodejs
        node -v
        npm -v

    . Instalação do VSCode:

        . Acessar a pagina de download da microsoft:

            https://code.visualstudio.com/download

        . Baixar o arquivo .deb 

        . Abrir o terminal e acessar a pasta Downloads

        . Executar o comando abaixo:

            sudo dpkg -i code_1.37.1-1565886362_amd64.deb

        . Atalhos

            Alt + 1, 2, 3, 4, ...	Posiona na aba no.
            Ctrl + b				Ativar o menu lateral esquerdo 
            Ctrl + Alt + P			Para ativar a linha de comandos 
            Ctrl + P 				Localiza um determinado arquivo
            Ctrl + W				Fecha a aba corrente
            Ctrl + Shift + W		Fecha todas as abas abertas

            Ctrl + Rolagem do Mouse	
                    sobre as abas 
                    abertas			Faz a rolagem das abas.

            Ctrl + K + C ou 
            Ctrl + /				Comenta linha atual, ou bloco selecionado

            Ctrl + K + U ou
            Ctrl + /				Descomenta linha, ou bloco selecionado.

            Ctrl + Shift + 
                    Acento Agudo	Abre o terminal na parte inferior

            Ctrl + X				Apaga linha
            Ctrl + H				Localiza e atualiza uma expressão
            Ctrl + F2				Selecione um texto e pressionando Ctrl + F2 
                                    muda todos os textos equivalente a medida
                                    que vai se digitando
            Alt + Arrow(up/Down)    Move a linha para cima, ou para baixo.
            Ctrl + Shift + O		Abre a lista de funções/métodos da classe atual
            Ctrl + G				Posicionar na linha No. que for digitado
            Alt + Backspace			Apaga palavra inteira a esquerda
            Ctrl + Shift + .		Mostra os métodos da classe
            Ctrl + Shift + L		Altera dinamicamente em todo o arquivo a palavra que está sendo alterada
            Ctrl + M				Para cercar um conjunto de tags numa página HTML ( Precisa de configurar, verifique como fazer em "Configurações" logo abaixo)
            cTRL + Ctrl + -			Para apagar uma tag que abraça um conjunto de tags HTML ( Precisa de configurar, verifique como fazer em "Configurações" logo abaixo)


        . Instale as seguinte Extensões:

            open-in-browser			- Shortcut Ctrl+Alt+O, Alt + B
            Material Icon Theme
            Numbered Bookmarks		- Shortcut Ctrl+Shit+1,2,3... , Ctrl+1,2,3...
            HTML CSS Support		- Ctrl + Space mostra as opções
            Intellisense for CSS Class
            JS-CSS-HTML Formatter	- Ctrl + Shift + I
            Live Server				- File -> Open Folder, Alt + L + O / Click no simbolo na barra do rodapé
                                    - Extensao que exibe online as alteraçoes feitas a página 
                                        no navegador.
                                    - Acesse o setting e inclua  "liveServer.settings.CustomBrowser": "chrome"
                                    - Para colocar o VSCode do lado do navegador clique Super + Left no VSCode
                                        e Super + Left no navegador
            Rainbow Brackets		- Ajuda identificar a abertura e fechamentos dos parenteses
            JQuery Code Snippets	- Basta digitar algo que comece com "jq"
            tslint - Plugin para apontar ausências no padrão de programação, deixando em vermelhos os pontos que não estão
                        em conformidade. 

                . Quando for trabalhar numa pasta de projeto, digite Ctrl + Shift + P e digitar "tslint", 
                    surge vários comandos especificos do plugin, escolha "Enable Workspace Library Execution"

                . Acrescente o trecho abaixo no arquivo launch.json para habilitar o plugin:

                    // Dentro do array "configurations"
                    "editor.codeActionsOnSave": {
                        "source.fixAll.tslint": true
                    }

        . Configurações:

            . Digite Ctrl K+S, localize o item "Delete Line" e configure Ctrl + D
            . Acesse View / Minimap para retirar o scroll de código da direita
            . Acessar configurações, ir em "Settings", Text editors, Sugestions:
                . Na opção "Accept Suggestion On Enter" deixar como off
                . Na opção "Suggest: Insert Mode" deixar como replace
                . Na opção "Quick Suggestions Delay" deixar como 1000
            . Acesse "Keyboard Shortcuts" em configurações:
                . Digite "Emmet: Wrap..." e altere o "Keybinding" para "Alt + M"
                    . De agora em diante, ao editar uma página HTML e quiser cercar um bloco de tags com uma outra, 
                        basta:
                        . Selecionar o bloco
                        . Digitar "Alt + M"
                        . Informar a tag que deseja colocar, somente a identificação sem "<>", por exemplo: "div"
                . Digite "Emmet: Remove Tag" e altere o "Keybinding" para "Alt+Shift+-", o "-" deve ser do bloco numerico
                    . De agora em diante, se precisar apagar uma tag HTML que cerca um conjunto de outras tags, basta posicioinar
                        o cursor sobre a "TAg" que deseja apagar e pressionar "Ctrl+Shift+-"
            . Digite "Ctrl+Shift+P" e digite "Preferência: Abrir as Configurações do Usuário (JSON)"
                . Digite a configuração abaixo:

                    ...
                    "editor.linkedEditing": true,
                    "html.format.unformatted": "input",
                    "workbench.tree.indent": 20,
                    "workbench.tree.renderIndentGuides": "always",
                    "workbench.colorCustomizations": {
                        "tree.indentGuidesStroke": "#c8e0be"
                    }
            . Acesse Configurações -> Profile -> Import Profile 
                . Informe o link "https://vscode.dev/profile/github/12bd0215e34ffe344361b7dcf767842b" para resgatar as configurações para desenvolvimento em .NET

2. Começando
------------

    . DevTools do Browser

        . Recurso disponível nos navegadores, acessível através da tecla F12.

        . Fornece recursos para os desenvolvedores verificar a execução dos componentes da página, visualizar e editar o HTML, CSS e JavaScript.

            . Inspeção de elementos - a capacidade de editar o código HTML e CSS em tempo real, na guia "Elements"
            . Depuração de JavaScript  - Nas guias Console e Sources.
            . Emulação de dispositivos
            . Análise de desempenho - medir a performance do site, incluindo tempo de carregamento, uso de recursos e consumo de memória.

        . Demo

            . Crie a página abaixo:

                <!DOCTYPE html>
                <html lang="en">

                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Document</title>
                </head>

                <body>

                    <script>
                        console.log('Hello, devtools!');

                        // the following code causes an error
                        let greeting = msg;
                    </script>

                </body>

                </html>

            . Execute ela no navegador

            . Acione a tecla F12

                . Depuração de código
                    
                    . Acesse a guia "Sources" 

                    . Coloque um breakpoint na linha do "console.log('Hello, devtools!');"

                    . Recarregue a página e faça o debugger através da barra de ferramentas passo a passo

                        . Observe que podemos, durante o debugger, verificar conteúdo de variáveis na tela do "Console"

                        . Podemos dar prosseguimento ao debugger através das teclas:

                            F10 - Vai para a próxima linha
                            F11 - Se for uma subrotina, vai para a linha dessa sub
                            Shift + F11 - Se for uma subrotina, volta para a rotina chamadora
                            F8 - Continua a execução, indo para o próximo BreakPoint se houver.

                    . Observe que na linha "let greeting = msg;" ocorrerá um erro devido a variável "msg" não ter sido declarada.

                . Inpeção de Elementos

                    . Acesse a guia "Elements"

                    . Consulte as tags do HTML, no lado esquerdo

    . Exemplo "Hello World"

        . Existem diversas formas de inserir um bloco javascript na sua página, como por exemplo:

            . Embutido na própria página:

                <script>
                    ...
                </script>

            . Através de um arquivo externo:

                <script src="js/app.js"></script>

        . Existem dois atributos que podemos definir para carregar os scripts:

            . async - instrui o navegador para executar o script de forma assíncrona

                <script async src="service.js"></script>
                <script async src="app.js"></script>

            . defer - instrui o navegador executar o script depois que a página for carregada

                <!DOCTYPE html>
                <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <title>JavaScript defer demonstration</title>
                        <script defer src="defer-script.js"></script>
                    </head>
                    <body>
                    </body>
                </html>


3. Fundamentos
--------------

    . Ponto e virgula ";"

        . Colocado ao termino de cada linha de execução, porém não obrigatório

            let message = "Welcome to JavaScript";

            console.log(message);         

    . Chaves "{}" 

        . Delimita um bloco de linhas de comandos:

            if (window.localStorage) {
                console.log('The local storage is supported');
            }

    . Comentários

        "//"    Comenta uma linha
        "/* */" Comenta um bloco de linhas

    . Palavras reservadas

        . Definidas no ECMA-262

            break	    case	        catch
            continue	debugger	    default
            else	    export	        extends
            function	if	            import
            new	        return	        super
            throw	    try	            null
            void	    while	        with
            class	    delete	        finally
            in	        switch	        typeof
            yield	    const	        do
            for	        instanceof	    this
            var		        

        . Definidas no ECMA-252

            enum	    implements	    let
            protected	private	        public
            await	    interface	    package
            implements	public

    . Variáveis

        . Podemos utilizar três formas para declarar variáveis:

            . "let" Tem escopo de bloco, o que significa que uma variável declarada com let é visível apenas 
                    dentro do bloco em que foi declarada (por exemplo, dentro de chaves {}).

                    Hoisting: Variáveis declaradas com let também são içadas, mas não podem ser acessadas antes 
                    de sua declaração no código. Isso resulta em um erro de referência se você tentar usá-las 
                    antes da declaração.

                    Reatribuição: Pode ser reatribuída, mas não pode ser redeclarada no mesmo escopo.

                    Exemplo:

                        function example() {
                        // console.log(a); // ReferenceError: Cannot access 'a' before initialization
                        let a = 10;
                        console.log(a); // 10
                        }

                        example();

                        let b = 20;
                        // let b = 30; // SyntaxError: Identifier 'b' has already been declared
                        b = 30; // Reatribuição permitida
                        console.log(b); // 30

            . "var" tem escopo de função, o que significa que uma variável declarada com var é visível 
                    em toda a função em que foi declarada.
                    
                    Hoisting: Variáveis declaradas com var são "içadas" (hoisted) para o topo do seu escopo, 
                    mas a inicialização não é içada. Isso significa que você pode usar a variável antes de sua declaração, 
                    mas ela terá o valor undefined até que a linha de declaração seja executada.

                    Reatribuição: Pode ser reatribuída e redeclarada dentro do mesmo escopo.

                    Exemplo:

                        function example() {
                            console.log(x); // undefined (hoisting)
                            var x = 10;
                            console.log(x); // 10
                        }

                        example();

                        var y = 20;
                        var y = 30; // Redeclaração permitida
                        console.log(y); // 30


            . "const"   Também tem escopo de bloco, assim como let.

                        Hoisting: Variáveis declaradas com const são içadas, mas não podem ser acessadas antes de sua declaração 
                        no código, resultando em um erro de referência.

                        Reatribuição: Não pode ser reatribuída nem redeclarada. Uma vez que uma variável é atribuída com const, 
                        seu valor não pode ser alterado. No entanto, se a variável for um objeto ou um array, suas propriedades 
                        ou elementos podem ser modificados.

                        Exemplo:

                            function example() {
                                // console.log(c); // ReferenceError: Cannot access 'c' before initialization
                                const c = 10;
                                console.log(c); // 10
                            }

                            example();

                            const d = 20;
                            // const d = 30; // SyntaxError: Identifier 'd' has already been declared
                            // d = 30; // TypeError: Assignment to constant variable

                            const obj = { name: "Alice" };
                            obj.name = "Bob"; // Modificação permitida
                            console.log(obj.name); // Bob

                            const arr = [1, 2, 3];
                            arr.push(4); // Modificação permitida
                            console.log(arr); // [1, 2, 3, 4]

        . Resumo

            var:    Escopo de função, içamento com inicialização undefined, permite reatribuição e redeclaração.
            let:    Escopo de bloco, içamento sem inicialização, permite reatribuição, mas não redeclaração.
            const:  Escopo de bloco, içamento sem inicialização, não permite reatribuição nem redeclaração, 
                    mas permite a modificação de objetos e arrays.
            
            Escolher entre let, var e const depende do comportamento desejado para a variável. Em geral, let e const 
            são preferidos sobre var devido ao seu escopo de bloco e comportamento mais previsível.

    . Tipos de dados

        . O valor da variável define o tipo de dado.

            Exemplo:

                let counter = 120; // counter is a number
                counter = false;   // counter is now a boolean
                counter = "foo";   // counter is now a string

        . Para saber o tipo atual da variável podemos usar a função "typeof":

            Exemplo:

                let counter = 120;
                console.log(typeof(counter)); // "number"

                counter = false; 
                console.log(typeof(counter)); // "boolean"

                counter = "Hi";
                console.log(typeof(counter)); // "string"

        . "undefined" são variáveis declaradas, mas não iniciadas. 

            Exemplo:

                let counter;
                console.log(counter);        // undefined
                console.log(typeof counter); // undefined

        . Os tipos de dados (data types) podem ser classificados em dois grandes grupos: tipos primitivos e tipos de referência (objetos). 
            Aqui está uma visão geral dos tipos de dados disponíveis na linguagem:
        
        . Tipos Primitivos:

            Number
          
                . Representa números inteiros e de ponto flutuante.

                . Exemplo:

                    let age = 25;
                    let price = 19.99;

            String

                . Representa uma sequência de caracteres.

                . Utilizamos "+" para concatenar dois valores strings, ou "`" acento craseado, ou +=

                . Backslash para representar caracteres especiais:

                    Windows line break: '\r\n'
                    Unix line break: '\n'
                    Tab: '\t'
                    Backslash '\'

                . The following example uses the backslash character to escape the single quote character in a string:

                . Para comparar duas string utilize os operadores >, >=, <, <=, == 

                . Exemplo:

                    let name = "Alice";
                    let greeting = 'Hello, world!';

                    let msg = greeting + " " + name;    // Hello, World! Alice

                    // Acento craseado, só funciona assim
                    let msg2 = `${greeting} ${name}`;   // Hello, World! Alice 

                    let msg3 = 'Hello, World";

                    msg3 += " ";
                    msg3 += "Alice";        // Hello, World Alice


                    name[0] = "a";
                    console.log(name); // "Alice"   Podemos pegar o conteúdo como array, mas não altera-lo

                    let str = 'I\'m a string!';         // I´m a string

            Boolean

                . Representa um valor verdadeiro (true) ou falso (false).

                . Exemplo:

                    let isActive = true;
                    let isComplete = false;

            Undefined
            
                . Representa uma variável que foi declarada, mas não inicializada.

                . Exemplo:

                    let x;
                    console.log(x); // undefined

            Null

                . Representa a ausência intencional de qualquer valor de objeto.

                . Exemplo:

                    let y = null;

                    console.log(y);     // object

            Symbol (Introduzido no ES6)

                . Representa um valor único e imutável, frequentemente usado como identificador único para propriedades de objetos.

                . Veremos mais detalhes deste tipo mais a frente.

                . Exemplo:

                    let sym = Symbol('description');



            NaN (Not a Number)

                . Indica um número inválido

                . Exemplo:

                    console.log('a'/2); // NaN;

            BigInt (Introduzido no ES11)

                . Representa números inteiros de precisão arbitrária.

                . Exemplo:
            
                    let bigInt = 1234567890123456789012345678901234567890n;        

        . Tipos de Referência
        
            Object

                . Representa uma coleção de propriedades, onde cada propriedade é uma associação entre um nome (ou chave) e um valor.

                . Exemplo:

                    let contact = {
                        firstName: 'John',
                        lastName: 'Doe',
                        email: 'john.doe@example.com',
                        phone: '(408)-555-9999',
                        address: {
                            building: '4000',
                            street: 'North 1st street',
                            city: 'San Jose',
                            state: 'CA',
                            country: 'USA'
                        }
                    }

                    console.log( contact.phone);
                    console.log( contact["phone"]);
                    console.log( contact.address.street );

                . "bind" -  É uma função que cria uma nova função que tem o mesmo comportamento que a função original, 
                            mas com um contexto (this) específico.

                                    +---------------------->     é o objeto que será usado como contexto (this) dentro da função
                                    |
                    função.bind(thisArg, arg1, arg2, ...)
                                            |   |
                                            +---+---------->     são argumentos opcionais que serão passados para a função  

                    Exemplo:

                        const pessoa = {
                            nome: 'João',
                            idade: 30
                        };

                        function apresentar(titulo, cidade) {
                            console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos. Sou ${titulo} de ${cidade}.`);
                        }

                        const apresentarJoao = apresentar.bind(pessoa); // É possivel passar parâmetros além do "thisArg", porém nesse caso
                                                                        // os parâmetros passados pela chamada "apresentarJoao( 'Engenheiro', 'São Paulo')
                                                                        // terão que trocar de lugar indo para o método "bind" "
                                                                        // apresentar.bind(pessoa, 'Engenheiro', 'São Paulo')"

                        apresentarJoao('Engenheiro', 'São Paulo');
                        // Saída: "Olá, meu nome é João e tenho 30 anos. Sou Engenheiro de São Paulo."

                    . Quando o método "bind" é chamado, ele cria uma nova função que tem o mesmo comportamento que a função original, 
                        mas com o contexto (this) definido por thisArg. Além disso, os argumentos arg1, arg2, ... são passados para 
                        a função como argumentos adicionais


            Array

                . Um tipo especial de objeto usado para armazenar listas ordenadas de valores.
        
                . Exemplo:

                    let arr = new Array();
                    let arr = [];
                    let athletes = new Array(3); 

                    let numbers = [1, 2, 3, 4, 5];

                    console.log( numbers[0] );  // 1

                    let scores = new Array(9,10,8,7,6);


                . Observe se usarmos a criação do array com o construtor Array(1,2,...), precisamos do operador "new".

                . Podemos adicionar um novo item diretamente no array sem fazer uso de funções/métodos:

                    let fruits = ["Apple", "Orange", "Plum"];

                    fruits[3] = "Banana";
                    fruits[4] = "Pear";
                    fruits[5] = "Peach";

                    console.log(fruits);    // ['Apple', 'Orange', 'Plum', 'Banana', 'Pear', 'Peach']
                    console.log(fruits[3]); // "Banana"

                . Um array pode adicionar outros tipos de objetos:

                    // mix of values
                    let arr = [ 'Apple', { name: 'John' }, true, function() { console.log('hello'); } ];

                    console.log(arr[0]); // Apple

                    // get the object at index 1 and then show its name
                    console.log( arr[1].name ); // John

                    // get the function at index 3 and run it
                    arr[3](); // hello


                . Métodos de um objeto Array:

                    . "length" - Retorna o total de elementos do array:

                        let fruits = ["Apple", "Orange", "Plum"];

                        console.log( fruits.length ); // 3

                    . "push" e "unshift" - Para adicionar um elemento ao array utilizamos o método "push", ou "unshift" para adicionar o item no inicio:

                        let seas = ['Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea'];
                        seas.push('Red Sea');   // Adiciona no final do array

                        console.log(seas);  // [ 'Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea', 'Red Sea' ]

                        seas.unshift('Blue Sea');   // Adiciona no inicio do array

                        console.log(seas);  // [ 'Blue Sea', 'Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea', 'Red Sea' ]

                    . "pop" e "shift" - Para eliminar um elemento ao array utilizamos "pop", ou "shift"

                        let seas = ['Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea'];
                        const lastElement = seas.pop();         // Remove o item no final do array
                        console.log(lastElement); 

                        const firstElement = seas.shift();

                        console.log(firstElement);              // Remove o item do inicio do array

                    . "indexOf" - Para localizar um item no array utilizamos o método "indexOf":

                        let seas = ['Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea'];
                        let index = seas.indexOf('North Sea');

                        console.log(index); // 2

                    . "isArray" - Para verificar se um objeto é array utilizamos o metodo "isArray":

                        console.log(Array.isArray(seas)); // true

                    . "filter" -  função de array que cria um novo array com todos os elementos que passam no teste implementado pela função 
                                    fornecida.

                        // arr      é o array original
                        // callback é a função de teste que é chamada para cada elemento do array
                        // thisArg  é o valor que é usado como this dentro da função de teste
                        var novoArray = arr.filter(callback[, thisArg])                                    

                        . A função de teste callback é chamada com os seguintes argumentos:

                            element: o elemento atual do array
                            index: o índice do elemento atual no array
                            array: o array original

                        .Se a função de teste retornar true, o elemento é incluído no novo array. Se retornar false, o elemento é ignorado.

                            var numeros = [1, 2, 3, 4, 5, 6];

                            var pares = numeros.filter(function(element) {
                                return element % 2 === 0;
                            });

                            console.log(pares); // [2, 4, 6]

                        . Podemos usar arrow functions para tornar o código mais conciso:

                            var numeros = [1, 2, 3, 4, 5, 6];

                            var pares = numeros.filter(element => element % 2 == 0 );

                            console.log(pares); // [2, 4, 6]

                    . "find" - Função de array que retorna o primeiro elemento do array que passa no teste implementado pela função fornecida.

                        // Os parâmetros segue a mesma lógica do método "filter"
                        var encontrado = arr.find(callback[, thisArg])

                        Exemplo:

                            var frutas = ['maçã', 'banana', 'laranja', 'uva'];

                            var encontrada = frutas.find(function(fruta) {
                                return fruta === 'banana';
                            });

                            console.log(encontrada); // 'banana'



                            ou

                            var frutas = ['maçã', 'banana', 'laranja', 'uva'];

                            var encontrada = frutas.find(fruta => fruta === 'banana');                            

                            console.log(encontrada); // 'banana'

                    . "reduce" -  é usado para aplicar uma função a cada elemento de um array e reduzi-los a um único valor

                        const numbers = [1, 2, 3, 4, 5];

                        //                                  +----------------> A função de callback (accumulator, current) é chamada para cada elemento do array
                        //                                  |
                        const sum = numbers.reduce((accumulator, current) => {
                            return accumulator + current;
                        }, 0);  //      |           |
                        // |            |           +------------------------> O current é o elemento atual do array
                        // |            +------------------------------------> O accumulator é o valor retornado pela função de callback na iteração anterior
                        // +-------------------------------------------------> Valor utilizado para iniciar a variável "accumalator"
                        //
                        // No primeiro passo, o accumulator é iniciado com o valor 0 (o segundo argumento da função reduce) e o 
                        // current é o primeiro elemento do array (1). A função de callback retorna 0 + 1 = 1.
                        //
                        // No segundo passo, o accumulator é 1 e o current é o segundo elemento do array (2). A função de callback retorna 1 + 2 = 3


                        console.log(sum); // imprime 15


                        // Outro Exemplo

                        const names = ['John', 'Jane', 'Bob', 'Alice'];

                        const fullName = names.reduce((accumulator, current) => {
                            return accumulator + ', ' + current;
                        }, '');

                        console.log(fullName); // imprime 'John, Jane, Bob, Alice'

                    . "apply" ou "call" - É um método que permite chamar uma função em um contexto específico, definido pelo objeto "this". 
                                            Ela é usada para definir o valor de "this" dentro da função e passar argumentos para a função.

                        //              +------------------>    é o objeto que será usado como contexto (this) dentro da função 
                        //              |
                        função.apply(thisArg, argsArray)
                        //       |                |
                        //       |                +-------->     é um array de argumentos que serão passados para a função
                        //       +------------------------->     poderia ter sido usado a função "call" ao invés de "apply"

                        . Quando a função "apply()" é chamada, a função é executada com o contexto (this) definido por "thisArg" e os 
                            argumentos passados em "argsArray".

                            const pessoa = {
                                nome: 'João',
                                idade: 30
                            };

                            function apresentar() {
                                console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
                            }

                            apresentar.apply(pessoa); // Saída: "Olá, meu nome é João e tenho 30 anos."

                        . Diferença entre "apply" e "call":

                            . "apply" - Os argumentos são passados em um array.

                                função.apply(thisArg, argsArray)

                            . "call" - Os argumentos são passados individualmente, separados por vírgulas.

                                função.call(thisArg, arg1, arg2, ...)

                . Formas de iterar um array:

                    const scores = [22, 54, 76, 92, 43, 33];

                    // Com método "map"
                    scores.map( (elemento, indice ) => 
                    { 
                        console.log( "Score " + elemento + " Indíce " + indice );
                    });

                    // Com "for..in"
                    for (i in scores) {
                        console.log(scores[i]);
                    }

                    // Com "forEach"
                    scores.forEach((score) => {
                        console.log(score);
                    });

                    scores.forEach((score) => console.log(score));

                    // Com "while"
                    let i = 0;

                    while (i < scores.length) {
                        console.log(scores[i]);
                        i++;
                    }

                    // Com "do"
                    let i = 0;

                    do {
                        console.log(scores[i]);
                        i++;
                    } while (i < scores.length);


                    // Com "for"
                    for (let i = 0; i < scores.length; i++) {
                        console.log(scores[i]);
                    }

                    // Com "for..of"
                    for (score of scores) {
                        console.log(score);
                    }

            Function

                . Um objeto que pode ser chamado (invocado) para executar um bloco de código.

                . Exemplo:

                    const showMessage = () => {
                      console.log("Hello World!");
                    }

                    showMessage();

            Date
            
                . Um objeto que representa uma data e hora.

                . Exemplo:
            
                    let now = new Date();

            RegExp
            
                . Um objeto que representa uma expressão regular, usada para correspondência de padrões em strings.
            
                . Exemplo:
            
                    let pattern = /ab+c/;

            Map
            
                . Um objeto que armazena pares chave-valor e lembra a ordem original das chaves.
            
                . Exemplo:

                    let map = new Map();

                    map.set('key1', 'value1');

                    for (item of map) {
                        console.log(item);  // [ 'key1', 'value1' ]
                    }

                    for (let item of map.values()) {
                        console.log(item);  // 'value1'
                    }

                    console.log(map.get('key1'));   // 'value1'

            Set

                . Um objeto que armazena valores únicos de qualquer tipo, seja primitivo ou de referência.

                . Exemplo:
            
                    // Criando um novo Set
                    const mySet = new Set();

                    // Adicionando valores ao Set
                    mySet.add(1);
                    mySet.add('hello');
                    mySet.add({ name: 'John' });

                    // Verificando se um valor está presente no Set
                    console.log(mySet.has(1)); // true
                    console.log(mySet.has('hello')); // true
                    console.log(mySet.has({ name: 'John' })); // true

                    // Obtenendo o tamanho do Set
                    console.log(mySet.size); // 3

                    // Iterando sobre os valores do Set
                    mySet.forEach(value => {
                        console.log(value);
                    });

                    // Removendo um valor do Set
                    mySet.delete('hello');

                    // Verificando se um valor está ausente do Set
                    console.log(mySet.has('hello')); // false


        . Exemplo de Uso
        
            . Aqui está um exemplo que demonstra o uso de vários tipos de dados em JavaScript:

                // Tipos Primitivos
                let age = 25; // Number
                let name = "Alice"; // String
                let isActive = true; // Boolean
                let x; // Undefined
                let y = null; // Null
                let sym = Symbol('description'); // Symbol
                let bigInt = 1234567890123456789012345678901234567890n; // BigInt

                // Tipos de Referência
                let person = { name: "Alice", age: 30 }; // Object
                let numbers = [1, 2, 3, 4, 5]; // Array
                function greet() { console.log("Hello, world!"); } // Function
                let now = new Date(); // Date
                let pattern = /ab+c/; // RegExp
                let map = new Map(); // Map
                map.set('key1', 'value1');
                let set = new Set(); // Set
                set.add(1);
                set.add(2);

                console.log(age, name, isActive, x, y, sym, bigInt);
                console.log(person, numbers, greet, now, pattern, map, set);

    . Objetos

        . Objetos em javascript assemelha-se um pouco com uma estrutura json:

            let person = {
                firstName: 'John',
                lastName: 'Doe'
            };

        . Podemos incluir métodos:

            let apple = {
                valueOf: function () {
                    return 10;
                },
            };

            let orange = {
                toString: function () {
                    return '20';
                },
            };

            console.log( apple.valueOf() );
            console.log( orange.toString() );

        . Exemplos de como obter as informações dos objetos javascript:

            console.log(person.firstName);
            console.log(person.lastName);

            console.log(person['firstName']);
            console.log(person['lastName']);

        . O nome das propriedades podem conter espaços, porém não é uma boa prática:

            let address = {
                'building no': 3960,
                street: 'North 1st street',
                state: 'CA',
                country: 'USA'
            };

            console.log( address['building no'] );
            console.log( address.'building no' );   // Neste caso ocorrerá um erro

        . Para adicionar dinamicamente uma nova propriedade, basta atribuir um valor a nova propriedade:

            address.zipCode = "02423100";   // Adiciona dinamicamente a nova propriedade

            console.log( address.zipCode );


4. Operadores
-------------

    . Aritiméticos

        Operator	    Sign
        --------        ----
        Addition	    +
        Subtraction	    -
        Multiplication	*
        Division	    /
        Resto           %

    . Atribuição

        Operator	Meaning	    Description
        --------    -------     -----------
        a = b	    a = b	    Assigns the value of b to a.
        a += b	    a = a + b	Assigns the result of a plus b to a.
        a -= b	    a = a - b	Assigns the result of a minus b to a.
        a *= b	    a = a * b	Assigns the result of a times b to a.
        a /= b	    a = a / b	Assigns the result of a divided by b to a.
        a %= b	    a = a % b	Assigns the result of a modulo b to a.
        a &=b	    a = a & b	Assigns the result of a AND b to a.
        a |=b	    a = a | b	Assigns the result of a OR b to a.
        a ^=b	    a = a ^ b	Assigns the result of a XOR b to a.
        a <<= b	    a = a << b	Assigns the result of a shifted left by b to a.
        a >>= b	    a = a >> b	Assigns the result of a shifted right (sign preserved) by b to a.
        a >>>= b	a = a >>> b	Assigns the result of a shifted right by b to a.    

    . Unários

        Unary Operators	    Name	                        
        ---------------     ----                            
        ++x	                Incrementa o valor 1 primeiro no x
        –-x	                Decrementa o valor 1 primeiro no x
        x++	                Utiliza o valor do x na operação para depois fazer a adição de 1 ao x
        x–-	                Utiliza o valor do x na operação para depois fazer a subtração de 1 ao x

    . Comparação

        Operator	Meaning
        --------    -------
        <	        less than
        >	        greater than
        <=	        less than or equal to
        >=	        greater than or equal to
        ==	        equal to
        !=	        not equal to
        ===	        strict equal
        !==	        not strict equal

        . Diferença entre "==" e "==="

            . "==" quando utilizado para uma condição o operador irá converter o tipo da segunda parte da comparação para o tipo 
                da primeira. Caso o conteúdo encontrado forem iguais a condição é verdadeira "true"

            . "===" quando utilizado não faz nenhuma conversão e se os tipos forem diferentes dará falso.

            . Exemplo:

                console.log( 1 == "1" );        // true
                console.log( 1 === "1" );       // false

    . Operadores lógicos

        ! (Logical NOT)
        || (Logical OR)
        && (Logical AND)

    . Operador (nullish coalescing) "IFNULL"

        . Importante, esse operador só funciona no ambiente do navegador. No ambiente do nodejs não executou.

        . Representado pelo simbolo "??", retorna o segundo valor se o primeiro for null/undefined:

            const name = null ?? 'John';

            console.log(name); // 'John'

            const age = undefined ?? 28;

            console.log(age);   // 28

            const city = ( null || undefined ) ?? "SAO PAULO";

            console.log( city );        // SAO PAULO

    . Exponenciação

        . Utilizamos o simbolo "**", equivalente a função "Math.pow( value1, value2 )". São forma de obter um número levado a uma determinada potência.

        . Exemplo:

            console.log( Math.pow( 2,2 ) );         // 4

            console.log( 2 ** 2 );                  // 4

        . Se o primeiro número for negativo ele deve vir entre parenteses. Já o segundo não há restrição.

            console.log( (-2) ** 2 );                  // 4


5. Controle de Fluxo
--------------------

    . "if"

        . Exemplos:

            // Exemplo de um simple "if"
            let age = 18;

            if (age >= 18) {
                console.log('You can sign up');
            }


            // Exemplo de um "if/else"
            let age = 18;

            if (age >= 18) {
                console.log('You can sign up.');
            } else {
                console.log('You must be at least 18 to sign up.');
            }

            // Exemplo de um "if/else if"
            let month = 6;
            let monthName;

            if (month == 1) {
                monthName = 'Jan';
            } else if (month == 2) {
                monthName = 'Feb';
            } else if (month == 3) {
                monthName = 'Mar';
            } else if (month == 4) {
                monthName = 'Apr';
            } else if (month == 5) {
                monthName = 'May';
            } else if (month == 6) {
                monthName = 'Jun';
            } else if (month == 7) {
                monthName = 'Jul';
            } else if (month == 8) {
                monthName = 'Aug';
            } else if (month == 9) {
                monthName = 'Sep';
            } else if (month == 10) {
                monthName = 'Oct';
            } else if (month == 11) {
                monthName = 'Nov';
            } else if (month == 12) {
                monthName = 'Dec';
            } else {
                monthName = 'Invalid month';
            }

            console.log(monthName);

    . Operador Ternário "?:"

        let age = 18;
        let message;

        age >= 16 ? (message = 'You can drive.') : (message = 'You cannot drive.');

        console.log(message);

        message = age<18 ? "de menor" : "de maior";

        console.log(message);

    . "switch case"

        let day = 3;
        let dayName;

        switch (day) {
            case 1:
                dayName = 'Sunday';
                break;                  
            case 2:
                dayName = 'Monday';
                break;
            case 3:
                dayName = 'Tuesday';
                break;                      // O "break" é obrigatório para sair do case, 
            case 4:                         // caso contrário a execução irá para o próximo case, até encontrar um outro "break"
                dayName = 'Wednesday';
                break;
            case 5:
                dayName = 'Thursday';
                break;
            case 6:
                dayName = 'Friday';
                break;
            case 7:
                dayName = 'Saturday';
                break;
            default:
                dayName = 'Invalid day';
        }

        console.log(dayName); // Tuesday

    . "while"

        let count = 1;
        while (count < 10) {
            console.log(count);
            count +=2;
        }

    . "do while"

        let count = 0;
        do {
            console.log(count);
            count++;
        } while (count < 5)

    . "for"

        for (let i = 1; i < 5; i++) {
            console.log(i);
        }

    . "break" - Pode ser usado para "for", "while" e "do while"

        for (let i = 0; i < 5; i++) {
            console.log(i);

            if (i == 2) {
                break;
            }
        }

    . "continue" - Pode ser usado para "for", "while" e "do while"

        for (let i = 0; i < 10; i++) {
            if (i % 2 === 0) {
                continue;
            }

            console.log(i);
        }


6. Funções
----------

    . Declaração de forma simples:

        function say(message) {
            console.log(message);
        }

    . Armazenando funções em variáveis:

        function add(a, b) {
            return a + b;
        }

        let sum = add;

        console.log(sum(5, 7)); // 12        

    . Definindo número infinito de parâmetros (...):

        // "..." representa o número indefinido de parâmetros
        function sum(...args) {
            let total = 0;

            for (const a of args) {
                total += a;
            }

            return total;
        }

        console.log(sum(1, 2, 3));  // 6

    . Definindo número infinito de parâmetros (...), porém com tipos de parâmetros diferentes:

        function sum(...args) {
            return args
                .filter(function (e) {
                    return typeof e === 'number';
                })
                .reduce(function (prev, curr, index, arr) {

                    // prev: o valor anterior (ou o valor inicial, se for o primeiro elemento).
                    // curr: o elemento atual.
                    // index: o índice do elemento atual. Na prática, o index iniciará não pela indíce "0" e sim pelo "1"
                    // array: o array original.

                    console.log(index);
                    console.log(arr);
                    console.log(prev, curr);
                    
                    
                    return prev + curr;
                });
        }

        let result = sum(10, 'Hi', null, undefined, 20, 30, 40);

        console.log(result);
 
    . Passando uma função como parâmetro:

        function add(a, b) {
            return a + b;
        }

        let sum = add;

        function average(a, b, fn) {
            return fn(a, b) / 2;
        }

        let result = average(10, 20, sum);

        console.log(result);

    . Retornando um função de dentro de uma função:

        // Crie a função
        function compareBy(propertyName) {
            return function (a, b) {
                let x = a[propertyName],
                y = b[propertyName];

                if (x > y) {
                    return 1;
                } else if (x < y) {
                    return -1;
                } else {
                    return 0;
                }
            };
        }


        // Crie o objeto abaixo
        let products = [
            {name: 'Xiomi', price: 900},
            {name: 'Samsung Galaxy', price: 850},
            {name: 'Sony Xperia', price: 700}
        ];


        // Execute o código abaixo:
        console.log('Products sorted by name:');
        products.sort(compareBy('name'));

        console.table(products);

        ┌─────────┬──────────────────┬───────┐
        │ (index) │       name       │ price │
        ├─────────┼──────────────────┼───────┤
        │    0    │ 'Samsung Galaxy' │  850  │
        │    1    │  'Sony Xperia'   │  700  │
        │    2    │     'Xiomi'      │  900  │
        └─────────┴──────────────────┴───────┘

    . Funções anônimas:

        // Forma simples de declarar uma função anônima
        let show = function() {
            console.log('Anonymous function');
        }

        show();


        // Arrow function com blocos de código
        let show2 = () => {
            console.log('Arrow function');
        }

        // Arrow function resumida
        let show3 = () => console.log('Arrow function resumida');


        // Outro exemplo, passando a função anônima parâmetro
        setTimeout(function() {
            console.log('Execute later after 1 second')
        }, 1000);



        // Invocando imediatamente a função
        (function add(a,b) {
            console.log("O valor de a + b é: " + (a + b) );     // O valor a + b é: 3
            
            return a + b;                                       // 3
        })(1,2);

        // Utilizando um objeto com funções
        const calculator = (function () {
            function add(a, b) {
                return a + b;
            }

            function multiply(a, b) {
                return a * b;
            }

            return {
                add: add,
                multiply: multiply
            }
        })();

        console.log(calculator.add(1, 2));
        console.log(calculator.multiply(1, 2));

        // Retornando vários valores numa função
        function getNames() {
            // get names from the database or API
            let firstName = 'John',
                lastName = 'Doe';

            // return as an array
            return [firstName, lastName];
        }

        console.log(getNames());

        // Retornando um objeto com varios valores numa função
        function getNames() {
            // get names from the database or API
            let firstName = 'John',
                lastName = 'Doe';

            // return values
            return {
                'firstName': firstName,
                'lastName': lastName
            };
        }

        let firstName = getNames().firstName;
        let lastName = getNames().lastName;

        console.log(firstName + ' ' + lastName);

        let name = getNames();

        console.log(name.firstName + ' ' + name.lastName);

    . Passagem de parâmetros por valor e por referência:


        . ByVal

            function square(x) {
                x = x * x;
                return x;
            }

            let y = 10;
            let result = square(y);     // Devido a variavel "y" ser primitiva ela será passada por valor

            console.log(result); // 100 
            console.log(y);             // Neste caso "y" não altera o valor, permanecendo com valor 10

        . ByRef

            let person = {
                name: 'John',
                age: 25,
            };

            function increaseAge(obj) {
                obj.age += 1;
            }

            increaseAge(person);        // "person" Por ser um objeto será passado por referência

            console.log(person);        // Neste caso a propriedade "age" passará de 25 para 26

    . Parâmetros Default

        function say(message='Hi') {
            console.log(message);
        }

        say(); // 'Hi'
        say('Hello') // 'Hello'

7. Objetos
----------

    . Como dito anteriormente, objetos em javascript assemelha-se um pouco com uma estrutura json:

        let person = {
            firstName: 'John',
            lastName: 'Doe'
        };

    . Porém, a diferença inicia com a possibilidade que temos de inserir métodos. Os métodos podem ser inseridos nos 
        objetos de diversas formas:

        . Forma No. 1:

            let person = {
                firstName: 'John',
                lastName: 'Doe'
            };

            person.greet = function () {
                console.log('Hello!');
            }

            person.greet();

        . Forma No. 2:

            let person = {
                firstName: 'John',
                lastName: 'Doe'
            };

            function greet() {
                console.log('Hello, World!');
            }

            person.greet = greet;

            person.greet();

        . Forma No. 3:

            let person = {
                firstName: 'John',
                lastName: 'Doe',
                greet: function () {
                    console.log('Hello, World!');
                },
                getFullName: function () {
                    return this.firstName + ' ' + this.lastName;
                }
            };


            console.log(person.getFullName());

        . Forma 4

            let person = {
                firstName: 'John',
                lastName: 'Doe',
                greet() {
                    console.log('Hello, World!');
                },
                getFullName() {
                    return this.firstName + ' ' + this.lastName;
                }
            };


            console.log(person.getFullName());

    . Fabrica de funções:

        function createPerson(firstName, lastName) {
            return {
                firstName: firstName,
                lastName: lastName,
                getFullName() {
                return firstName + ' ' + lastName;
                },
            };
        }

        let person1 = createPerson('John', 'Doe');
        let person2 = createPerson('Jane', 'Doe');

        console.log(person1.getFullName());
        console.log(person2.getFullName());


    . Obtendo valores das propriedades do objeto:

        var person = {
            firstName: 'John',
            lastName: 'Doe',
            ssn: '299-24-2351',
            getFullName: function () {
                return this.firstName + ' ' + this.lastName;
            }
        };

        for (var prop in person) {
            if (typeof person[prop] === 'function') continue;   // Para imprimir somente o valor das propriedades

            console.log(prop + ':' + person[prop]);
        }

    . Construtor

        . A forma para se criar um objeto com um método construtor é criar uma função:

            function Person(firstName, lastName) {
                // add properties to this
                this.firstName = firstName;
                this.lastName = lastName;

                // return this;
            }


            let person = new Person('John','Doe');

        . Importante, as propriedades do objetos são criadas automaticamente durante a atribuição dos valores.

        . Os parâmetros do construtor podem ser feitos com valores "defaults":

            // Valor defaults   ----------+     ----------------+
            //                            |                     |
            //                            v                     V
            function Person(firstName = "Mark", lastName = "Silva") {
                ...
            }


        . Podemos construir métodos dentro desses objetos:

            // Método construtor
            function Person(firstName, lastName) {
                this.firstName = firstName;
                this.lastName = lastName;

                this.getFullName = function () {
                    return this.firstName + " " + this.lastName;
                };
            }

            let person = new Person("John", "Doe");

            console.log(person.getFullName());

        . A criação de classe com construtor obedece duas regras:

            . O nome da função deve começar com letra maiuscula, embora essa seja mais uma convenção porque nos testes
                o nome com letra minuscula também funcionou perfeitamente.

            . A criação do objeto deve sempre ser feito através do operador "new"

    . Object.Create

        var personActions = {
            getFullName() {
                return this.firstName + ' ' + this.lastName;
            },
        };

        function createPerson(firstName, lastName) {
            let person = Object.create(personActions);  // Cria um objeto com o objeto "Object", envia o objeto "personActions" no construtor.
            person.firstName = firstName;               // O retorno será um objeto com o "personActions" na estrutura.
            person.lastName = lastName;                 
            return person;                              // Incrementa as propriedades no objeto criado, formando um único.
        }

        let person1 = createPerson('John', 'Doe');
        let person2 = createPerson('Jane', 'Doe');

        console.log(person1.getFullName());
        console.log(person2.getFullName());

    . Initializer shorthand

        Exemplo 1:

            let name = 'Computer',
                status = 'On';

            let machine = {
                name,
                status
            };

            console.log(machine);   // {name: 'Computer', status: 'On'}

        Exemplo 2

            function createMachine(name, status) {
                return {
                    name,
                    status
                };
            }

            let machine1 = createMachine('Computer', 'On');

            console.log(machine);   // {name: 'Computer', status: 'On'}

    . This

        .  É uma palavra-chave que se refere ao objeto atual que está sendo executado. Em outras palavras, é o contexto 
            em que uma função é chamada.

        .  Referência ao objeto corrente:

            . Exemplo 1:

                let counter = {
                    count: 0,
                    next: function () {
                        return ++this.count;        // Aqui
                    },
                };

                counter.next();

            . Exemplo 2:

                function Pessoa(nome) {
                    this.nome = nome;
                }

                const joao = new Pessoa('João');

                console.log(joao.nome); // João

        . Contexto global - Fora de um objeto, this referencia a "window"

            this.color= 'Red';
            console.log(window.color); // 'Red'

        . Diferenças do uso do this em function e object:

            . Function - O uso do "this" é obrigatório quando criamos funções/métodos dentro de funções:

                function Person(firstName = "Marco", lastName = "Silva") {
                    this.firstName = firstName;
                    this.lastName = lastName;

                    // Aqui
                    this.getFullName = function () {
                        return this.firstName + " " + this.lastName;
                    };

                    // Aqui
                    this.showFullName = function () {
                        console.log(this.getFullName());
                    };
                }

                const p = new Person("Jose", "Maria");

                p.showFullName();

            . Object - O uso não é necessário:

                const pessoa = {
                    nome: 'João',

                    falar: function () {       //                      Function
                        console.log(this.nome); // João
                    }
                };

                pessoa.falar(); 

        . Atenção - Em função de seta (arrow function), this não é redefinido e não herda o contexto do objeto e sim do pai

            . Exemplos de como não usar o "this":

                . Exemplo 1:

                    const pessoa = {
                        nome: 'João',
                        falar: () => {              //                      Arrow function
                            console.log(this.nome); // undefined
                        },

                        falar2: function () {       //                      Function
                            console.log(this.nome); // João
                        }
                    };

                    pessoa.falar(); // undefined

                    pessoa.falar2();    // João

                . Exemplo 2:

                    ...
                    <input type="text" name="username" id="username" placeholder="Enter a username">
                    <div id="greeting"></div>
                    ...

                    <script>
                        const greeting = document.querySelector('#greeting');
                        const username = document.querySelector('#username');

                        username.addEventListener('keyup', () => {
                            greeting.textContent = 'Hello ' + this.value;       // Ao invés de usar o this, use "greeting.textContent = `Hello, ${userName.value}`;"
                        });                             //      |
                                                        //      +------> O resultado aqui é um "undefined", porque o this representa a variável global "window"
                    </script>                   

                            


                

8 . Prototype
-------------

    . Em JavaScript, prototype é uma propriedade de funções e objetos.

    . Em JavaScript, todas as funções são objetos. E cada função tem uma propriedade prototype que é um objeto. 
        Esse objeto contém propriedades e métodos que são compartilhados por todas as instâncias da função.

    . Quando você cria uma instância de uma função usando a palavra-chave new, a instância recebe todas as 
        propriedades e métodos do objeto prototype da função. Isso significa que você pode acessar essas 
        propriedades e métodos diretamente na instância.

        Por exemplo:

            function Pessoa(nome) {
                this.nome = nome;
            }

            Pessoa.prototype.falar = function() {
                console.log('Olá, meu nome é ' + this.nome);
            }

            const joao = new Pessoa('João');

            joao.falar(); // Olá, meu nome é João

    . Se quisermos fazer um "override" do método/função "falar" na classe concreta, a chamada desse método será da classe concreta:

            function Pessoa(nome) {
                this.nome = nome;

                this.falar = function(){
                    console.log("Meu nome é " + this.nome );
                }
            }

            Pessoa.prototype.falar = function() {
                console.log('Olá, meu nome é ' + this.nome);
            }

            const joao = new Pessoa('João');

            joao.falar(); // Meu nome é João


9. Classes
----------

    . Existem várias maneiras de declarar uma classe em JavaScript. Aqui estão algumas delas:

        . Declarando uma classe com a palavra-chave class

            class Pessoa {
                constructor(nome, idade) {
                    this.nome = nome;
                    this.idade = idade;
                }

                falar() {
                    console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
                }
            }
        
            const pessoa = new Pessoa("Marco", 57 );

            pessoa.falar();

        . Declarando uma classe com a função function

            function Pessoa(nome, idade) {
                this.nome = nome;
                this.idade = idade;
            }

            // Se criar um método dentro da classe com o "falar" e chamá-lo, a execução será sempre do método "prototype"
            Pessoa.prototype.falar = function() {
                console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
            };

            const pessoa = new Pessoa("Marco", 57 );

            pessoa.falar();


        . Declarando uma classe com a sintaxe de objeto

            const Pessoa = {
                constructor: function(nome, idade) {
                    this.nome = nome;
                    this.idade = idade;
                },
                falar: function() {
                    console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
                }
            };

            Pessoa.falar();         // Neste caso não é preciso criar o objeto, já pode usá-lo


        .  Declarando uma classe com a sintaxe de classe de ES6

            class Pessoa {
                constructor(nome, idade) {
                    this.nome = nome;
                    this.idade = idade;
                }

                falar() {
                    console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
                }

                static criarPessoa(nome, idade) {
                    return new Pessoa(nome, idade);
                }
            }

            const pessoa = Pessoa.criarPessoa('Marco', 57 );

            pessoa.falar();

        . Declarando uma classe com a sintaxe de classe de ES6 com herança

            class Pessoa {
                constructor(nome, idade) {
                    this.nome = nome;
                    this.idade = idade;
                }

                falar() {
                    console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
                }
            }

            class Aluno extends Pessoa {
                constructor(nome, idade, matricula) {
                    super(nome, idade);
                    this.matricula = matricula;
                }

                estudar() {
                    console.log(`Estou estudando...`);
                }
            }

            const pessoa = new Pessoa('Marco', 57);

            pessoa.falar();

            const aluno = new Aluno('Marco', 57, '123456');

            aluno.estudar();
            aluno.falar();

        . Declarando uma classe como expressão:

            let Person = class {
                constructor(name) {
                    this.name = name;
                }
                getName() {
                    return this.name;
                }
            }

            const marco = new Person('Marco');
            console.log(marco.name);

    . Getter and Setters

        class Person {
            constructor(name) {
                this._name = name;
            }
            get name() {
                return this._name;
            }
            set name(newName) {
                if (typeof newName !== 'string') {
                    throw 'The name must be a string';
                }

                newName = newName.trim();
                if (newName === '') {
                    throw 'The name cannot be empty';
                }
                this._name = newName;
            }
        }

        const marco = new Person('Marco');

        console.log(marco.name);

        marco.name = 'Antonio';

        console.log(marco.name);

    . Propriedades privadas - Utiliza-se o caracter "#" para identificar que a propriedade é privada

        class Pessoa {
            #nome;
            #idade;

            constructor(nome, idade) {
                this.#nome = nome;
                this.#idade = idade;
            }

            get nome() {
                return this.#nome;
            }
        }

        class Funcionario extends Pessoa {
            constructor(nome, idade, cargo) {
                super(nome, idade);
                this.cargo = cargo;
            }
        }

        const marco = new Funcionario('Marco', 57, 'Programador');

        console.log(marco.nome);

        // Esta linha levantará uma exception. Propriedades com identificação de "#" não podem ser
        // acessadas diretamente. É preciso que se construa um método dentro da classe pai para acessá-la
        console.log(marco.#nome);

    . Métodos Privados - O funcionamento de métodos privados segue a mesma lógica das propriedades privadas

        class Pessoa {
            #nome;
            #idade;

            constructor(nome, idade) {
                this.#nome = nome;
                this.#idade = idade;
            }

            #getNomePrivado() {
                return this.#nome;
            }
        }

        class Funcionario extends Pessoa {
            constructor(nome, idade, cargo) {
                super(nome, idade);
                this.cargo = cargo;
            }

            getNome() {
                return this.#getNomePrivado(); // Erro: SyntaxError: Private method '#getNomePrivado' must be declared in an enclosing class
            }
        }


    . new.target    - É uma propriedade que retorna o construtor que foi chamado com o operador new. 
                        Ela é usada para determinar se uma função foi chamada como um construtor ou como uma função regular.

                        Quando uma função é chamada com o operador new, o valor de new.target é o próprio construtor

        function Pessoa(nome) {
            if (new.target === Pessoa) {
                this.nome = nome;
            } else {
                throw new Error('Pessoa deve ser chamada com o operador new');
            }
        }

        // Neste caso o construtor não levantará uma exception
        const pessoa = new Pessoa('Marco');
        //              ^
        //              |
        //              +-------------- Se retirar o operador "new" da expressão "const pessoa = Pessoa('Marco');" a execução 
        //                              desse código levantará uma exceção
        //
        //                              Para que o "new.target" retorne o nome do construtor é necessário o uso de "new"


        // Aqui será levantado uma exception
        Pessoa('Marco');

        console.log( pessoa.nome );

    . Métodos Estáticos

        class Person {
            constructor(name) {
                this.name = name;
            }
            getName() {
                return this.name;
            }
            static createAnonymous() {
                return "createAnonymous";
            }
        }


        console.log(Person.createAnonymous());

    . Propriedades Estáticas

        class Item {
            constructor(name, quantity) {
                this.name = name;
                this.quantity = quantity;
                this.constructor.count++;
            }
            static count = 0;
            static getCount() {
                return Item.count;
            }
        }


        const parafuso = new Item('Parafuso', 10);

        console.log(Item.getCount());   // 1


        const tijolo = new Item('Tijolo', 5);

        console.log(Item.getCount());   // 2

    . instanceof - É utilizado para conferir se um objeto é derivado de uma determinada classe:

        function Person(name) {
            this.name = name;
        }

        let p1 = new Person('John');

        console.log(p1 instanceof Person); // true    


10. Tipos de Função
-------------------


https://www.javascripttutorial.net/javascript-callback/
