Curso de Javascript
-------------------

https://www.javascripttutorial.net/
https://learn-js.org/

https://javascript.info/

https://www.java5cript.com/
https://github.com/trekhleb/javascrip...
https://www.jsv9000.app/

Fundamentos
-----------


1. Instalações
--------------

    . Instalação do Nodejs

        curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | $SHELL
        nvm --version

        # Para instalar a versão lts mais recente
        nvm install --lts

        # Se quiser instalar uma versão especifica, utilize:
        # nvm install 18.20.4

        # Se quiser listar as versões do node disponivel no repositorio remoto
        # nvm ls-remote

        # Se quiser listar as versões instalada na máquina atual
        # nvm ls

        # Para usar uma versão instalada na máquina atual
        # nvm use 20.17.0

        # Para desinstalar uma versão do node js
        # nvm uninstall 18.20.4

        node -v
        npm -v



    . Instalação do VSCode:

        . Acessar a pagina de download da microsoft:

            https://code.visualstudio.com/download

        . Baixar o arquivo .deb 

        . Abrir o terminal e acessar a pasta Downloads

        . Executar o comando abaixo:

            sudo dpkg -i code_1.37.1-1565886362_amd64.deb

        . Atalhos

            Alt + 1, 2, 3, 4, ...	Posiona na aba no.
            Ctrl + b				Ativar o menu lateral esquerdo 
            Ctrl + Alt + P			Para ativar a linha de comandos 
            Ctrl + P 				Localiza um determinado arquivo
            Ctrl + W				Fecha a aba corrente
            Ctrl + Shift + W		Fecha todas as abas abertas

            Ctrl + Rolagem do Mouse	
                    sobre as abas 
                    abertas			Faz a rolagem das abas.

            Ctrl + K + C ou 
            Ctrl + /				Comenta linha atual, ou bloco selecionado

            Ctrl + K + U ou
            Ctrl + /				Descomenta linha, ou bloco selecionado.

            Ctrl + Shift + 
                    Acento Agudo	Abre o terminal na parte inferior

            Ctrl + X				Apaga linha
            Ctrl + H				Localiza e atualiza uma expressão
            Ctrl + F2				Selecione um texto e pressionando Ctrl + F2 
                                    muda todos os textos equivalente a medida
                                    que vai se digitando
            Alt + Arrow(up/Down)    Move a linha para cima, ou para baixo.
            Ctrl + Shift + O		Abre a lista de funções/métodos da classe atual
            Ctrl + G				Posicionar na linha No. que for digitado
            Alt + Backspace			Apaga palavra inteira a esquerda
            Ctrl + Shift + .		Mostra os métodos da classe
            Ctrl + Shift + L		Altera dinamicamente em todo o arquivo a palavra que está sendo alterada
            Ctrl + M				Para cercar um conjunto de tags numa página HTML ( Precisa de configurar, verifique como fazer em "Configurações" logo abaixo)
            cTRL + Ctrl + -			Para apagar uma tag que abraça um conjunto de tags HTML ( Precisa de configurar, verifique como fazer em "Configurações" logo abaixo)

        . Instale as seguinte Extensões:

            open-in-browser			- Shortcut Ctrl+Alt+O, Alt + B
            Material Icon Theme
            Numbered Bookmarks		- Shortcut Ctrl+Shit+1,2,3... , Ctrl+1,2,3...
            HTML CSS Support		- Ctrl + Space mostra as opções
            Intellisense for CSS Class
            JS-CSS-HTML Formatter	- Ctrl + Shift + I
            Live Server				- File -> Open Folder, Alt + L + O / Click no simbolo na barra do rodapé
                                    - Extensao que exibe online as alteraçoes feitas a página 
                                        no navegador.
                                    - Acesse o setting e inclua  "liveServer.settings.CustomBrowser": "chrome"
                                    - Para colocar o VSCode do lado do navegador clique Super + Left no VSCode
                                        e Super + Left no navegador
            Rainbow Brackets		- Ajuda identificar a abertura e fechamentos dos parenteses
            JQuery Code Snippets	- Basta digitar algo que comece com "jq"
            tslint - Plugin para apontar ausências no padrão de programação, deixando em vermelhos os pontos que não estão
                        em conformidade. 

                . Quando for trabalhar numa pasta de projeto, digite Ctrl + Shift + P e digitar "tslint", 
                    surge vários comandos especificos do plugin, escolha "Enable Workspace Library Execution"

                . Acrescente o trecho abaixo no arquivo launch.json para habilitar o plugin:

                    // Dentro do array "configurations"
                    "editor.codeActionsOnSave": {
                        "source.fixAll.tslint": true
                    }

        . Configurações:

            . Digite Ctrl K+S, localize o item "Delete Line" e configure Ctrl + D
            . Acesse View / Minimap para retirar o scroll de código da direita
            . Acessar configurações, ir em "Settings", Text editors, Sugestions:
                . Na opção "Accept Suggestion On Enter" deixar como off
                . Na opção "Suggest: Insert Mode" deixar como replace
                . Na opção "Quick Suggestions Delay" deixar como 1000
            . Acesse "Keyboard Shortcuts" em configurações:
                . Digite "Emmet: Wrap..." e altere o "Keybinding" para "Alt + M"
                    . De agora em diante, ao editar uma página HTML e quiser cercar um bloco de tags com uma outra, 
                        basta:
                        . Selecionar o bloco
                        . Digitar "Alt + M"
                        . Informar a tag que deseja colocar, somente a identificação sem "<>", por exemplo: "div"
                . Digite "Emmet: Remove Tag" e altere o "Keybinding" para "Alt+Shift+-", o "-" deve ser do bloco numerico
                    . De agora em diante, se precisar apagar uma tag HTML que cerca um conjunto de outras tags, basta posicioinar
                        o cursor sobre a "TAg" que deseja apagar e pressionar "Ctrl+Shift+-"
            . Digite "Ctrl+Shift+P" e digite "Preference: Open User Settings (JSON)"
                . Digite a configuração abaixo:

                    ...
                    "editor.linkedEditing": true,
                    "html.format.unformatted": "input",
                    "workbench.tree.indent": 20,
                    "workbench.tree.renderIndentGuides": "always",
                    "workbench.colorCustomizations": {
                        "tree.indentGuidesStroke": "#c8e0be"
                    }
            . Acesse Configurações -> Profile -> Import Profile 
                . Informe o link "https://vscode.dev/profile/github/12bd0215e34ffe344361b7dcf767842b" para resgatar as configurações para desenvolvimento em .NET

2. Começando
------------

    . DevTools do Browser

        . Recurso disponível nos navegadores, acessível através da tecla F12.

        . Fornece recursos para os desenvolvedores verificar a execução dos componentes da página, visualizar e editar o HTML, CSS e JavaScript.

            . Inspeção de elementos - a capacidade de editar o código HTML e CSS em tempo real, na guia "Elements"
            . Depuração de JavaScript  - Nas guias Console e Sources.
            . Emulação de dispositivos
            . Análise de desempenho - medir a performance do site, incluindo tempo de carregamento, uso de recursos e consumo de memória.

        . Demo

            . Crie a página abaixo:

                <!DOCTYPE html>
                <html lang="en">

                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Document</title>
                </head>

                <body>

                    <script>
                        console.log('Hello, devtools!');

                        // the following code causes an error
                        let greeting = msg;
                    </script>

                </body>

                </html>

            . Execute ela no navegador

            . Acione a tecla F12

                . Depuração de código
                    
                    . Acesse a guia "Sources" 

                    . Coloque um breakpoint na linha do "console.log('Hello, devtools!');"

                    . Recarregue a página e faça o debugger através da barra de ferramentas passo a passo

                        . Observe que podemos, durante o debugger, verificar conteúdo de variáveis na tela do "Console"

                        . Podemos dar prosseguimento ao debugger através das teclas:

                            F10 - Vai para a próxima linha
                            F11 - Se for uma subrotina, vai para a linha dessa sub
                            Shift + F11 - Se for uma subrotina, volta para a rotina chamadora
                            F8 - Continua a execução, indo para o próximo BreakPoint se houver.

                    . Observe que na linha "let greeting = msg;" ocorrerá um erro devido a variável "msg" não ter sido declarada.

                . Inpeção de Elementos

                    . Acesse a guia "Elements"

                    . Consulte as tags do HTML, no lado esquerdo

    . Exemplo "Hello World"

        . Existem diversas formas de inserir um bloco javascript na sua página, como por exemplo:

            . Embutido na própria página:

                <script>
                    ...
                </script>

            . Através de um arquivo externo:

                <script src="js/app.js"></script>

        . Existem dois atributos que podemos definir para carregar os scripts:

            . async - instrui o navegador para executar o script de forma assíncrona

                <script async src="service.js"></script>
                <script async src="app.js"></script>

            . defer - instrui o navegador executar o script depois que a página for carregada

                <!DOCTYPE html>
                <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <title>JavaScript defer demonstration</title>
                        <script defer src="defer-script.js"></script>
                    </head>
                    <body>
                    </body>
                </html>

3. Fundamentos
--------------

    . Ponto e virgula ";"

        . Colocado ao termino de cada linha de execução, porém não obrigatório

            let message = "Welcome to JavaScript";

            console.log(message);         

    . Chaves "{}" 

        . Delimita um bloco de linhas de comandos:

            if (window.localStorage) {
                console.log('The local storage is supported');
            }

    . Comentários

        "//"    Comenta uma linha
        "/* */" Comenta um bloco de linhas

    . Palavras reservadas

        . Definidas no ECMA-262

            break	    case	        catch
            continue	debugger	    default
            else	    export	        extends
            function	if	            import
            new	        return	        super
            throw	    try	            null
            void	    while	        with
            class	    delete	        finally
            in	        switch	        typeof
            yield	    const	        do
            for	        instanceof	    this
            var		        

        . Definidas no ECMA-252

            enum	    implements	    let
            protected	private	        public
            await	    interface	    package
            implements	public

    . Variáveis

        . Podemos utilizar três formas para declarar variáveis:

            . "let" Tem escopo de bloco, o que significa que uma variável declarada com let é visível apenas 
                    dentro do bloco em que foi declarada (por exemplo, dentro de chaves {}).

                    Hoisting: Variáveis declaradas com let também são içadas, mas não podem ser acessadas antes 
                    de sua declaração no código. Isso resulta em um erro de referência se você tentar usá-las 
                    antes da declaração.

                    Reatribuição: Pode ser reatribuída, mas não pode ser redeclarada no mesmo escopo.

                    Exemplo:

                        function example() {
                        // console.log(a); // ReferenceError: Cannot access 'a' before initialization
                        let a = 10;
                        console.log(a); // 10
                        }

                        example();

                        let b = 20;
                        // let b = 30; // SyntaxError: Identifier 'b' has already been declared
                        b = 30; // Reatribuição permitida
                        console.log(b); // 30

            . "var" tem escopo de função, o que significa que uma variável declarada com var é visível 
                    em toda a função em que foi declarada.
                    
                    Hoisting: Variáveis declaradas com var são "içadas" (hoisted) para o topo do seu escopo, 
                    mas a inicialização não é içada. Isso significa que você pode usar a variável antes de sua declaração, 
                    mas ela terá o valor undefined até que a linha de declaração seja executada.

                    Reatribuição: Pode ser reatribuída e redeclarada dentro do mesmo escopo.

                    Exemplo:

                        function example() {
                            console.log(x); // undefined (hoisting)
                            var x = 10;
                            console.log(x); // 10
                        }

                        example();

                        var y = 20;
                        var y = 30; // Redeclaração permitida
                        console.log(y); // 30


            . "const"   Também tem escopo de bloco, assim como let.

                        Hoisting: Variáveis declaradas com const são içadas, mas não podem ser acessadas antes de sua declaração 
                        no código, resultando em um erro de referência.

                        Reatribuição: Não pode ser reatribuída nem redeclarada. Uma vez que uma variável é atribuída com const, 
                        seu valor não pode ser alterado. No entanto, se a variável for um objeto ou um array, suas propriedades 
                        ou elementos podem ser modificados.

                        Exemplo:

                            function example() {
                                // console.log(c); // ReferenceError: Cannot access 'c' before initialization
                                const c = 10;
                                console.log(c); // 10
                            }

                            example();

                            const d = 20;
                            // const d = 30; // SyntaxError: Identifier 'd' has already been declared
                            // d = 30; // TypeError: Assignment to constant variable

                            const obj = { name: "Alice" };
                            obj.name = "Bob"; // Modificação permitida
                            console.log(obj.name); // Bob

                            const arr = [1, 2, 3];
                            arr.push(4); // Modificação permitida
                            console.log(arr); // [1, 2, 3, 4]

        . Resumo

            var:    Escopo de função, içamento com inicialização undefined, permite reatribuição e redeclaração.
            let:    Escopo de bloco, içamento sem inicialização, permite reatribuição, mas não redeclaração.
            const:  Escopo de bloco, içamento sem inicialização, não permite reatribuição nem redeclaração, 
                    mas permite a modificação de objetos e arrays.
            
            Escolher entre let, var e const depende do comportamento desejado para a variável. Em geral, let e const 
            são preferidos sobre var devido ao seu escopo de bloco e comportamento mais previsível.

    . Tipos de dados

        . O valor da variável define o tipo de dado.

            Exemplo:

                let counter = 120; // counter is a number
                counter = false;   // counter is now a boolean
                counter = "foo";   // counter is now a string

        . Para saber o tipo atual da variável podemos usar a função "typeof":

            Exemplo:

                let counter = 120;
                console.log(typeof(counter)); // "number"

                counter = false; 
                console.log(typeof(counter)); // "boolean"

                counter = "Hi";
                console.log(typeof(counter)); // "string"

        . "undefined" são variáveis declaradas, mas não iniciadas. 

            Exemplo:

                let counter;
                console.log(counter);        // undefined
                console.log(typeof counter); // undefined

        . Os tipos de dados (data types) podem ser classificados em dois grandes grupos: tipos primitivos e tipos de referência (objetos). 
            Aqui está uma visão geral dos tipos de dados disponíveis na linguagem:
        
        . Tipos Primitivos:

            Number
          
                . Representa números inteiros e de ponto flutuante.

                . Exemplo:

                    let age = 25;
                    let price = 19.99;

            String

                . Representa uma sequência de caracteres.

                . Utilizamos "+" para concatenar dois valores strings, ou "`" acento craseado, ou +=

                . Backslash para representar caracteres especiais:

                    Windows line break: '\r\n'
                    Unix line break: '\n'
                    Tab: '\t'
                    Backslash '\'

                . The following example uses the backslash character to escape the single quote character in a string:

                . Para comparar duas string utilize os operadores >, >=, <, <=, == 

                . Exemplo:

                    let name = "Alice";
                    let greeting = 'Hello, world!';

                    let msg = greeting + " " + name;    // Hello, World! Alice

                    // Acento craseado, só funciona assim
                    let msg2 = `${greeting} ${name}`;   // Hello, World! Alice 

                    let msg3 = 'Hello, World";

                    msg3 += " ";
                    msg3 += "Alice";        // Hello, World Alice


                    name[0] = "a";
                    console.log(name); // "Alice"   Podemos pegar o conteúdo como array, mas não altera-lo

                    let str = 'I\'m a string!';         // I´m a string

            Boolean

                . Representa um valor verdadeiro (true) ou falso (false).

                . Exemplo:

                    let isActive = true;
                    let isComplete = false;

            Undefined
            
                . Representa uma variável que foi declarada, mas não inicializada.

                . Exemplo:

                    let x;
                    console.log(x); // undefined

            Null

                . Representa a ausência intencional de qualquer valor de objeto.

                . Exemplo:

                    let y = null;

                    console.log(y);     // object

            Symbol (Introduzido no ES6)

                . Representa um valor único e imutável, frequentemente usado como identificador único para propriedades de objetos.

                . Veremos mais detalhes deste tipo mais a frente.

                . Exemplo:

                    let sym = Symbol('description');



            NaN (Not a Number)

                . Indica um número inválido

                . Exemplo:

                    console.log('a'/2); // NaN;

            BigInt (Introduzido no ES11)

                . Representa números inteiros de precisão arbitrária.

                . Exemplo:
            
                    let bigInt = 1234567890123456789012345678901234567890n;        

        . Tipos de Referência
        
            Object

                . Representa uma coleção de propriedades, onde cada propriedade é uma associação entre um nome (ou chave) e um valor.

                . Exemplo:

                    let contact = {
                        firstName: 'John',
                        lastName: 'Doe',
                        email: 'john.doe@example.com',
                        phone: '(408)-555-9999',
                        address: {
                            building: '4000',
                            street: 'North 1st street',
                            city: 'San Jose',
                            state: 'CA',
                            country: 'USA'
                        }
                    }

                    console.log( contact.phone);
                    console.log( contact["phone"]);
                    console.log( contact.address.street );

                . "bind" -  É uma função que cria uma nova função que tem o mesmo comportamento que a função original, 
                            mas com um contexto (this) específico.

                                    +---------------------->     é o objeto que será usado como contexto (this) dentro da função
                                    |
                    função.bind(thisArg, arg1, arg2, ...)
                                            |   |
                                            +---+---------->     são argumentos opcionais que serão passados para a função  

                    Exemplo:

                        const pessoa = {
                            nome: 'João',
                            idade: 30
                        };

                        function apresentar(titulo, cidade) {
                            console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos. Sou ${titulo} de ${cidade}.`);
                        }

                        const apresentarJoao = apresentar.bind(pessoa); // É possivel passar parâmetros além do "thisArg", porém nesse caso
                                                                        // os parâmetros passados pela chamada "apresentarJoao( 'Engenheiro', 'São Paulo')
                                                                        // terão que trocar de lugar indo para o método "bind" "
                                                                        // apresentar.bind(pessoa, 'Engenheiro', 'São Paulo')"

                        apresentarJoao('Engenheiro', 'São Paulo');
                        // Saída: "Olá, meu nome é João e tenho 30 anos. Sou Engenheiro de São Paulo."

                    . Quando o método "bind" é chamado, ele cria uma nova função que tem o mesmo comportamento que a função original, 
                        mas com o contexto (this) definido por thisArg. Além disso, os argumentos arg1, arg2, ... são passados para 
                        a função como argumentos adicionais


            Array

                . Um tipo especial de objeto usado para armazenar listas ordenadas de valores.
        
                . Exemplo:

                    let arr = new Array();
                    let arr = [];
                    let athletes = new Array(3); 

                    let numbers = [1, 2, 3, 4, 5];

                    console.log( numbers[0] );  // 1

                    let scores = new Array(9,10,8,7,6);


                . Observe se usarmos a criação do array com o construtor Array(1,2,...), precisamos do operador "new".

                . Podemos adicionar um novo item diretamente no array sem fazer uso de funções/métodos:

                    let fruits = ["Apple", "Orange", "Plum"];

                    fruits[3] = "Banana";
                    fruits[4] = "Pear";
                    fruits[5] = "Peach";

                    console.log(fruits);    // ['Apple', 'Orange', 'Plum', 'Banana', 'Pear', 'Peach']
                    console.log(fruits[3]); // "Banana"

                . Um array pode adicionar outros tipos de objetos:

                    // mix of values
                    let arr = [ 'Apple', { name: 'John' }, true, function() { console.log('hello'); } ];

                    console.log(arr[0]); // Apple

                    // get the object at index 1 and then show its name
                    console.log( arr[1].name ); // John

                    // get the function at index 3 and run it
                    arr[3](); // hello


                . Métodos de um objeto Array:

                    . "length" - Retorna o total de elementos do array:

                        let fruits = ["Apple", "Orange", "Plum"];

                        console.log( fruits.length ); // 3

                    . "push" e "unshift" - Para adicionar um elemento ao array utilizamos o método "push", ou "unshift" para adicionar o item no inicio:

                        let seas = ['Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea'];
                        seas.push('Red Sea');   // Adiciona no final do array

                        console.log(seas);  // [ 'Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea', 'Red Sea' ]

                        seas.unshift('Blue Sea');   // Adiciona no inicio do array

                        console.log(seas);  // [ 'Blue Sea', 'Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea', 'Red Sea' ]

                    . "pop" e "shift" - Para eliminar um elemento ao array utilizamos "pop", ou "shift"

                        let seas = ['Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea'];
                        const lastElement = seas.pop();         // Remove o item no final do array
                        console.log(lastElement); 

                        const firstElement = seas.shift();

                        console.log(firstElement);              // Remove o item do inicio do array

                    . "indexOf" - Para localizar um item no array utilizamos o método "indexOf":

                        let seas = ['Black Sea', 'Caribbean Sea', 'North Sea', 'Baltic Sea'];
                        let index = seas.indexOf('North Sea');

                        console.log(index); // 2

                    . "isArray" - Para verificar se um objeto é array utilizamos o metodo "isArray":

                        console.log(Array.isArray(seas)); // true

                    . "filter" -  função de array que cria um novo array com todos os elementos que passam no teste implementado pela função 
                                    fornecida.

                        // arr      é o array original
                        // callback é a função de teste que é chamada para cada elemento do array
                        // thisArg  é o valor que é usado como this dentro da função de teste
                        var novoArray = arr.filter(callback[, thisArg])                                    

                        . A função de teste callback é chamada com os seguintes argumentos:

                            element: o elemento atual do array
                            index: o índice do elemento atual no array
                            array: o array original

                        .Se a função de teste retornar true, o elemento é incluído no novo array. Se retornar false, o elemento é ignorado.

                            var numeros = [1, 2, 3, 4, 5, 6];

                            var pares = numeros.filter(function(element) {
                                return element % 2 === 0;
                            });

                            console.log(pares); // [2, 4, 6]

                        . Podemos usar arrow functions para tornar o código mais conciso:

                            var numeros = [1, 2, 3, 4, 5, 6];

                            var pares = numeros.filter(element => element % 2 == 0 );

                            console.log(pares); // [2, 4, 6]

                    . "find" - Função de array que retorna o primeiro elemento do array que passa no teste implementado pela função fornecida.

                        // Os parâmetros segue a mesma lógica do método "filter"
                        var encontrado = arr.find(callback[, thisArg])

                        Exemplo:

                            var frutas = ['maçã', 'banana', 'laranja', 'uva'];

                            var encontrada = frutas.find(function(fruta) {
                                return fruta === 'banana';
                            });

                            console.log(encontrada); // 'banana'



                            ou

                            var frutas = ['maçã', 'banana', 'laranja', 'uva'];

                            var encontrada = frutas.find(fruta => fruta === 'banana');                            

                            console.log(encontrada); // 'banana'

                    . "reduce" -  é usado para aplicar uma função a cada elemento de um array e reduzi-los a um único valor

                        const numbers = [1, 2, 3, 4, 5];

                        //                                  +----------------> A função de callback (accumulator, current) é chamada para cada elemento do array
                        //                                  |
                        const sum = numbers.reduce((accumulator, current) => {
                            return accumulator + current;
                        }, 0);  //      |           |
                        // |            |           +------------------------> O current é o elemento atual do array
                        // |            +------------------------------------> O accumulator é o valor retornado pela função de callback na iteração anterior
                        // +-------------------------------------------------> Valor utilizado para iniciar a variável "accumalator"
                        //
                        // No primeiro passo, o accumulator é iniciado com o valor 0 (o segundo argumento da função reduce) e o 
                        // current é o primeiro elemento do array (1). A função de callback retorna 0 + 1 = 1.
                        //
                        // No segundo passo, o accumulator é 1 e o current é o segundo elemento do array (2). A função de callback retorna 1 + 2 = 3


                        console.log(sum); // imprime 15


                        // Outro Exemplo

                        const names = ['John', 'Jane', 'Bob', 'Alice'];

                        const fullName = names.reduce((accumulator, current) => {
                            return accumulator + ', ' + current;
                        }, '');

                        console.log(fullName); // imprime 'John, Jane, Bob, Alice'

                    . "apply" ou "call" - É um método que permite chamar uma função em um contexto específico, definido pelo objeto "this". 
                                            Ela é usada para definir o valor de "this" dentro da função e passar argumentos para a função.

                        //              +------------------>    é o objeto que será usado como contexto (this) dentro da função 
                        //              |
                        função.apply(thisArg, argsArray)
                        //       |                |
                        //       |                +-------->     é um array de argumentos que serão passados para a função
                        //       +------------------------->     poderia ter sido usado a função "call" ao invés de "apply"

                        . Quando a função "apply()" é chamada, a função é executada com o contexto (this) definido por "thisArg" e os 
                            argumentos passados em "argsArray".

                            const pessoa = {
                                nome: 'João',
                                idade: 30
                            };

                            function apresentar() {
                                console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
                            }

                            apresentar.apply(pessoa); // Saída: "Olá, meu nome é João e tenho 30 anos."

                        . Diferença entre "apply" e "call":

                            . "apply" - Os argumentos são passados em um array.

                                função.apply(thisArg, argsArray)

                            . "call" - Os argumentos são passados individualmente, separados por vírgulas.

                                função.call(thisArg, arg1, arg2, ...)

                . Formas de iterar um array:

                    const scores = [22, 54, 76, 92, 43, 33];

                    // Com método "map"
                    scores.map( (elemento, indice ) => 
                    { 
                        console.log( "Score " + elemento + " Indíce " + indice );
                    });

                    // Com "for..in"
                    for (i in scores) {
                        console.log(scores[i]);
                    }

                    // Com "forEach"
                    scores.forEach((score) => {
                        console.log(score);
                    });

                    scores.forEach((score) => console.log(score));

                    // Com "while"
                    let i = 0;

                    while (i < scores.length) {
                        console.log(scores[i]);
                        i++;
                    }

                    // Com "do"
                    let i = 0;

                    do {
                        console.log(scores[i]);
                        i++;
                    } while (i < scores.length);


                    // Com "for"
                    for (let i = 0; i < scores.length; i++) {
                        console.log(scores[i]);
                    }

                    // Com "for..of"
                    for (score of scores) {
                        console.log(score);
                    }

            Function

                . Um objeto que pode ser chamado (invocado) para executar um bloco de código.

                . Exemplo:

                    const showMessage = () => {
                      console.log("Hello World!");
                    }

                    showMessage();

            Date
            
                . Um objeto que representa uma data e hora.

                . Exemplo:
            
                    let now = new Date();

            RegExp
            
                . Um objeto que representa uma expressão regular, usada para correspondência de padrões em strings.
            
                . Exemplo:
            
                    let pattern = /ab+c/;

            Map
            
                . Um objeto que armazena pares chave-valor e lembra a ordem original das chaves.
            
                . Exemplo:

                    let map = new Map();

                    map.set('key1', 'value1');

                    for (item of map) {
                        console.log(item);  // [ 'key1', 'value1' ]
                    }

                    for (let item of map.values()) {
                        console.log(item);  // 'value1'
                    }

                    console.log(map.get('key1'));   // 'value1'

            Set

                . Um objeto que armazena valores únicos de qualquer tipo, seja primitivo ou de referência.

                . Exemplo:
            
                    // Criando um novo Set
                    const mySet = new Set();

                    // Adicionando valores ao Set
                    mySet.add(1);
                    mySet.add('hello');
                    mySet.add({ name: 'John' });

                    // Verificando se um valor está presente no Set
                    console.log(mySet.has(1)); // true
                    console.log(mySet.has('hello')); // true
                    console.log(mySet.has({ name: 'John' })); // true

                    // Obtenendo o tamanho do Set
                    console.log(mySet.size); // 3

                    // Iterando sobre os valores do Set
                    mySet.forEach(value => {
                        console.log(value);
                    });

                    // Removendo um valor do Set
                    mySet.delete('hello');

                    // Verificando se um valor está ausente do Set
                    console.log(mySet.has('hello')); // false


        . Exemplo de Uso
        
            . Aqui está um exemplo que demonstra o uso de vários tipos de dados em JavaScript:

                // Tipos Primitivos
                let age = 25; // Number
                let name = "Alice"; // String
                let isActive = true; // Boolean
                let x; // Undefined
                let y = null; // Null
                let sym = Symbol('description'); // Symbol
                let bigInt = 1234567890123456789012345678901234567890n; // BigInt

                // Tipos de Referência
                let person = { name: "Alice", age: 30 }; // Object
                let numbers = [1, 2, 3, 4, 5]; // Array
                function greet() { console.log("Hello, world!"); } // Function
                let now = new Date(); // Date
                let pattern = /ab+c/; // RegExp
                let map = new Map(); // Map
                map.set('key1', 'value1');
                let set = new Set(); // Set
                set.add(1);
                set.add(2);

                console.log(age, name, isActive, x, y, sym, bigInt);
                console.log(person, numbers, greet, now, pattern, map, set);

    . Objetos

        . Objetos em javascript assemelha-se um pouco com uma estrutura json:

            let person = {
                firstName: 'John',
                lastName: 'Doe'
            };

        . Podemos incluir métodos:

            let apple = {
                valueOf: function () {
                    return 10;
                },
            };

            let orange = {
                toString: function () {
                    return '20';
                },
            };

            console.log( apple.valueOf() );
            console.log( orange.toString() );

        . Exemplos de como obter as informações dos objetos javascript:

            console.log(person.firstName);
            console.log(person.lastName);

            console.log(person['firstName']);
            console.log(person['lastName']);

        . O nome das propriedades podem conter espaços, porém não é uma boa prática:

            let address = {
                'building no': 3960,
                street: 'North 1st street',
                state: 'CA',
                country: 'USA'
            };

            console.log( address['building no'] );
            console.log( address.'building no' );   // Neste caso ocorrerá um erro

        . Para adicionar dinamicamente uma nova propriedade, basta atribuir um valor a nova propriedade:

            address.zipCode = "02423100";   // Adiciona dinamicamente a nova propriedade

            console.log( address.zipCode );

4. Operadores
-------------

    . Aritiméticos

        Operator	    Sign
        --------        ----
        Addition	    +
        Subtraction	    -
        Multiplication	*
        Division	    /
        Resto           %

    . Atribuição

        Operator	Meaning	    Description
        --------    -------     -----------
        a = b	    a = b	    Assigns the value of b to a.
        a += b	    a = a + b	Assigns the result of a plus b to a.
        a -= b	    a = a - b	Assigns the result of a minus b to a.
        a *= b	    a = a * b	Assigns the result of a times b to a.
        a /= b	    a = a / b	Assigns the result of a divided by b to a.
        a %= b	    a = a % b	Assigns the result of a modulo b to a.
        a &=b	    a = a & b	Assigns the result of a AND b to a.
        a |=b	    a = a | b	Assigns the result of a OR b to a.
        a ^=b	    a = a ^ b	Assigns the result of a XOR b to a.
        a <<= b	    a = a << b	Assigns the result of a shifted left by b to a.
        a >>= b	    a = a >> b	Assigns the result of a shifted right (sign preserved) by b to a.
        a >>>= b	a = a >>> b	Assigns the result of a shifted right by b to a.    

    . Unários

        Unary Operators	    Name	                        
        ---------------     ----                            
        ++x	                Incrementa o valor 1 primeiro no x
        –-x	                Decrementa o valor 1 primeiro no x
        x++	                Utiliza o valor do x na operação para depois fazer a adição de 1 ao x
        x–-	                Utiliza o valor do x na operação para depois fazer a subtração de 1 ao x

    . Comparação

        Operator	Meaning
        --------    -------
        <	        less than
        >	        greater than
        <=	        less than or equal to
        >=	        greater than or equal to
        ==	        equal to
        !=	        not equal to
        ===	        strict equal
        !==	        not strict equal

        . Diferença entre "==" e "==="

            . "==" quando utilizado para uma condição o operador irá converter o tipo da segunda parte da comparação para o tipo 
                da primeira. Caso o conteúdo encontrado forem iguais a condição é verdadeira "true"

            . "===" quando utilizado não faz nenhuma conversão e se os tipos forem diferentes dará falso.

            . Exemplo:

                console.log( 1 == "1" );        // true
                console.log( 1 === "1" );       // false

    . Operadores lógicos

        ! (Logical NOT)
        || (Logical OR)
        && (Logical AND)

    . Operador (nullish coalescing) "IFNULL"

        . Importante, esse operador só funciona no ambiente do navegador. No ambiente do nodejs não executou.

        . Representado pelo simbolo "??", retorna o segundo valor se o primeiro for null/undefined:

            const name = null ?? 'John';

            console.log(name); // 'John'

            const age = undefined ?? 28;

            console.log(age);   // 28

            const city = ( null || undefined ) ?? "SAO PAULO";

            console.log( city );        // SAO PAULO

    . Exponenciação

        . Utilizamos o simbolo "**", equivalente a função "Math.pow( value1, value2 )". São forma de obter um número levado a uma determinada potência.

        . Exemplo:

            console.log( Math.pow( 2,2 ) );         // 4

            console.log( 2 ** 2 );                  // 4

        . Se o primeiro número for negativo ele deve vir entre parenteses. Já o segundo não há restrição.

            console.log( (-2) ** 2 );                  // 4

5. Controle de Fluxo
--------------------

    . "if"

        . Exemplos:

            // Exemplo de um simple "if"
            let age = 18;

            if (age >= 18) {
                console.log('You can sign up');
            }


            // Exemplo de um "if/else"
            let age = 18;

            if (age >= 18) {
                console.log('You can sign up.');
            } else {
                console.log('You must be at least 18 to sign up.');
            }

            // Exemplo de um "if/else if"
            let month = 6;
            let monthName;

            if (month == 1) {
                monthName = 'Jan';
            } else if (month == 2) {
                monthName = 'Feb';
            } else if (month == 3) {
                monthName = 'Mar';
            } else if (month == 4) {
                monthName = 'Apr';
            } else if (month == 5) {
                monthName = 'May';
            } else if (month == 6) {
                monthName = 'Jun';
            } else if (month == 7) {
                monthName = 'Jul';
            } else if (month == 8) {
                monthName = 'Aug';
            } else if (month == 9) {
                monthName = 'Sep';
            } else if (month == 10) {
                monthName = 'Oct';
            } else if (month == 11) {
                monthName = 'Nov';
            } else if (month == 12) {
                monthName = 'Dec';
            } else {
                monthName = 'Invalid month';
            }

            console.log(monthName);

    . Operador Ternário "?:"

        let age = 18;
        let message;

        age >= 16 ? (message = 'You can drive.') : (message = 'You cannot drive.');

        console.log(message);

        message = age<18 ? "de menor" : "de maior";

        console.log(message);

    . "switch case"

        let day = 3;
        let dayName;

        switch (day) {
            case 1:
                dayName = 'Sunday';
                break;                  
            case 2:
                dayName = 'Monday';
                break;
            case 3:
                dayName = 'Tuesday';
                break;                      // O "break" é obrigatório para sair do case, 
            case 4:                         // caso contrário a execução irá para o próximo case, até encontrar um outro "break"
                dayName = 'Wednesday';
                break;
            case 5:
                dayName = 'Thursday';
                break;
            case 6:
                dayName = 'Friday';
                break;
            case 7:
                dayName = 'Saturday';
                break;
            default:
                dayName = 'Invalid day';
        }

        console.log(dayName); // Tuesday

    . "while"

        let count = 1;
        while (count < 10) {
            console.log(count);
            count +=2;
        }

    . "do while"

        let count = 0;
        do {
            console.log(count);
            count++;
        } while (count < 5)

    . "for"

        for (let i = 1; i < 5; i++) {
            console.log(i);
        }

    . "break" - Pode ser usado para "for", "while" e "do while"

        for (let i = 0; i < 5; i++) {
            console.log(i);

            if (i == 2) {
                break;
            }
        }

    . "continue" - Pode ser usado para "for", "while" e "do while"

        for (let i = 0; i < 10; i++) {
            if (i % 2 === 0) {
                continue;
            }

            console.log(i);
        }

6. Funções
----------

    . Declaração de forma simples:

        function say(message) {
            console.log(message);
        }

    . Armazenando funções em variáveis:

        function add(a, b) {
            return a + b;
        }

        let sum = add;

        console.log(sum(5, 7)); // 12        

    . Definindo número infinito de parâmetros (...):

        // "..." representa o número indefinido de parâmetros
        function sum(...args) {
            let total = 0;

            for (const a of args) {
                total += a;
            }

            return total;
        }

        console.log(sum(1, 2, 3));  // 6

    . Definindo número infinito de parâmetros (...), porém com tipos de parâmetros diferentes:

        function sum(...args) {
            return args
                .filter(function (e) {
                    return typeof e === 'number';
                })
                .reduce(function (prev, curr, index, arr) {

                    // prev: o valor anterior (ou o valor inicial, se for o primeiro elemento).
                    // curr: o elemento atual.
                    // index: o índice do elemento atual. Na prática, o index iniciará não pela indíce "0" e sim pelo "1"
                    // array: o array original.

                    console.log(index);
                    console.log(arr);
                    console.log(prev, curr);
                    
                    
                    return prev + curr;
                });
        }

        let result = sum(10, 'Hi', null, undefined, 20, 30, 40);

        console.log(result);
 
    . Passando uma função como parâmetro:

        function add(a, b) {
            return a + b;
        }

        let sum = add;

        function average(a, b, fn) {
            return fn(a, b) / 2;
        }

        let result = average(10, 20, sum);

        console.log(result);

    . Retornando um função de dentro de uma função:

        // Crie a função
        function compareBy(propertyName) {
            return function (a, b) {
                let x = a[propertyName],
                y = b[propertyName];

                if (x > y) {
                    return 1;
                } else if (x < y) {
                    return -1;
                } else {
                    return 0;
                }
            };
        }


        // Crie o objeto abaixo
        let products = [
            {name: 'Xiomi', price: 900},
            {name: 'Samsung Galaxy', price: 850},
            {name: 'Sony Xperia', price: 700}
        ];


        // Execute o código abaixo:
        console.log('Products sorted by name:');
        products.sort(compareBy('name'));

        console.table(products);

        ┌─────────┬──────────────────┬───────┐
        │ (index) │       name       │ price │
        ├─────────┼──────────────────┼───────┤
        │    0    │ 'Samsung Galaxy' │  850  │
        │    1    │  'Sony Xperia'   │  700  │
        │    2    │     'Xiomi'      │  900  │
        └─────────┴──────────────────┴───────┘

    . Funções anônimas:

        // Forma simples de declarar uma função anônima
        let show = function() {
            console.log('Anonymous function');
        }

        show();


        // Arrow function com blocos de código
        let show2 = () => {
            console.log('Arrow function');
        }

        // Arrow function resumida
        let show3 = () => console.log('Arrow function resumida');


        // Outro exemplo, passando a função anônima parâmetro
        setTimeout(function() {
            console.log('Execute later after 1 second')
        }, 1000);



        // Invocando imediatamente a função
        (function add(a,b) {
            console.log("O valor de a + b é: " + (a + b) );     // O valor a + b é: 3
            
            return a + b;                                       // 3
        })(1,2);

        // Utilizando um objeto com funções
        const calculator = (function () {
            function add(a, b) {
                return a + b;
            }

            function multiply(a, b) {
                return a * b;
            }

            return {
                add: add,
                multiply: multiply
            }
        })();

        console.log(calculator.add(1, 2));
        console.log(calculator.multiply(1, 2));

        // Retornando vários valores numa função
        function getNames() {
            // get names from the database or API
            let firstName = 'John',
                lastName = 'Doe';

            // return as an array
            return [firstName, lastName];
        }

        console.log(getNames());

        // Retornando um objeto com varios valores numa função
        function getNames() {
            // get names from the database or API
            let firstName = 'John',
                lastName = 'Doe';

            // return values
            return {
                'firstName': firstName,
                'lastName': lastName
            };
        }

        let firstName = getNames().firstName;
        let lastName = getNames().lastName;

        console.log(firstName + ' ' + lastName);

        let name = getNames();

        console.log(name.firstName + ' ' + name.lastName);

    . Passagem de parâmetros por valor e por referência:


        . ByVal

            function square(x) {
                x = x * x;
                return x;
            }

            let y = 10;
            let result = square(y);     // Devido a variavel "y" ser primitiva ela será passada por valor

            console.log(result); // 100 
            console.log(y);             // Neste caso "y" não altera o valor, permanecendo com valor 10

        . ByRef

            let person = {
                name: 'John',
                age: 25,
            };

            function increaseAge(obj) {
                obj.age += 1;
            }

            increaseAge(person);        // "person" Por ser um objeto será passado por referência

            console.log(person);        // Neste caso a propriedade "age" passará de 25 para 26

    . Parâmetros Default

        function say(message='Hi') {
            console.log(message);
        }

        say(); // 'Hi'
        say('Hello') // 'Hello'

    . Funções de "callback"

        . Funções de callback em JavaScript são funções que são passadas como argumentos para outras funções e são 
            executadas dentro da função que as recebe. Exemplo:

            function saudar(nome) {
                console.log(`Olá, ${nome}!`);
            }

            function chamarSaudar(nome, callback) {
                callback(nome);
            }

            chamarSaudar("João", saudar); // imprime "Olá, João!"

        . Nesse exemplo, a função dobrar é uma função de callback que é passada como argumento para a função map(). A função 
            map() chama a função dobrar para cada elemento do array e retorna um novo array com os resultados.

            const numeros = [1, 2, 3, 4, 5];

            const dobrar = (numero) => {
                return numero * 2;
            };

            const resultado = numeros.map(dobrar);

            console.log(resultado); // imprime [2, 4, 6, 8, 10]

7. Objetos
----------

    . Como dito anteriormente, objetos em javascript assemelha-se um pouco com uma estrutura json:

        let person = {
            firstName: 'John',
            lastName: 'Doe'
        };

    . Porém, a diferença inicia com a possibilidade que temos de inserir métodos. Os métodos podem ser inseridos nos 
        objetos de diversas formas:

        . Forma No. 1:

            let person = {
                firstName: 'John',
                lastName: 'Doe'
            };

            person.greet = function () {
                console.log('Hello!');
            }

            person.greet();

        . Forma No. 2:

            let person = {
                firstName: 'John',
                lastName: 'Doe'
            };

            function greet() {
                console.log('Hello, World!');
            }

            person.greet = greet;

            person.greet();

        . Forma No. 3:

            let person = {
                firstName: 'John',
                lastName: 'Doe',
                greet: function () {
                    console.log('Hello, World!');
                },
                getFullName: function () {
                    return this.firstName + ' ' + this.lastName;
                }
            };


            console.log(person.getFullName());

        . Forma 4

            let person = {
                firstName: 'John',
                lastName: 'Doe',
                greet() {
                    console.log('Hello, World!');
                },
                getFullName() {
                    return this.firstName + ' ' + this.lastName;
                }
            };


            console.log(person.getFullName());

    . Fabrica de funções:

        function createPerson(firstName, lastName) {
            return {
                firstName: firstName,
                lastName: lastName,
                getFullName() {
                return firstName + ' ' + lastName;
                },
            };
        }

        let person1 = createPerson('John', 'Doe');
        let person2 = createPerson('Jane', 'Doe');

        console.log(person1.getFullName());
        console.log(person2.getFullName());


    . Obtendo valores das propriedades do objeto:

        var person = {
            firstName: 'John',
            lastName: 'Doe',
            ssn: '299-24-2351',
            getFullName: function () {
                return this.firstName + ' ' + this.lastName;
            }
        };

        for (var prop in person) {
            if (typeof person[prop] === 'function') continue;   // Para imprimir somente o valor das propriedades

            console.log(prop + ':' + person[prop]);
        }

    . Construtor

        . A forma para se criar um objeto com um método construtor é criar uma função:

            function Person(firstName, lastName) {
                // add properties to this
                this.firstName = firstName;
                this.lastName = lastName;

                // return this;
            }


            let person = new Person('John','Doe');

        . Importante, as propriedades do objetos são criadas automaticamente durante a atribuição dos valores.

        . Os parâmetros do construtor podem ser feitos com valores "defaults":

            // Valor defaults   ----------+     ----------------+
            //                            |                     |
            //                            v                     V
            function Person(firstName = "Mark", lastName = "Silva") {
                ...
            }


        . Podemos construir métodos dentro desses objetos:

            // Método construtor
            function Person(firstName, lastName) {
                this.firstName = firstName;
                this.lastName = lastName;

                this.getFullName = function () {
                    return this.firstName + " " + this.lastName;
                };
            }

            let person = new Person("John", "Doe");

            console.log(person.getFullName());

        . A criação de classe com construtor obedece duas regras:

            . O nome da função deve começar com letra maiuscula, embora essa seja mais uma convenção porque nos testes
                o nome com letra minuscula também funcionou perfeitamente.

            . A criação do objeto deve sempre ser feito através do operador "new"

    . Object.Create

        var personActions = {
            getFullName() {
                return this.firstName + ' ' + this.lastName;
            },
        };

        function createPerson(firstName, lastName) {
            let person = Object.create(personActions);  // Cria um objeto com o objeto "Object", envia o objeto "personActions" no construtor.
            person.firstName = firstName;               // O retorno será um objeto com o "personActions" na estrutura.
            person.lastName = lastName;                 
            return person;                              // Incrementa as propriedades no objeto criado, formando um único.
        }

        let person1 = createPerson('John', 'Doe');
        let person2 = createPerson('Jane', 'Doe');

        console.log(person1.getFullName());
        console.log(person2.getFullName());

    . Initializer shorthand

        Exemplo 1:

            let name = 'Computer',
                status = 'On';

            let machine = {
                name,
                status
            };

            console.log(machine);   // {name: 'Computer', status: 'On'}

        Exemplo 2

            function createMachine(name, status) {
                return {
                    name,
                    status
                };
            }

            let machine1 = createMachine('Computer', 'On');

            console.log(machine);   // {name: 'Computer', status: 'On'}

    . This

        .  É uma palavra-chave que se refere ao objeto atual que está sendo executado. Em outras palavras, é o contexto 
            em que uma função é chamada.

        .  Referência ao objeto corrente:

            . Exemplo 1:

                let counter = {
                    count: 0,
                    next: function () {
                        return ++this.count;        // Aqui
                    },
                };

                counter.next();

            . Exemplo 2:

                function Pessoa(nome) {
                    this.nome = nome;
                }

                const joao = new Pessoa('João');

                console.log(joao.nome); // João

        . Contexto global - Fora de um objeto, this referencia a "window"

            this.color= 'Red';
            console.log(window.color); // 'Red'

        . Diferenças do uso do this em function e object:

            . Function - O uso do "this" é obrigatório quando criamos funções/métodos dentro de funções:

                function Person(firstName = "Marco", lastName = "Silva") {
                    this.firstName = firstName;
                    this.lastName = lastName;

                    // Aqui
                    this.getFullName = function () {
                        return this.firstName + " " + this.lastName;
                    };

                    // Aqui
                    this.showFullName = function () {
                        console.log(this.getFullName());
                    };
                }

                const p = new Person("Jose", "Maria");

                p.showFullName();

            . Object - O uso não é necessário:

                const pessoa = {
                    nome: 'João',

                    falar: function () {       //                      Function
                        console.log(this.nome); // João
                    }
                };

                pessoa.falar(); 

        . Atenção - Em função de seta (arrow function), this não é redefinido e não herda o contexto do objeto e sim do pai

            . Exemplos de como não usar o "this":

                . Exemplo 1:

                    const pessoa = {
                        nome: 'João',
                        falar: () => {              //                      Arrow function
                            console.log(this.nome); // undefined
                        },

                        falar2: function () {       //                      Function
                            console.log(this.nome); // João
                        }
                    };

                    pessoa.falar(); // undefined

                    pessoa.falar2();    // João

                . Exemplo 2:

                    ...
                    <input type="text" name="username" id="username" placeholder="Enter a username">
                    <div id="greeting"></div>
                    ...

                    <script>
                        const greeting = document.querySelector('#greeting');
                        const username = document.querySelector('#username');

                        username.addEventListener('keyup', () => {
                            greeting.textContent = 'Hello ' + this.value;       // Ao invés de usar o this, use "greeting.textContent = `Hello, ${userName.value}`;"
                        });                             //      |
                                                        //      +------> O resultado aqui é um "undefined", porque o this representa a variável global "window"
                    </script>                   

8 . Prototype
-------------

    . Em JavaScript, prototype é uma propriedade de funções e objetos.

    . Em JavaScript, todas as funções são objetos. E cada função tem uma propriedade prototype que é um objeto. 
        Esse objeto contém propriedades e métodos que são compartilhados por todas as instâncias da função.

    . Quando você cria uma instância de uma função usando a palavra-chave new, a instância recebe todas as 
        propriedades e métodos do objeto prototype da função. Isso significa que você pode acessar essas 
        propriedades e métodos diretamente na instância.

        Por exemplo:

            function Pessoa(nome) {
                this.nome = nome;
            }

            Pessoa.prototype.falar = function() {
                console.log('Olá, meu nome é ' + this.nome);
            }

            const joao = new Pessoa('João');

            joao.falar(); // Olá, meu nome é João

    . Se quisermos fazer um "override" do método/função "falar" na classe concreta, a chamada desse método será da classe concreta:

            function Pessoa(nome) {
                this.nome = nome;

                this.falar = function(){
                    console.log("Meu nome é " + this.nome );
                }
            }

            Pessoa.prototype.falar = function() {
                console.log('Olá, meu nome é ' + this.nome);
            }

            const joao = new Pessoa('João');

            joao.falar(); // Meu nome é João

9. Classes
----------

    . Existem várias maneiras de declarar uma classe em JavaScript. Aqui estão algumas delas:

        . Declarando uma classe com a palavra-chave class

            class Pessoa {
                constructor(nome, idade) {
                    this.nome = nome;
                    this.idade = idade;
                }

                falar() {
                    console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
                }
            }
        
            const pessoa = new Pessoa("Marco", 57 );

            pessoa.falar();

        . Declarando uma classe com a função function

            function Pessoa(nome, idade) {
                this.nome = nome;
                this.idade = idade;
            }

            // Se criar um método dentro da classe com o "falar" e chamá-lo, a execução será sempre do método "prototype"
            Pessoa.prototype.falar = function() {
                console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
            };

            const pessoa = new Pessoa("Marco", 57 );

            pessoa.falar();


        . Declarando uma classe com a sintaxe de objeto

            const Pessoa = {
                constructor: function(nome, idade) {
                    this.nome = nome;
                    this.idade = idade;
                },
                falar: function() {
                    console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
                }
            };

            Pessoa.falar();         // Neste caso não é preciso criar o objeto, já pode usá-lo


        .  Declarando uma classe com a sintaxe de classe de ES6

            class Pessoa {
                constructor(nome, idade) {
                    this.nome = nome;
                    this.idade = idade;
                }

                falar() {
                    console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
                }

                static criarPessoa(nome, idade) {
                    return new Pessoa(nome, idade);
                }
            }

            const pessoa = Pessoa.criarPessoa('Marco', 57 );

            pessoa.falar();

        . Declarando uma classe com a sintaxe de classe de ES6 com herança

            class Pessoa {
                constructor(nome, idade) {
                    this.nome = nome;
                    this.idade = idade;
                }

                falar() {
                    console.log(`Olá, meu nome é ${this.nome} e tenho ${this.idade} anos.`);
                }
            }

            class Aluno extends Pessoa {
                constructor(nome, idade, matricula) {
                    super(nome, idade);
                    this.matricula = matricula;
                }

                estudar() {
                    console.log(`Estou estudando...`);
                }
            }

            const pessoa = new Pessoa('Marco', 57);

            pessoa.falar();

            const aluno = new Aluno('Marco', 57, '123456');

            aluno.estudar();
            aluno.falar();

        . Declarando uma classe como expressão:

            let Person = class {
                constructor(name) {
                    this.name = name;
                }
                getName() {
                    return this.name;
                }
            }

            const marco = new Person('Marco');
            console.log(marco.name);

    . Getter and Setters

        class Person {
            constructor(name) {
                this._name = name;
            }
            get name() {
                return this._name;
            }
            set name(newName) {
                if (typeof newName !== 'string') {
                    throw 'The name must be a string';
                }

                newName = newName.trim();
                if (newName === '') {
                    throw 'The name cannot be empty';
                }
                this._name = newName;
            }
        }

        const marco = new Person('Marco');

        console.log(marco.name);

        marco.name = 'Antonio';

        console.log(marco.name);

    . Propriedades privadas - Utiliza-se o caracter "#" para identificar que a propriedade é privada

        class Pessoa {
            #nome;
            #idade;

            constructor(nome, idade) {
                this.#nome = nome;
                this.#idade = idade;
            }

            get nome() {
                return this.#nome;
            }
        }

        class Funcionario extends Pessoa {
            constructor(nome, idade, cargo) {
                super(nome, idade);
                this.cargo = cargo;
            }
        }

        const marco = new Funcionario('Marco', 57, 'Programador');

        console.log(marco.nome);

        // Esta linha levantará uma exception. Propriedades com identificação de "#" não podem ser
        // acessadas diretamente. É preciso que se construa um método dentro da classe pai para acessá-la
        console.log(marco.#nome);

    . Métodos Privados - O funcionamento de métodos privados segue a mesma lógica das propriedades privadas

        class Pessoa {
            #nome;
            #idade;

            constructor(nome, idade) {
                this.#nome = nome;
                this.#idade = idade;
            }

            #getNomePrivado() {
                return this.#nome;
            }
        }

        class Funcionario extends Pessoa {
            constructor(nome, idade, cargo) {
                super(nome, idade);
                this.cargo = cargo;
            }

            getNome() {
                return this.#getNomePrivado(); // Erro: SyntaxError: Private method '#getNomePrivado' must be declared in an enclosing class
            }
        }


    . new.target    - É uma propriedade que retorna o construtor que foi chamado com o operador new. 
                        Ela é usada para determinar se uma função foi chamada como um construtor ou como uma função regular.

                        Quando uma função é chamada com o operador new, o valor de new.target é o próprio construtor

        function Pessoa(nome) {
            if (new.target === Pessoa) {
                this.nome = nome;
            } else {
                throw new Error('Pessoa deve ser chamada com o operador new');
            }
        }

        // Neste caso o construtor não levantará uma exception
        const pessoa = new Pessoa('Marco');
        //              ^
        //              |
        //              +-------------- Se retirar o operador "new" da expressão "const pessoa = Pessoa('Marco');" a execução 
        //                              desse código levantará uma exceção
        //
        //                              Para que o "new.target" retorne o nome do construtor é necessário o uso de "new"


        // Aqui será levantado uma exception
        Pessoa('Marco');

        console.log( pessoa.nome );

    . Métodos Estáticos

        class Person {
            constructor(name) {
                this.name = name;
            }
            getName() {
                return this.name;
            }
            static createAnonymous() {
                return "createAnonymous";
            }
        }


        console.log(Person.createAnonymous());

    . Propriedades Estáticas

        class Item {
            constructor(name, quantity) {
                this.name = name;
                this.quantity = quantity;
                this.constructor.count++;
            }
            static count = 0;
            static getCount() {
                return Item.count;
            }
        }


        const parafuso = new Item('Parafuso', 10);

        console.log(Item.getCount());   // 1


        const tijolo = new Item('Tijolo', 5);

        console.log(Item.getCount());   // 2

    . instanceof - É utilizado para conferir se um objeto é derivado de uma determinada classe:

        function Person(name) {
            this.name = name;
        }

        let p1 = new Person('John');

        console.log(p1 instanceof Person); // true    

10. Promisses
-------------

    . Promises são um recurso do JavaScript que permitem lidar com operações assíncronas de forma mais elegante e 
        fácil de gerenciar. Uma promise é um objeto que representa um valor que pode estar disponível agora, no 
        futuro ou nunca.

    . De forma semelhante, uma promise em JavaScript é como um "pedido" que você faz a um código que pode levar algum 
        tempo para ser executado. Em vez de bloquear a execução do código até que o resultado esteja disponível, você 
        pode continuar executando outras tarefas e, quando o resultado estiver pronto, você pode lidar com ele.

    . Aqui estão os principais conceitos relacionados a promises:

        Pending: O estado inicial da promise, quando o resultado ainda não está disponível.

        Fulfilled: O estado em que a promise foi resolvida com sucesso e o resultado está disponível.

        Rejected: O estado em que a promise foi rejeitada e um erro ocorreu.

        Resolved: O estado em que a promise foi resolvida, seja com sucesso ou com erro.  

    . Para consumir uma promise temos três métodos:

        . then      O método then é usado para lidar com o resultado de uma promise quando ela é resolvida com sucesso. 
                    Ele recebe uma função de callback que é executada quando a promise é resolvida. 

            const promise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve("Olá, mundo!");
                }, 2000);
            });

            promise.then((resultado) => {
                console.log(resultado); // imprime "Olá, mundo!" após 2 segundos
            });

        . catch     O método catch é usado para lidar com o resultado de uma promise quando ela é rejeitada com um erro. 
                    Ele recebe uma função de callback que é executada quando a promise é rejeitada.

            const promise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject("Erro ocorreu!");
                }, 2000);
            });

            promise.catch((erro) => {
                console.log(erro); // imprime "Erro ocorreu!" após 2 segundos
            });

        . finally   O método finally é usado para executar uma ação independente do resultado da promise. 
                    Ele recebe uma função de callback que é executada quando a promise é resolvida ou rejeitada.

            const promise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve("Olá, mundo!");
                }, 2000);
            });

            promise.finally(() => {
                console.log("Promise finalizada!"); // imprime "Promise finalizada!" após 2 segundos
            });

    . Exemplo do funcionamento 

        // Declaração da função que retornará uma Promise
        function getUsers() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                resolve([   // -------------------------------------------+
                    { username: 'john', email: 'john@test.com' }, //      |
                    { username: 'jane', email: 'jane@test.com' }, //      |
                ]);                                               //      |
                }, 1000);                                         //      |
        });                                                       //      |
        }   //                                            +---------------+
            //                                            |
            //                                            V
        // Função que será executada caso houver um "resolve" no cenário
        function onFulfilled(users) {
            console.log(users);
        }

        const promise = getUsers();
        promise.then(onFulfilled);  // Aqui é feito o disparo da ação assincronica que retorna um "resolve" e 
                                    // automaticamente executará a função onFullfilled

    . No exemplo abaixo, a função de callback do then é executada quando a promise é resolvida, e a função de 
        callback do finally é executada independente do resultado da promise.

        const promise = new Promise((resolve, reject) => {
            setTimeout(() => {
                reject("Olá, mundo!");
                // resolve("Olá, mundo!");
            }, 2000);
        });

        promise
            .then((result) => {
                console.log(result);
        })
        .catch((error) => {
            console.log(error);
        })
        .finally(() => {
            console.log("Promise finalizada!");
        });

    . async/await

        . Sempre que uma função for precedida da palavra "async" o retorno será uma promise:

            async function f() {
                return 1;           // Seria a mesma coisa que "return Promise.resolve(1);"
            }        

            f().then(console.log); // 1

        . Sempre que for usado a palavra "await" na chamada de uma função, o javascript aguardará o 
            retorno dela para ir a próxima linha


            async function f() {

                let promise = new Promise((resolve, reject) => {
                    setTimeout(() => resolve("done!"), 10000)
                });
            
                let result = await promise; // wait until the promise resolves (*)
            
                console.log(result);
                
            }
            
            f();        

11. ES6 Modules
---------------

    . Módulos em ECMAScript 6, é uma forma de organizar e estruturar o código JavaScript em pequenas unidades reutilizáveis, 
        chamadas de módulos. Esses módulos podem ser carregados e usados em outros arquivos JavaScript, permitindo que 
        você crie aplicações mais complexas e escaláveis.

    . Características dos módulos ES6:

        . Declarativos: Os módulos ES6 são declarativos, o que significa que você define o que o módulo exporta e importa, 
                        em vez de ter que escrever código para carregar e vincular os módulos.

        . Independentes: Os módulos ES6 são independentes, o que significa que eles não compartilham variáveis ou funções 
                        com outros módulos, a menos que sejam explicitamente exportadas ou importadas.

        . Reutilizáveis: Os módulos ES6 são reutilizáveis, o que significa que você pode usar o mesmo módulo em diferentes partes 
                         da sua aplicação.

        . Caching:      Os módulos ES6 são cacheados, o que significa que o navegador ou ambiente de execução pode armazenar em 
                        cache os módulos carregados e reutilizá-los em vez de carregá-los novamente.        

    . Exportando funções:

        . Crie uma pasta na raiz do projeto com o nome "js".

        . Dentro da pasta "js" crie o arquivo fornecedora das funções, com o nome de "site.js", utilize uma das duas formas:

            . Utilizando "export" como atributo da função

                export function display(message) {
                    const el = document.createElement('div');
                    el.innerText = message;
                    document.body.appendChild(el);
                }

                export function showMessage(message) {
                    alert(message);
                }

            . Utilizando o "export" como linha de comando:

                function display(message) {
                    const el = document.createElement('div');
                    el.innerText = message;
                    document.body.appendChild(el);
                }

                function showMessage(message) {
                    alert(message);
                }

                export { display, showMessage };

        . Na pasta "js" crie outro o arquivo, "index.js", que consumirá as funções do arquivo "site.js":

            import { display, showMessage } from './site.js';

            display('Hello World');
            showMessage('Hello, World!');

        . Crie a página "index.html" abaixo:

            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Document</title>
            </head>
            <body>

            <!-- IMPORTANTE: Observe o "type=module", na declaração do script que                -->
            <!--             consumirá as funções é obrigatório a identificação do "type=module" -->
            <script src="js/index.js" type="module"></script>  
            </body>
            </html>

        . Execute a página "index.html" e veja se os resultado foram exibidos com sucesso.

    . Exportando variáveis:

        . Inclua as linhas do arquivo "site.js" a linha abaixo:

            // Linha inserida
            let count = 0;

            ...

            function showMessage(message) {
                alert(message);
            }

            // Linha alterada, inserido o export da variável "count"
            export { display, showMessage, count };

        . Inclua na última linha do arquivo "index.js" a linha abaixo:

            // Linha alterada, inserido o import da variável "count"
            import { display, showMessage, count } from './site.js';

            ...
            // linha inserida
            console.log(count);


        . Execute a página "index.html" e veja se o resultado da variável "count" foi exibido com sucesso.

    . Outra forma de fazer import de funções:

        . Acesse o arquivo "index.js" e faça as alterações abaixo:

            // Retire a função display do import
            import { showMessage, count } from './site.js';

            // Insira a linha abaixo
            let site = await import('./site.js');

            // Alere a linha abaixo, no lugar de "display(...)", altere pelo "site.display(...)"
            site.display('Hello, World!');

            showMessage('Hello, World!');

            console.log(count);

        . Execute o arquivo "index.html" e verifique se a função "display" executou com sucesso.

    . Outra forma de fazer export de funções "export default":

        . Quando você usa export default para exportar uma função, você está criando um export padrão. 
            Isso significa que a função é exportada sem um nome específico e pode ser importada por outros 
            módulos sem precisar especificar o nome.

        . Exemplo:

            . Crie o arquivo "user.mjs" com o conteúdo abaixo:

                let users;

                // O export default abaixo, exporta uma promise que quando resolvida, faz com que o valor da variavel "users" seja alterado.
                // Isso é possível pois a variavel "users" é inicializada com o valor "undefined" e a promise   resolvida ap s o fetch.
                // Isso é importante pois quem importa o módulo "user.mjs" pode usar o valor de "users" mesmo antes dele ser realmente carregado.
                // O "export default" faz com que ao ser importado pode ser dado qq nome a função para ser usado.
                export default (async () => {
                    const url = 'https://jsonplaceholder.typicode.com/users';
                    const response = await fetch(url);
                    users = await response.json();
                })();

                export { users };            

            . Crie o arquivo "app.mjs" com o conteúdo abaixo:

                // O nome dado para a função anônima do arquivo "user.mjs" foi "promise". Poderia ser qq nome "mmm", ou "getUsers", ...
                import promise, { users } from './user.mjs';

                function render(users) {
                    if (!users) {
                        throw 'The user list is not available.';
                    }
                    let list = users
                        .map((user) => {
                            return `<li> ${user.name}(<a href="email:${user.email}">${user.email}</a>)</li>`;
                        })
                        .join(' ');

                    return `<ol>${list}</ol>`;
                }

                // Aqui, se o retorno foi um "resolve", ou se a execução foi bem sucedida, então 
                // é executado o método "then"
                promise.then(() => {
                    let container = document.querySelector('.container');
                    try {
                        container.innerHTML = render(users);
                    } catch (error) {
                        container.innerHTML = error;
                    }
                });

            . Crie a página "index.html" com o conteúdo abaixo:

                <!DOCTYPE html>
                <html lang="en">

                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>JavaScript Top-Level Await Demo</title>
                </head>

                <body>
                    <div class="container"></div>
                    <script type="module" src="app.mjs"></script>
                </body>

                </html>

            . Execute a página e veja o resultado.

12. Try..Catch
--------------

        try {
            // Código que pode gerar uma exceção
            int x = 5 / 0;
        } catch (ArithmeticException e) {
            // Lide com a exceção
            System.out.println("Erro: " + e.getMessage());
        } finally {
            // Libere recursos
            System.out.println("Liberando recursos...");
        }

    . Levantando exceção:

        function divide(a, b) {
            if (b === 0) {
                throw new Error("Erro: divisão por zero");
        }
            return a / b;
        }

        try {
            const resultado = divide(10, 0);
            console.log(resultado);
        } catch (error) {
            console.error(error.message);
        }

    . Usando try...catch sem identificar a exceção:

        const isValidJSON = (str) => {
            try {
                JSON.parse(str);
                return true;
            } catch {
                return false;
            }
        };

        let valid = isValidJSON(`{"language":"JavaScript"}`);
        console.log(valid);


    . Existem várias exceções que podem ser utilizadas para lidar com erros e exceções em um programa. 
        Aqui estão algumas das principais exceções utilizadas no JavaScript:

        Error:          É a exceção mais genérica e é utilizada para representar um erro genérico.
        TypeError:      É utilizada para representar um erro de tipo, como quando se tenta executar uma 
                        operação em um valor que não é do tipo correto.
        RangeError:     É utilizada para representar um erro de intervalo, como quando se tenta acessar um 
                        índice de um array que está fora do intervalo válido.
        ReferenceError: É utilizada para representar um erro de referência, como quando se tenta acessar 
                        uma variável que não foi declarada.
        SyntaxError:    É utilizada para representar um erro de sintaxe, como quando se tenta executar um 
                        código que contém erros de sintaxe.
        URIError:       É utilizada para representar um erro de URI, como quando se tenta criar um objeto 
                        URI com um valor inválido.
        EvalError:      É utilizada para representar um erro de avaliação, como quando se tenta executar 
                        um código que contém erros de avaliação.
        InternalError:  É utilizada para representar um erro interno, como quando o motor do JavaScript 
                        encontra um erro interno.
        AggregateError: É utilizada para representar um erro agregado, como quando se tenta executar uma 
                        operação que envolve vários erros.

    . Além disso, também existem algumas exceções específicas para certas APIs e bibliotecas, como:

        DOMException:           É utilizada para representar um erro de DOM, como quando se tenta acessar um 
                                elemento do DOM que não existe.
        WebGLRenderingContext:  É utilizada para representar um erro de WebGL, como quando se tenta executar 
                                uma operação que não é suportada pelo contexto WebGL.


Browser: Document, Eventos e Interfaces
---------------------------------------

13. Document
------------

    . Ambiente e especificação do navegador - Abaixo a estrutura do que o javascript enxerga quando é executado no navegador:


                                                          Window
                                                          ------
                                                            | 
         +----------------------------------------------------------------------------------+           
         |                                                  |                               |
         v                                                  v                               v
        DOM (Document Object Model)             BOM (Browser Object Model)              Javascript
        ---------------------------             --------------------------              ----------
        document                                navigator                               Object
        ...                                     screen                                  Array
                                                location                                Function
                                                frames                                  ...
                                                history
                                                XMLHttpRequest


        . Por exemplo:

            <!DOCTYPE html>
            <html lang="en">

            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>JavaScript Top-Level Await Demo</title>
            </head>

            <body>
                <div class="container"></div>
                <script>
                    function sayHi() {
                        alert("Hello");
                    }

                    // global functions are methods of the global object:
                    window.sayHi();
                    alert(window.innerHeight); 

                </script>
            </body>

            </html>

    . Comandos para apresentar valores dos objetos na console:

        . console.log(): Exibe uma mensagem no console.

        . console.debug(): Exibe uma mensagem de depuração no console.

        . console.info(): Exibe uma mensagem de informação no console.

        . console.warn(): Exibe um aviso no console.

        . console.error(): Exibe um erro no console.

        . console.dir(): Exibe informações detalhadas sobre um objeto no console.

        . console.table(): Exibe um objeto como uma tabela no console.

        . console.time() e console.timeEnd(): Usados para medir o tempo de execução de um trecho de código.

        . console.count(): Exibe uma contagem de quantas vezes o método console.count() foi chamado com o mesmo nome.

        . console.group() e console.groupEnd(): Usados para agrupar mensagens relacionadas no console.

        . console.clear(): Limpa o console.

    . BOM - Usado para interagir com o navegador e realizar ações relacionadas ao navegador

    . DOM - Usado para manipular e interagir com os elementos HTML em uma página web.

        . Em DOM, qualquer nô da arvore do HTML abaixo é considerado um objeto.

            <!DOCTYPE HTML>
            <html>
                <head>
                    <title>About elk</title>
                </head>

                <body>
                    <h1>The truth about elk.</h1>
                </body>
            </html>

        . Equivalência dos nôs do DOM vs Tags HTML:

            <html> = document.documentElement 
            <body> = document.body
            <head> = document.head

        . Acesse a página via navegador, acione o devTools e na console execute os comandos abaixo:

            console.log( document.documentElement )

            console.log( document.body )

            console.log( document.head )

    . childNodes, firstChild, lastChild

        . childNodes - propriedade que retorna uma coleção de nodos filhos de um elemento.

            . Execute o comando abaixo no console do navegador:

                console.log( document.body.childNodes )                 // Apresentará todos os nôs dentro do body
                console.log(document.body.childNodes[1].textContent)    // Apresenta o conteúdo da tag <h1>
                
            . firstChild - Apresenta o primeiro Nô da tag

            . lastChild - Apresenta o último.

            . Execute os comandos abaixo no console do navegador:

                console.log(document.body.firstNode );
                console.log(documento.body.lastNode );

        . Iterando os nôs dos filhos:

            // for..of é a maneira mais indicada para iterar os nôs, 
            // evite usar for..in, ele itera todos os itens da coleção além dos filhos

            for (let node of document.body.childNodes) {
                alert(node.textContent); // shows all nodes from the collection
            }

        . Inclua as linhas abaixo no arquivo HTML:

            <!DOCTYPE HTML>
            <html>
                <head>
                    <title>About elk</title>
                </head>

                <body>
                    <h1>The truth about elk.</h1>

                    <!-- Script incluido -->
                    <script>
                        for (let node of document.body.childNodes) {
                            alert(node.textContent); // shows all nodes from the collection
                        }
                    </script>
                </body>
            </html>

    . children  - É uma propriedade que retorna uma coleção de elementos filhos de um elemento. Essa coleção é 
                    uma lista de elementos que são filhos diretos do elemento atual.

        . A propriedade "children" é semelhante à propriedade childNodes, mas com uma diferença importante: 
            children só inclui elementos, enquanto "childNodes" inclui todos os tipos de nodos, incluindo texto, 
            comentários e outros.

        . Exemplo:

            <html>
                <body>
                    <div>Begin</div>

                    <ul>
                        <li>Information</li>
                    </ul>

                    <div>End</div>

                    <script>
                        for (let elem of document.body.children) {
                            alert(elem); // DIV, UL, DIV, SCRIPT
                        }
                    </script>
                </body>
            </html>

    . tables    - O DOM fornece propriedades adicionais a alguns tipos de tags HTML, como por exemplo <table>

        <html>
            <body>
                <table id="myTable" border="1">
                    <th>Id</th>
                    <th>Name</th>
                    <th>Email</th>

                    <tr>
                        <td>1</td>
                        <td>Marco</td>
                        <td>marco.gmail.com</td>
                    </tr>

                    <tr>
                        <td>2</td>
                        <td>Lucas</td>
                        <td>lucas.gmail.com</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>Lucas</td>
                        <td>lucas.gmail.com</td>
                    </tr>
                </table>

                <script>
                    
                    // Para acessar as propriedades da tag "table" basta referenciar ao "id" da tag html
                    //
                    //          +---> <table id="myTable" border="1">
                    //          |
                    let td = myTable.rows[0].cells[1];

                    td.style.backgroundColor = "red";         
                </script>
            </body>
        </html>

    . getElement*, querySelector*

        . document.querySelectorAll - O método querySelectorAll é uma função do JavaScript que retorna uma coleção 
                                        de elementos HTML que correspondem a um seletor que pode ser:

            . Seletor de classe:    .nome-da-classe - seleciona todos os elementos que têm a 
                                    classe nome-da-classe.

                document.querySelectorAll('.nome-da-classe')

            . Seletor de ID:        #id-do-elemento - seleciona o elemento que tem o ID id-do-elemento.

                document.querySelectorAll('#id-do-elemento')

            . Seletor de tag:       nome-da-tag - seleciona todos os elementos que têm a tag nome-da-tag.

                document.querySelectorAll('table')

            . Seletor de pseudoclasse: :pseudo-classe - seleciona todos os elementos que correspondam à 
                                        pseudoclasse pseudo-classe.

                document.querySelectorAll('td:first-child') // Retorna todas as primeiras TDs de todas as TRs da tag <table> 
                document.querySelectorAll('td:last-child')  // Retorna todos os últimos TDs de todas as TRs da tag <table> 
                
                document.querySelectorAll('td:first-child')[0].textContent  // Retorna o conteúdo da primeira TD devido ao indice 0 

            . Seletor de atributo:  [nome-do-atributo] - seleciona todos os elementos que têm o atributo nome-do-atributo.
            
                <!-- Exemplo de uso do método querySelectorAll em uma página HTML -->

                <!-- HTML -->
                <div id="container">
                    <p data-id="1">Parágrafo 1</p>
                    <p data-id="2">Parágrafo 2</p>
                    <p>Parágrafo 3</p>
                    <p data-id="4">Parágrafo 4</p>
                </div>

                <!-- JavaScript -->
                <script>
                    // Seleciona todos os elementos com o atributo "data-id"
                    const elementos = document.querySelectorAll('[data-id]');

                    // Exibe a lista de elementos selecionados
                    console.log(elementos);

                    // Altera o estilo dos elementos selecionados
                    elementos.forEach((elemento) => {
                        elemento.style.color = 'blue';
                    });
                </script>

            . Seletor de combinação: seletor1, seletor2 - seleciona todos os elementos que correspondam a 
                                        qualquer um dos seletores seletor1 ou seletor2.

                <!-- Exemplo de uso do método querySelectorAll com combinação de seletores em uma página HTML -->

                <!-- HTML -->
                <div id="container">
                    <h2>Título</h2>
                    <ul>
                        <li>Item 1</li>
                        <li>Item 2</li>
                        <li>Item 3</li>
                    </ul>
                    <p>Parágrafo</p>
                    <div class="destaque">
                        <h3>Destaque</h3>
                        <p>Este é um destaque</p>
                    </div>
                </div>

                <!-- JavaScript -->
                <script>
                    // Seleciona todos os elementos que são filhos diretos do elemento com id "container"
                    // e que são elementos h2 ou ul
                    const elementos = document.querySelectorAll('#container>h2, #container>ul');

                    // Exibe a lista de elementos selecionados
                    console.log(elementos);

                    // Altera o estilo dos elementos selecionados
                    elementos.forEach((elemento) => {
                        elemento.style.color = 'red';
                    });
                </script>

            . Seletor de descendente: seletor1 seletor2 - seleciona todos os elementos que correspondam ao 
                                        seletor seletor2 e que sejam descendentes do elemento que corresponde ao 
                                        seletor seletor1.

                <!-- Exemplo de uso do método querySelectorAll com seletores descendentes em uma página HTML -->

                <!-- HTML -->
                <div id="container">
                    <h2>Título</h2>
                    <ul>
                        <li>Item 1</li>
                        <li>Item 2</li>
                        <li>Item 3</li>
                    </ul>
                    <div class="destaque">
                        <h3>Destaque</h3>
                        <p>Este é um destaque</p>
                        <ul>
                        <li>Item 4</li>
                        <li>Item 5</li>
                        </ul>
                    </div>
                </div>

                <!-- JavaScript -->
                <script>
                    // Seleciona todos os elementos ul que são descendentes do elemento com id "container"
                    const elementos = document.querySelectorAll('#container ul');

                    // Exibe a lista de elementos selecionados
                    console.log(elementos);

                    // Altera o estilo dos elementos selecionados
                    elementos.forEach((elemento) => {
                        elemento.style.backgroundColor = 'lightblue';
                    });
                </script>

            . Seletor de filho: seletor1 > seletor2 - seleciona todos os elementos que correspondam 
                                ao seletor seletor2 e que sejam filhos diretos do elemento que corresponde ao seletor seletor1.


                <!-- Exemplo de uso do método querySelectorAll com seletores de filho em uma página HTML -->

                <!-- HTML -->
                <div id="container">
                    <h2>Título</h2>
                    <ul>
                        <li>Item 1</li>
                        <li>Item 2</li>
                        <li>Item 3</li>
                    </ul>
                    <div class="destaque">
                        <h3>Destaque</h3>
                        <p>Este é um destaque</p>
                        <ul>
                        <li>Item 4</li>
                        <li>Item 5</li>
                        </ul>
                    </div>
                </div>

                <!-- JavaScript -->
                <script>
                    // Seleciona todos os elementos li que são filhos diretos do primeiro elemento ul
                    const elementos = document.querySelectorAll('#container > ul > li');

                    // Exibe a lista de elementos selecionados
                    console.log(elementos);

                    // Altera o estilo dos elementos selecionados
                    elementos.forEach((elemento) => {
                        elemento.style.backgroundColor = 'lightblue';
                    });
                </script>

        . document.querySelector    - é uma função do DOM (Document Object Model) que permite selecionar um elemento HTML 
                                        baseado em uma expressão de seleção CSS. Ele retorna o primeiro elemento que corresponde 
                                        à expressão de seleção especificada, ou null se não for encontrado nenhum elemento.

                                        O querySelector retorna apenas o primeiro elemento que corresponde à expressão de seleção. 
                                        Se precisar selecionar todos os elementos que correspondem à expressão, use o método 
                                        querySelectorAll em vez disso.

            . Exemplo:

                <!DOCTYPE html>
                <html>
                    <head>
                        <title>Exemplo querySelector</title>
                    </head>

                    <body>
                        <h1 id="titulo1" class="titulo">Título 1 da página</h1>
                        <h1 id="titulo2" class="titulo">Título 2 da página</h1>

                        <p class="paragrafo">Este é um parágrafo.</p>
                        <button class="botao">Clique aqui</button>

                        <script>
                            const titulo = document.querySelector('.titulo');
                            console.log(titulo.textContent); // Saída: "Título 1 da página"
                        </script>
                    </body>
                </html>

        . document.getElementById   - O método document.getElementById é uma função do JavaScript que retorna um 
                                        elemento HTML com o ID especificado. Se o elemento não for encontrado, o 
                                        método retorna null.

            . Exemplo:

                <!DOCTYPE html>
                <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>Document</title>
                    </head>

                    <body>
                        <h1 id="titulo1" class="titulo">Título 1 da página</h1>
                        <h1 id="titulo2" class="titulo">Título 2 da página</h1>

                        <p class="paragrafo">Este é um parágrafo.</p>
                        <button class="botao">Clique aqui</button>

                        <script>
                            const titulo = document.getElementById('titulo2');
                            console.log(titulo.textContent); // Saída: "Título da página"
                        </script>
                    </body>

                </html>

        . document.getElementsByTagName - O método getElementsByTagName do DOM é um método que retorna uma coleção de 
                                        elementos que correspondem ao nome de tag especificado.

                                        Em outras palavras, ele permite que você selecione todos os elementos de uma página 
                                        HTML que têm um determinado nome de tag, como p, div, span, img, etc.

            Exemplo:

                <!DOCTYPE html>
                <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>Document</title>
                    </head>

                    <body>
                        <table id="table">
                            <tr>
                                <td>Your age:</td>

                                <td>
                                    <label>
                                        <input type="radio" name="age" value="young" checked> less than 18
                                    </label>
                                    <label>
                                        <input type="radio" name="age" value="mature"> from 18 to 50
                                    </label>
                                    <label>
                                        <input type="radio" name="age" value="senior"> more than 60
                                    </label>
                                </td>
                            </tr>
                        </table>

                        <script>
                            let inputs = table.getElementsByTagName('input');

                            for (let input of inputs) {
                                alert(input.value + ': ' + input.checked);
                            }
                        </script>
                    </body>
                </html>

        . document.getElementsByName - É um método que retorna uma coleção de elementos que correspondem ao atributo name 
                                        especificado.

                                        Ele permite que você selecione todos os elementos de uma página HTML que têm um 
                                        determinado valor no atributo name.

            Exemplo: 

                <!DOCTYPE html>
                <html>
                    <head>
                        <title>Exemplo de getElementsByName</title>
                    </head>
                    <body>
                        <form>
                            <input type="text" name="nome" value="Nome" placeholder="Digite seu nome">
                            <input type="email" name="email" placeholder="Digite seu e-mail">
                            <input type="text" name="nome" value="Sobrenome" placeholder="Digite sobrenome">
                        </form>

                        <script>
                            const elementosNome = document.getElementsByName('nome');
                            console.log(elementosNome); // retorna uma coleção de elementos com name="nome"

                            for( const elemento of elementosNome){
                                console.log( elemento );
                            }
                        </script>
                    </body>
                </html>

        . document.getElementsByClassName -  É um método que retorna uma coleção de elementos que correspondem ao nome da 
                                            classe especificado.

                                            Ele permite que você selecione todos os elementos de uma página HTML que têm 
                                            uma determinada classe.

            Exemplo:

                <!DOCTYPE html>
                <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>Document</title>
                    </head>

                    <body>
                        <form>
                            <input type="text" name="nome" value="Nome" class="form-control" placeholder="Digite seu nome">
                            <input type="email" name="email" class="form-control-sm" placeholder="Digite seu e-mail">
                            <input type="text" name="nome" class="form-control" value="Sobrenome" placeholder="Digite sobrenome">
                        </form>

                        <script>
                            const elementosNome = document.getElementsByClassName('form-control');
                            console.log(elementosNome); // retorna uma coleção de elementos com name="nome"

                            for( const elemento of elementosNome){
                                console.log( elemento );
                            }
                        </script>
                    </body>
                </html>

        . Comparação entre os métodos para nôs do DOM:

            Method	                Searches by...	        Can call on an element?	    run "forEach" in collection?
            ------                  --------------          -----------------------     ----------------------------

            querySelector	        CSS-selector	        ✔	                        ✔
            querySelectorAll	    CSS-selector	        ✔	                        ✔
            getElementById	        id	                    -	                        -
            getElementsByName	    name	                -	                        -
            getElementsByTagName	tag or '*'	            ✔	                        - 
            getElementsByClassName	class	                ✔	                        -

        . Importante: Cuidado, os métodos: getElementsByTagName, getElementsByName e getElementsByClassName retornam uma coleção, por isso seus nomes estão no plural.
                                                     -                     -                   -
                                                     |                     |                   |
                                                     +---------------------+-------------------+
                                                                           |
                                                                           V

                                                        Cuidado para não esquecer o "s", pois retornam 
                                                        uma coleção, diferente do "getElementById" que
                                                        retorna um único elemento.         

    . innerHTML - É uma propriedade de leitura e escrita que permite acessar ou modificar o conteúdo HTML interno de um elemento HTML.

        . Exemplo 1: Acessando o conteúdo HTML interno

            <!-- HTML -->
            <div id="meu-div">Olá, <span>mundo!</span></div>

            // Código Javascript
            const div = document.getElementById('meu-div');
            console.log(div.innerHTML); // Saída: "Olá, <span>mundo!</span>"

        . Exemplo 2: Modificando o conteúdo HTML interno

            <!-- HTML -->
            <div id="meu-div">Olá, mundo!</div>

            // Código Javascript
            const div = document.getElementById('meu-div');
            div.innerHTML = 'Olá, <strong>mundo!</strong>';
            console.log(div.innerHTML); // Saída: "Olá, <strong>mundo!</strong>"

    . outerHTML - É uma propriedade de leitura e escrita que permite acessar ou modificar todo o conteúdo HTML de um elemento, 
                    incluindo o próprio elemento.

                    . Retorna não somente o conteúdo interno, mas também o conteúdo do elemento da tag pai.

        . Exemplo:

            <!DOCTYPE html>
            <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Document</title>
                </head>

                <body>
                    <div id="container">
                        <input type="text" name="nome" id="nome">
                    </div>

                    <script>
                        let divContainer = document.getElementById('container');

                        console.log( divContainer.outerHTML );
                        console.log( divContainer.innerHTML );

                        divContainer.outerHTML = 'Hello, World!';

                        console.log( divContainer.outerHTML ); 
                        // Saída
                        //
                        // <div id="container"> <!-- Tag Responsável pelo conteúdo interno -->
                        //     <input type="text" name="nome" id="nome">
                        // </div>

                        console.log( divContainer.innerHTML );
                        // Saída
                        //
                        // <input type="text" name="nome" id="nome">

                    </script>
                </body>
            </html>

        . Assemelha-se muito com o "innerHTML", porém existem diferenças grandes:

            . Ao acessar a propriedade "outerHTML", retorna o conteúdo completo da tag.

            . Se utilizarmos o "outerHTML" para alterar o conteúdo da página, a página exibida é alterada, 
                mas o conteúdo dela não. Se consultarmos o conteúdo da página após o "outerHTML" veremos
                que não mudou, porém a exibição sim.

                Exemplo: 

                    <!DOCTYPE html>
                    <html lang="en">
                        <head>
                            <meta charset="UTF-8">
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                            <title>Document</title>
                        </head>

                        <body>
                            <div id="container">
                                <input type="text" name="nome" id="nome">
                            </div>

                            <script>
                                let divContainer = document.getElementById('container');

                                console.log( divContainer.outerHTML );
                                console.log( divContainer.innerHTML );

                                divContainer.outerHTML = 'Hello, World!';

                                console.log( divContainer.outerHTML );  // Continuará o input type text na página
                                console.log( divContainer.innerHTML );  // Idem
                            </script>
                        </body>
                    </html>

    . HTML Attributes -  são informações adicionais que podem ser adicionadas a uma tag HTML para fornecer mais contexto e significado ao 
                        elemento. Eles são escritos na forma de pares de nome-valor, separados por um sinal de igual (=), e são colocados 
                        dentro da tag de abertura do elemento.  

        Exemplo:

            <!DOCTYPE html>
            <html lang="en">

            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Document</title>
            </head>

            <body>

                <div id="elem" about="Elephant"></div>
                <!--  |           |                 -->
                <!--  |           V                 -->
                <!--  +-> HTML Attributes           -->

            </body>

            </html>

        . Podemos acessar esses attributes através das funções abaixo:

            . elem.hasAttribute(name) –         Verifica a existência do atributo.
            . elem.getAttribute(name) –         Obtêm o valor.
            . elem.setAttribute(name, value) –  Configura o valor, se o atributo existir ele atualiza; caso contrário cria o atributo.
            . elem.removeAttribute(name) –      removes the attribute.

        . Exemplo:

            <!DOCTYPE html>
            <html lang="en">

            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Document</title>
            </head>

            <body>
                <div id="elem" about="Elephant"></div>
                <input type="text" name="name" id="name" value="John">

                <script>
                    console.log(elem.getAttribute('About')); // (1) 'Elephant', reading

                    elem.setAttribute('Test', 123); // (2), writing

                    console.log(elem.outerHTML); // (3), <div id="elem" about="Elephant" test="123"></div>

                    for (let attr of elem.attributes) { // (4) list all
                        console.log(`${attr.name} = ${attr.value}`);
                    }

                    elem.setAttribute('Test', 456);

                    console.log( elem.outerHTML );   // <div id="elem" about="Elephant" test="456"></div>


                    let name = document.getElementById('name'); 

                    console.log(name.value);        // John

                    name.value = 'Jane';

                    console.log(name.value);        // Jane

                </script>
            </body>

            </html>




# Parei no "DOM properties are typed"
https://javascript.info/dom-attributes-and-properties