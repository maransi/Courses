Dominando Injeção de Dependência
--------------------------------

Aula 1. Ferramentas
-------------------

. Este curos é continuação do curso Fundamentos C#, OOP, SQL Server e Dapper.

. Utilizaremos:

    Umas das plataformas Windows. MAC, Ou Linux
    NET 5 ou superior
    Azure Data Studio
    SQL Server
    VS Code

. Instalação do Docker

	. Instalação

		. Instalação nas distribuições baseadas no Ubuntu:

			. A URL abaixo tem os passos atualizado para instalação do Docker:

				https://docs.docker.com/engine/install/ubuntu/

			. Instalação Atualizada

				sudo apt-get update
				sudo apt-get install \
					ca-certificates \
					curl \
					gnupg \
					lsb-release

				curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

				echo \
					"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
					$(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

				sudo apt-get update
				sudo apt-get install docker-ce docker-ce-cli containerd.io
				sudo docker --version

				sudo groupadd docker
				sudo gpasswd -a <usuario> docker
				sudo chown "$USER":"$USER" /var/run/docker.sock -R
				sudo service docker restart

				docker --version

		. Instalação no Mint

			sudo apt-get update
			cd Downloads/
			sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common
			curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
			sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(. /etc/os-release; echo "$UBUNTU_CODENAME") stable"
			sudo apt-get update
			sudo apt-get -y install docker-ce docker-compose
			sudo usermod -aG docker $USER
			docker --version

            sudo groupadd docker
            sudo gpasswd -a <usuario> docker
            sudo chown "$USER":"$USER" /var/run/docker.sock -R
            sudo service docker restart

            docker --version

. Instalando o .NET Core SDK

    . Instalçao Atualizada:

        . URL com informações para realizar a instalação.

            https://docs.microsoft.com/pt-br/dotnet/core/install/linux-ubuntu

            . IMPORTANTE: Acesse a instalação da distribuição e versão especifica do linux que estamos utilizando para 
                            proceder os comandos adequadamente.

                            A instalação abaixo está para o Ubuntu 20.04

        # Comando para o Ubuntu 22.04 em diante
        # wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.0g-2ubuntu4_amd64.deb
        # sudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb

        # Instalação do SDK
        wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
        sudo dpkg -i packages-microsoft-prod.deb

        sudo dpkg --purge packages-microsoft-prod && sudo dpkg -i packages-microsoft-prod.deb
        sudo apt-get update

        sudo apt-get install -y gpg
        wget -O - https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor -o microsoft.asc.gpg
        sudo mv microsoft.asc.gpg /etc/apt/trusted.gpg.d/
        wget https://packages.microsoft.com/config/ubuntu/20.04/prod.list
        sudo mv prod.list /etc/apt/sources.list.d/microsoft-prod.list
        sudo chown root:root /etc/apt/trusted.gpg.d/microsoft.asc.gpg
        sudo chown root:root /etc/apt/sources.list.d/microsoft-prod.list

        # Comando para o Ubuntu 22.04 em diante
        # wget http://archive.ubuntu.com/ubuntu/pool/main/o/openssl/libssl1.1_1.1.0g-2ubuntu4_amd64.deb
        # sudo dpkg -i libssl1.1_1.1.0g-2ubuntu4_amd64.deb

        sudo apt-get update; \
        sudo apt-get install -y apt-transport-https && \
        sudo apt-get update && \
        sudo apt-get install -y dotnet-sdk-5.0

        sudo apt-get install -y apt-transport-https && \
        sudo apt-get update && \
        sudo apt-get install -y aspnetcore-runtime-5.0

        sudo apt-get install -y dotnet-runtime-5.0


. Instalando o VS Code

    Instalação das extensões do VSCode

            C# 
            C# Extensions
            C# XML Documentation Comments
            vscode-icons (Opcional)
            Docker

        . Atalhos:

            Ctrl + K + D ou Shit + Alt + F:             Identa todo o seu código automaticamente;
            Ctrl + K + C:                               comenta um bloco de linhas;
            Ctrl + K + U:                               descomenta um bloco de linhas;
            Alt + Left Arrow:                           durante a programação, volta um método que você estava navegando;
            Alt + Right Arrow:                          durante a programação, avança um método que você estava navegando;
            Ctrl + .:                                   implementa o método/classe inexistente que você acabou de escrever;
            Ctrl + M + O:                               esconde todas as regions da classe atual;
            Ctrl + Shift + B:                           compila todos os projetos;
            F5:                                         manda depurar um projeto;
            Ctrl + F5:                                  manda executar um projeto;
            F10:                                        durante a depuração, avança uma linha;
            F11:                                        durante a depuração, avança uma linha entrando nos detalhes da mesma;


    Configurar Visual Studio Code para .NETCore

        . Acesse File / Preferences / Settings

        . Digite C#

        . Acesse "C# Configuration / CSharp Format Enabled" e habilite a configuração

        . Digite "Format on save" e habilite a configuração

        . Digite "Final" e habilite a configuração "Files: Insert final newline" e habilite a configuração

    
    Caso exiba a mensagem: "unable to generate assets to build and debug. omnisharp server is not running" siga os passos abaixo:

        . Acesse a opção "Arquivos/Preferência/Configurações"

        . Digite "OmniSharp" e faça a localização:

        . Encontre a opção "OmniSharp Auto Start" e desabilite.

        . Acesse as extensões, na barra lateral do VSCode, clique na extensão C# e faça um Downgrade da versão para 1.23.17

        . Apague do seu projeto a pasta ".vscode"

        . Digite Ctrl + Shift + P

        . Digite ".Net: Generate Assests for Build and Debug" para criar o "launch.json" e o "task.json"

        . Saia e entre no VSCode. Verifique na entrada se a instalação do OmniSharp ocorreu com sucesso.

        . Retorne a opção "OmniSharp Auto Start" e habilite.
   

. Instalando o SQL Server

    https://docs.microsoft.com/pt-br/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash
    https://docs.microsoft.com/pt-br/sql/linux/sql-server-linux-setup-tools?view=sql-server-ver15#ubuntu


    docker container run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=<password>"    -p 1433:1433 --name sqlserver --hostname sqlserver    -d mcr.microsoft.com/mssql/server:2019-latest
    docker container ps -a
    docker container exec -t sqlserver cat /var/opt/mssql/log/errorlog | grep connection

    # Testar no linux, não funcionou no windows
    docker container exec -it sqlserver /opt/mssql-tools/bin/sqlcmd -S localhost -U SA  -P "$(read -sp "Enter current SA password: "; echo "${REPLY}")"  -Q "ALTER LOGIN SA WITH PASSWORD=\"$(read -sp "Enter new SA password: "; echo "${REPLY}")\""

    # Execute os comandos abaixo ao entrar no container
    #
    # hostname -I
    # ip a
    docker exec -it sqlserver "bash"

    curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
    curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list
    sudo apt-get update 
    sudo apt-get install mssql-tools unixodbc-dev
    sudo apt-get update 
    sudo apt-get install mssql-tools
    echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bash_profile
    echo 'export PATH="$PATH:/opt/mssql-tools/bin"' >> ~/.bashrc
    source ~/.bashrc
    
    # Execute o comando abaixo e substitua o endereço IP do comando "sqlcmd" pelo adquirido no "hostname -I"
    #
    # hostname -I
    sqlcmd -S 192.168.0.82,1433 -U SA -P "<password>"


    # Execute os comandos abaixo dentro do sqlcmd
    EXEC sp_databases
    GO

    EXEC sp_helpdb    
    GO

    SELECT name FROM master..sysdatabases ORDER BY name
    GO

    EXEC sp_msForEachDB 'PRINT ''?'''
    GO

    EXIT


    . Sempre que for necessário levantar o banco do docker utilize o comando abaixo:

        docker start sqlserver

    . Para terminar a execução do banco, utilize

        docker stop sqlserver


. Instalando Azure Data Studio

    . Para Linux siga os passos abaixo:

        Acessar o link abaixo para fazer o download do arquivo .deb:

            https://go.microsoft.com/fwlink/?linkid=2169956

        cd ~
        sudo dpkg -i ./Downloads/azuredatastudio-linux-<version string>.deb
        azuredatastudio

    . Para Windows acesse o link abaixo:

        https://docs.microsoft.com/pt-br/sql/azure-data-studio/download-azure-data-studio?view=sql-server-ver15    


Aula 3. O que é injeção de dependência
--------------------------------------

    . Não é um padrão ( Design Pattern )

    . Técnica que implement o IoC

        . Inversion of Control
        . DIP

    . Ajuda no baixo acoplamento

    . Provê uma melhor divisão de responsabilidades

    . O que eu preciso para trabalhar?
        . Quem vai me prover? Não importa.


Aula 4 - Baixo acoplamento
--------------------------

    . Imagina um sistema grande
    
    . Cada pedacinho tem que focar em uma coisa
        . Não dá pra abraçar o mundo 

    . Tem que funcionar de forma independente

        . Fácil de entender
        . Fácil de dar manuteção
        . Se precisar jogar fora e criar outro é fácil

Aula 5. Mau exemplo
-------------------

    . Vamos tomar como base um pedido

    . Receber os parâmetros

    . Processa o pedido

Aula 6. Entendento o problema
-----------------------------

    . O problema

        . Dificil de ler

        . Dificil de mudar

        . Código não é reusável

        . Alto acoplamento

        . Teste? pra quê?

Aula 7. Resolvendo o problema com OOP
-------------------------------------

    . OO

        . Abstração, encapsulamento 
            . Simpels e direto

        . Pedaços pequenos

        . Reusáveis

        . Testáveis

        . Legiveis

        . Fácil manutenção

Aula 8. Cobre o pé, descobre a cabeça
-------------------------------------

    . Está bem melhor, mas...

    . A dependência ainda existe 

        . Só mudou de lugar

    . Depende da implementação 

        . Depender da abastração.

    . Exemplo:

        . Sem injeção de dependência:

            public class OrderController: Controller{

                [Route("v1/orders")]
                [HttpPost]
                public async Task<string> Place(    string cutomerId,
                                                    string zipCode,
                                                    string promoCode,
                                                    int[] products){
                    ...
                    var deliveryService = new DeliveryService();

                    decimal deliveryFee = deliveryService.GetDeliveryFee( zipCode );
                    ...
                }
            }

        . Com injeção de dependência:

            public class OrderController: Controller{

                private readonly DeliveryService _deliveryService;

                OrderController( DeliveryService deliveryService){
                    _deliveryService = deliveryService;
                }

                [Route("v1/orders")]
                [HttpPost]
                public async Task<string> Place(    string cutomerId,
                                                    string zipCode,
                                                    string promoCode,
                                                    int[] products){
                    ...
                    decimal deliveryFee = _deliveryService.GetDeliveryFee( zipCode );
                    ...
                }
            }

Aula 9. Inversão de controle
-----------------------------

    .Inversão de controle

    . Externiliza as responsabilidades

        . Delega

    . Cria uma dependêcia externa

        . O controller não é mais responsável pelo cálculo do frete,
            aogra ele depende de um serviço.

    . Exemplo:

        public class OrderController: Controller{

            private readonly DeliveryService _deliveryService;

            OrderController( DeliveryService deliveryService){
                _deliveryService = deliveryService;
            }

            [Route("v1/orders")]
            [HttpPost]
            public async Task<string> Place(    string cutomerId,
                                                string zipCode,
                                                string promoCode,
                                                int[] products){
                ...
                decimal deliveryFee = _deliberyService.GetDeliveryFee( zipCode );
            }
        }

Aula 10. Abstração e implementação
---------------------------------

    . Impelmentalçao

        . Concreto

        . Materialização

        . É o "Como"

    . Abstração 

        . Contrato

        . Só as definições

        . é o "O que"

    . Nem tudo precisa abstrair, ou criar uma interface para utilizar injeção de dependência

Aula 11. Porque abastrair?
------------------------

    . Facilita as mudanças

        . Imagina um cenário crítico como a troca de um banco de dados

    . Testes de Unidade

        . Não podem depender de banco, rede ou qq outra coisa externa

    . Se vc depende da abastração, a implementação não importa...

    . Exemplo:

        public class OrderController: Controller{

            private readonly DeliveryService _deliveryService;

            OrderController( DeliveryService deliveryService){
                _deliveryService = deliveryService;
            }

            [Route("v1/orders")]
            [HttpPost]
            public async Task<string> Place(    string cutomerId,
                                                string zipCode,
                                                string promoCode,
                                                int[] products
                                                [FromServices] DeliveryService deliveryService){
                ...
                decimal deliveryFee = deliberyService.GetDeliveryFee( zipCode );
            }
        }

Aula 12. Princípio da Inversão de Dependência
---------------------------------------------

    . Princípio da inversão de dependênci

    . Depender de abstrações e não de implemnetações

    . Exemplo

        public interface IDeliveryService{
            decimal GetDeliveryFee( string zipCode);
        }

    . Usando a interface

        public class DeliverService: IDeliveryService{
            public decimal GetDeliveryFee( string zipCode){
                ...
            }
        }

    . Utilização no Controller:

        public class OrderController: Controller{

            private readonly IDeliveryService _deliveryService;

            OrderController( IDeliveryService deliveryService){
                _deliveryService = deliveryService;
            }

            ...
        }

    . Utilização da abstração nos testes:

        public FakeDeliveryService: IDeliveryService{
            public decimal GetDeliveryFee( string zipCode ){
                return 10;
            }
        }

        ...

        [TestMethod]
        public void ShouldPlaceAndOrder(){
            IDeliveryService service = new FackeDeliveryService();
            var controller = new OrderController( service );
        }

        . Para fazer testes automatizados, posso criar uma uma classe "Fake" sem a necessidade de depender de 
            outras classes, banco de dados, etc.

    . Muito sugerido pelos princípios SOLID

Aula 13. Service Locator
------------------------

    . SL diz como resolver as depências criadas 

        . Funciona como um dê-para

    . Já temos um pronto no ASP.NET (build in the box)

        . Podemos utilizar outros 

            // Assim
            builder.Services.AddTransient<IDeliveryFeeService, DeliveryFeeService>();

            // ou
            builder.Services.AddScoped<IDeliveryFeeService, DeliveryFeeService>();

            // ou
            builder.Services.AddSingleton<IDeliveryFeeService, DeliveryFeeService>();

Aula 14. AddTransient, AddScoped, AddSingleton
----------------------------------------------

    . AddTransient

        builder.Services.AddTransient<IDeliveryFeeService,, DeliveryFeeService>();

            . Sempre cira uma nova instância do objeto

            . Ideal para cenários onde queremos sempre um novo objeto.

    . AddScoped

        builder.Services.AddScoped<IDeliveryFeeService,, DeliveryFeeService>();

            . Cria um objeto por transação/requisição

            . Se você chamar 2 ou mais serviços que dendem do mesmo objeto, a mesma instância será utilizada

            . Ideal para cenários onde queremos apenas um objeto por requisição (banco).

    . AddSingleton

        . Cria um objeto quando a aplicação inicia e apaga da sessão quando a aplicação termina.

            builder.Services.AddSingleton<IDeliveryFeeService, DeliveryFeeService>();

        . Mantém este objeto na memória até a aplicação para ou reiniciar 

        . Sempre devolve a mesma instância deste objeto, com os mesmos valores.

        . Padrão que visa garantir apenas um instância de um objeto para aplicão toda

        . Um bom exemplo são as configurações

            . Uma vez carregadas, ficam até a aplicação reiniciar.

        . Cuidado.


Aula 15. AddDbContext
---------------------

    . Item especial do tipo Scoped

        builder.Services.AddDbContext< BlogDataContext>( x => useSqlServer( connStr ));

    . Utilizado exclusivamente com o EF

    . Garante que a conexão só dura até o fim da requisição


Aula 16. Apresentação
---------------------

    . Acesse o prompt da pasta de projeto e execute o comando abaixo:

        git clone https://github.com/balta-io/2813.git


Aula 17. Criando Dependência
----------------------------

    . Acesse a pasta "01. Inicial/DependencyStore" e entre no VSCode colocando essa pasta como raiz nele

    . Acesse a classe "Controllers/OrderController.cs"

    . Crie a pasta "Repositories" dentro da pasta raiz e dentro dela crie a classe abaixo:

        using Dapper;
        using Dependency.Models;
        using Microsoft.Data.SqlClient;


        namespce DependencyStore.Repositories;

        public class CustomerRepository{

            // Padrão de nomenclatura para propriedades privadas é iniciar com o caracter "_"
            //
            // O "readonly" só permite atribuir um valor a propriedade somente dentro do construtor
            private readonly SqlConnection _connection;

            // Poderiamos criar o método construtor com um "Expression Body" por termos somente uma linha
            //public CustomerRepository( SqlConnection connection ) => _connection = connection;

            public CustomerRepository( SqlConnection connection ){
                _connection = connection;
            }
            
            public async Task<Customer?> GetByIdAsync( string customerId){

                const string query = "SELECT [Id], [Name], [Email] FROM CUSTOMER WHERE ID=@id";
                
                return await _connection.QueryFirstOrDefaultAsync<Customer>(query, new  { 
                                                                                            id = customerId 
                                                                                        });
            }
        }

Aula 18. DIP na prática 
-----------------------

    . Crie a pasta "Repositories/Contracts/" dentro da pasta "DependencyStore".

    . Dentro da pasta criada crie a interface abaixo:

        using DependecyStore.Models;

        namespace DependencyStore.Repositories.Contracts;

        public interace ICustomerRepository{
            Task<Customer?> GetByIdAsync( string customerId );
        }

    . Faça a implementação da interface acima na classe "CustomerRepository":

        namespace DependencyStore.Repositories;

        public class CustomerRepository: ICustomerRepository{       // Linha alterada
            ...
        }

    . Acesse a classe "OrderController" e crie a propriedade "CustomerRepository" que será utilizada na injeção de dependência:

        public class OrderController: ControllerBase{
            private readonly ICursotmreRepository _customerRepository;              // Linha Inserida

            public OrderController( ICustormerRepository customerRepository ){      // Construtor Inserido
                _customerRepository = customerRepository;
            }

            ....

            [Route("v1/orders")]
            [HttpPost]
            public async Task<IActionResult> Place(string customerId, string zipCode, string promoCode, int[] products)
            {
                // #1 - Recupera o cliente
                // Customer customer = null;
                // await using (var conn = new SqlConnection("CONN_STRING"))
                // {
                //     const string query = "SELECT [Id], [Name], [Email] FROM CUSTOMER WHERE ID=@id";
                //     customer = await conn.QueryFirstAsync<Customer>(query, new { id = customerId });
                // }

                var customer = await customerRepository.GetByIdAsync( customerId );     // Linha Inserida

                if ( customer == null ){                                                // if inserida
                    return NotFound();
                }

                ....
            }


        }


Aula 19. Utilizando serviços
----------------------------

    . Adicionar as packages "Dapper", "Microsoft.Data.SqlClient" e "RestSharp". Ver no projeto "01. Final" no arquivo .csproj a versões


    . Crie a pasta "Contracts/DeliveryFeeService".

    . Dentro da pasta recém criada crie a interface abaixo:

        namespace DependencyStore.Services.Contracts;

        public interface IDeliveryFeeService
        {
            Task<decimal> GetDeliveryFeeAsync(string zipCode);
        }

    . Crie a classe "DeliveryFeeService" na pasta "Services":

        using DependencyStore.Services.Contracts;
        using RestSharp;

        namespace DependencyStore.Services;

        public class DeliveryFeeService : IDeliveryFeeService
        {
            public async Task<decimal> GetDeliveryFeeAsync(string zipCode)
            {
                var client = new RestClient("https://api.myorg.com");
                var request = new RestRequest()
                    .AddJsonBody(new
                    {
                        ZipCode = zipCode
                    });
                var response = await client.PostAsync<decimal>(request);

                // Caso não consiga obter a taxa de entrega o valor padrão é 5
                return response == 0 ? 5 : response;
            }
        }

    . Acesse a classe "OrderController" e crie a propriedade "_deliveryFeeService" que será utilizada na injeção de dependência:

        public class OrderController: ControllerBase{
            private readonly ICursotmerRepository _customerRepository;              

            private readonly IDeliveryFeeService _deliveryFeeService;               // Linha Inserida

            public OrderController( ICustormerRepository customerRepository,
                                    IDeliveryFeeService deliverFeeService ){      // Linha Inserida
                _customerRepository = customerRepository;
                _deliverFeeService = deliveryFeeService;                         // Linha Inserida
            }

            [Route("v1/orders")]
            [HttpPost]
            public async Task<IActionResult> Place(string customerId, string zipCode, string promoCode, int[] products)
            {

                ...

                // Comente as linhas abaixo

                // #2 - Calcula o frete
                // decimal deliveryFee = 0;
                // var client = new RestClient("https://consultafrete.io/cep/");
                // var request = new RestRequest()
                //     .AddJsonBody(new
                //     {
                //         zipCode
                //     });
                // deliveryFee = await client.PostAsync<decimal>(request, new CancellationToken());
                // Nunca é menos que R$ 5,00
                // if (deliveryFee < 5)
                //     deliveryFee = 5;

                decimal deliveryFee = await _deliveryFeeService.GetDeliveryFeeAsync( zipCode );     // Linha inserida

                ....
            }
        }

Aula 20. PromoCode Repository
-----------------------------

    . Dentro da pasta "Repositories/Contracts" crie a interface abaixo:

        using DependencyStore.Models;

        namespace DependencyStore.Repositories.Contracts;

        public interface IPromoCodeRepository
        {
            Task<PromoCode?> GetPromoCodeAsync(string promoCode);
        }

    . Dentro da pasta "Repositories" crie a classe "PromoCodeRepository":

        using Dapper;
        using DependencyStore.Models;
        using DependencyStore.Repositories.Contracts;
        using Microsoft.Data.SqlClient;

        namespace DependencyStore.Repositories;

        public class PromoCodeRepository : IPromoCodeRepository
        {
            private readonly SqlConnection _connection;

            public PromoCodeRepository(SqlConnection connection)
                => _connection = connection;

            public async Task<PromoCode?> GetPromoCodeAsync(string promoCode)
            {
                var query = $"SELECT * FROM PROMO_CODES WHERE CODE={promoCode}";
                return await _connection.QueryFirstOrDefaultAsync<PromoCode>(query);
            }
        }

    . Acesse a classe "OrderController" e crie a propriedade "_promoCodeRepository" que será utilizada na injeção de dependência:

        public class OrderController: ControllerBase{
            private readonly ICursotmerRepository _customerRepository;              

            private readonly IDeliveryFeeService _deliveryFeeService;               

            private readonly IPromoCodeRepository _promoCodeRepository;         // Linha Inserida

            public OrderController( ICustormerRepository customerRepository,
                                    IDeliveryFeeService deliverFeeService,
                                    IPromoCodeRepository promoCodeRepository ){         // Linha Inserida
                _customerRepository = customerRepository;
                _deliverFeeService = deliveryFeeService;                         
                _promoCodeRepository = promoCodeRepository;             // Linha Inserida
            }

            [Route("v1/orders")]
            [HttpPost]
            public async Task<IActionResult> Place(string customerId, string zipCode, string promoCode, int[] products)
            {

                ...

                decimal deliveryFee = await _deliveryFeeService.GetDeliveryFeeAsync( zipCode );     

                var cupon PromoCode? = await _promoCodeRepository( promoCode );     // Linha inserida

                ....
            }
        }


Aula 21. Removendo as regras de negócios do controlador
-------------------------------------------------------

    . O objetivo é tirar o máximo de código do "Controller".

    . Acesse a classe "OrderController" e crie a propriedade "_promoCodeRepository" que será utilizada na injeção de dependência:

        public class OrderController: ControllerBase{

            ...

            [Route("v1/orders")]
            [HttpPost]
            public async Task<IActionResult> Place(string customerId, string zipCode, string promoCode, int[] products)
            {

                ...

                var customer = await _customerRepository.GetCustomerAsync(customerId);

                if (customer == null )
                    return NotFound();

                var deliveryFee = await _deliveryFeeService.GetDeliveryFeeAsync(zipCode);
                var cupon = await _promoCodeRepository.GetPromoCodeAsync(promoCode);
                var discount = cupon?.Value ?? 0M;
                var order = new Order(deliveryFee, discount, new List<Product>());
                return $"Pedido {order.Code} gerado com sucesso!";

                /*      Comente
                
                    // #3 - Calcula o total dos produtos
                    decimal subTotal = 0;
                    const string getProductQuery = "SELECT [Id], [Name], [Price] FROM PRODUCT WHERE ID=@id";
                    for (var p = 0; p < products.Length; p++)
                    {
                        Product product;
                        await using (var conn = new SqlConnection("CONN_STRING"))
                            product = await conn.QueryFirstAsync<Product>(getProductQuery, new { Id = p });

                        subTotal += product.Price;
                    }

                    // #4 - Aplica o cupom de desconto
                    decimal discount = 0;
                    await using (var conn = new SqlConnection("CONN_STRING"))
                    {
                        const string query = "SELECT * FROM PROMO_CODES WHERE CODE=@code";
                        var promo = await conn.QueryFirstAsync<PromoCode>(query, new { code = promoCode });
                        if (promo.ExpireDate > DateTime.Now)
                            discount = promo.Value;
                    }

                    // #5 - Gera o pedido
                    var order = new Order();
                    order.Code = Guid.NewGuid().ToString().ToUpper().Substring(0, 8);
                    order.Date = DateTime.Now;
                    order.DeliveryFee = deliveryFee;
                    order.Discount = discount;
                    order.Products = products;
                    order.SubTotal = subTotal;

                    // #6 - Calcula o total
                    order.Total = subTotal - discount + deliveryFee;

                    // #7 - Retorna
                    return Ok(new
                    {
                        Message = $"Pedido {order.Code} gerado com sucesso!"
                    });
                */

                ....
            }
        }

    . Acesse a classe "Order.cs" e inclua os métodos abaixo:

        namespace DependencyStore.Models;

        public class Order
        {
            public Order(                                                       // Método inserido
                decimal deliveryFee,
                decimal discount,
                List<Product> products)
            {
                Code = Guid.NewGuid().ToString().ToUpper().Substring(0, 8);
                Date = DateTime.Now;
                DeliveryFee = deliveryFee;
                Discount = discount;
            }
            
            ...

            public List<Product> Products { get; set; }                     // Propriedade inserida
            public decimal SubTotal => Products.Sum(x => x.Price);          // Propriedade inserida
            public decimal Total => SubTotal - Discount + DeliveryFee;      // Propriedade inserida


        }

Aula 22.  Resolvendo as dependências - AddTransient 
---------------------------------------------------

    . Acesse a classe "Program.cs" e acrescente as linhas abaixo:


        var builder = WebApplication.CreateBuilder(args);

        builder.Services.AddTransient<ICustomerRepository, CustomerRepository>();       // Na linha inserida 
        builder.Services.AddTransient<IPromoCodeRepository, PromoCodeRepository>();     // Na linha inserida 
        builder.Services.AddTransient<IDeliveryFeeService, DeliveryFeeService>();       // Na linha inserida 

        builder.Services.AddControllers();

        var app = builder.Build();

        app.MapControllers();

        app.Run();


        . Se quisessemos fazer a Injeção de Dependência para outros tipos de objetos poderiamos utilizar:

            builder.Services.AddTransient<CustomerRepository>();       // Para injetar diretamente a classe "CustomerRepository"
            
            ou

            builder.Services.AddTransient( new CustomerRepository() );       // Para injetar diretamente a classe "CustomerRepository"

        . O ".AddTransient" dará sempre uma instância nova para o objeto.


Aula 23. Resolvendo as dependências - AddScoped 
-----------------------------------------------

    . Acesse a classe "Program.cs" e acrescente as linhas abaixo:


        var builder = WebApplication.CreateBuilder(args);

        builder.Services.AddScoped( new SqlConnection("CONN_STRING") );             // Linha inserida                            // Linha inserida
        builder.Services.AddTransient<ICustomerRepository, CustomerRepository>();       
        builder.Services.AddTransient<IPromoCodeRepository, PromoCodeRepository>();     
        builder.Services.AddTransient<IDeliveryFeeService, DeliveryFeeService>();       

        builder.Services.AddControllers();

        var app = builder.Build();

        app.MapControllers();

        app.Run();


        . ".AddScoped" cria um objeto por requisição

    
Aula 24. Resolvendo as dependências - AddSingleton 
--------------------------------------------------

    .".AddSingleton" cria um objeto uma única vez na aplicação

Aula 25.  Extension Methods
---------------------------

    . Permitem adicionar comportamentos as classes "built-in" do .NET

    . Como por exemplo o "WebApplicationBuilder.cs"


Aula 26. Implementando Extension Methods
----------------------------------------

    . Toda classe de extensão precisa ser estática

        ...
        public static Utils{
            ...
        }

    . Dentro da classe estática devemos criar os métodos de extensão, que também devem ser estáticos:

        ...
        public static Utils{

            public static bool EhMaior(...){...}
        }

    . A assinatura do método deve conter como primeiros parâmetro do tipo "this" e em seguida a classe que pretendemos 
        fazer a extensão "EhMaior( this int <nome parâmetro>, ...)". Podemos utilizar tipos primitivos, ou classes.

                 +------------> Obbrigatório ser estática
        ...      |
        public static Utils{                 +--------> Classe/Tipo Primitivo que receberá a extensão
                                             |
            public static bool EhMaior(this int param, int secondParam ){ return param > secondParam }
                      |                 |
                      |                 +---> Identifica que este método é de extensão
        }             +---> Obrigatório ser estático


    . A partir do momento que definimos a classe acima os objetos que derivam de "int" terá disponível o método "EhMaior":

        ...
        int numero = 10;

        if (numero.EhMaior( 20 ) ){
            ...
        }

    . Voltando ao projeto, crie a pasta "Extensions" dentro da pasta raiz do projeto e crie a classe de extensão abaixo:

        using DependencyStore.Repositories;
        using DependencyStore.Repositories.Contracts;
        using DependencyStore.Services;
        using DependencyStore.Services.Contracts;
        using Microsoft.Data.SqlClient;
        using Microsoft.Extensions.DependencyInjection.Extensions;

        namespace DependencyStore.Extensions;

        public static class DependenciesExtension
        {
            public static void AddSqlConnection(
                this IServiceCollection services, 
                string connectionString)
            {
                services.AddScoped<SqlConnection>(x 
                    => new SqlConnection(connectionString));
            }
            public static void AddRepositories(this IServiceCollection services)
            {
                services.TryAddTransient<ICustomerRepository, CustomerRepository>();
                services.AddTransient<IPromoCodeRepository, PromoCodeRepository>();
            }
            
            public static void AddServices(this IServiceCollection services)
            {
                services.AddTransient<IDeliveryFeeService, DeliveryFeeService>();
            }
        }

    . Acesse a classe "Program.cs", apague e insira as linhas abaixo:


        using DependencyStore.Extensions;

        var builder = WebApplication.CreateBuilder(args);

        builder.Services.AddControllers();
        builder.Services.AddEndpointsApiExplorer();
        builder.Services.AddSwaggerGen();
        builder.Services.AddControllers();

        /* Linhas Eliminadas

            builder.Services.AddScoped( new SqlConnection("CONN_STRING") );
            builder.Services.AddTransient<ICustomerRepository, CustomerRepository>();       
            builder.Services.AddTransient<IPromoCodeRepository, PromoCodeRepository>();     
            builder.Services.AddTransient<IDeliveryFeeService, DeliveryFeeService>();       

        */
                                                    +------> Este método não existe, criar um método de extensão
                                                    |
        var connStr = builder.Configuration.GetConnectionString("DefaultConnection");       // Linha inserida
        builder.Services.AddSqlConnection(connStr);                                         // Linha inserida
        builder.Services.AddRepositories();                                                 // Linha inserida
        builder.Services.AddServices();                                                     // Linha inserida

        var app = builder.Build();

        app.UseAuthorization();
        app.MapControllers();

        app.Run();


Aula 27. Registrando mais de uma implementação
----------------------------------------------

    . O que acontece com a implementação abaixo? onde temos mais de uma 
        implementação para a mesma interface.

        ...
        public interface IService{

        }

        public class ServiceOne: IService{

        }

        public classe ServiceTwo: IService{

        }
        ...

    . Program.cs

        ...
        builder.Services.AddTransient<IService, ServiceOne>();
        builder.Services.AddTransient<IService. ServiceTwo>();
        ...

    . No caso acima, o .NET retornará sempre a última classe registrada, assim a "ServiceTwo".

        ...
        private readonly IService _service;

        public OrderController( IService service) 
            => _service = service;

        [Route("/")]
        [HttpGet]
        public IActionResult Get(){
            return Ok( new {
                            _service.GetType.Name
                        });
        }

    . Embora o .NET retorne sempre a última classe registrada, não significa que ele deixou de 
        registrar as demais classes:

        builder.Service.AddTransient<IService, ServiceOne>();
        builder.Service.AddTransient<IService, ServiceOne>();
        builder.Service.AddTransient<IService, ServiceOne>();
        builder.Service.AddTransient<IService, ServiceTwo>();
        
    . Se formos verificar as classes registradas, todas estarão lá, mas sempre retornará a última 
        registrada:

        ...
        private readonly IEnumerable<IService> _service;

        public OrderController(IEnumerable<IService> service)
            => _service = service;

        [Route("/")]
        [HttpGet]
        public IActionResult Get(){
            return Ok( x => n.GetType().Name  });
        }


        // Saída
        [
            "ServiceOne",
            "ServiceOne",
            "ServiceOne",
            "ServiceTwo"            
        ]


Aula 28.  Service Descriptor
----------------------------

    . Descreve como resolver uma dependência

    . Determina o tipo e tempo de vida dela

    . AddTransient, AddScoped e AddSingleton são "wrapers" deste item.

    . Como conseguir o objeto da classe desejada:

        ...
        va descriptor = new ServiceDescriptor(
            typeof(IService),   // Abstração
            typeof( ServiceOne ),   // Implementação
            ServiceLifetime.Singleton   // Tempo de vida
        );

        builder.Services.Add( descriptor );

    
https://medium.com/volosoft/asp-net-core-dependency-injection-58bc78c5d369
https://jinalkumarpatel.hashnode.dev/dependency-injection-in-net-core


Aula 29.  TryAdd e TryAddEnumerable
-----------------------------------

    . TryAdd    - Só registra um item por interface:

        ...
        builder.Services.TryAddTransiente<IService, ServiceOne>();
        builder.Services.TryAddTransiente<IService, ServiceOne>();
        ...

   . Se formos verificar as classes registradas, só estarão uma lá:

        ...
        private readonly IEnumerable<IService> _service;

        public OrderController(IEnumerable<IService> service)
            => _service = service;

        [Route("/")]
        [HttpGet]
        public IActionResult Get(){
            return Ok( x => n.GetType().Name  });
        }


        // Saída
        [
            "ServiceOne"
        ]

Aula 30. [FromService]
----------------------

    . You can directly inject a dependency into an action method by passing it as a parameter 
        to the method and using the [FromServices] attribute. During model binding,
        the framework will resolve the parameter from the DI container, instead of from the
        request values. This listing shows how you could rewrite listing to use [FromServices] 
        instead of constructor injection.

        public class UserController : ControllerBase
        {
            // The [FromServices] attribute ensures IMessageSender is
            // resolved from the DI container. IMessageSender is
            // only available in RegisterUser.

            [HttpPost("register")]
            public IActionResult RegisterUser( [FromServices] IMessageSender messageSender,
                                                string username)
            {
                messageSender.SendMessage(username);        // IMessageSender is
                                                            // only available in RegisterUser.
                return Ok();
            }

            [HttpPost("promote")]
            public IActionResult PromoteUser( [FromServices] IPromotionService promoService,
                                                string username, int level)
            {
                promoService.PromoteUser(username, level);
                return Ok();
            }
        }


    . You might be tempted to use the [FromServices] attribute in all your action methods, 
        but I’d encourage you to use standard constructor injection most of the time.
        Having the constructor as a single location that declares all the dependencies of a
        class can be useful, so I only use [FromServices] in the rare cases where creating an
        instance of a dependency is expensive and is only used in a single action method.


Aula 31. Hora da Entrevista
---------------------------

    [Pegar as perguntas dessa aula e responder ]


    https://www.c-sharpcorner.com/article/multiple-interface-implementations-in-asp-net-core/

